{"language":"Solidity","sources":{"contracts/composability/ComposableExecutionModule.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport { IExecutor } from \"erc7579/interfaces/IERC7579Module.sol\";\nimport { IERC7579Account, Execution } from \"erc7579/interfaces/IERC7579Account.sol\";\nimport { ModeLib } from \"erc7579/lib/ModeLib.sol\";\nimport { ExecutionLib } from \"erc7579/lib/ExecutionLib.sol\";\nimport { ERC7579FallbackBase } from \"module-bases/ERC7579FallbackBase.sol\";\nimport { IComposableExecutionModule } from \"../interfaces/IComposableExecution.sol\";\nimport { ComposableExecutionLib } from \"./ComposableExecutionLib.sol\";\nimport { InputParam, OutputParam, ComposableExecution } from \"../types/ComposabilityDataTypes.sol\";\n\n/**\n * @title Composable Execution Module: Executor and Fallback\n * @dev A module for ERC-7579 accounts that enables composable transactions execution\n */\ncontract ComposableExecutionModule is IComposableExecutionModule, IExecutor, ERC7579FallbackBase {\n    address private constant ENTRY_POINT_V07_ADDRESS = 0x0000000071727De22E5E9d8BAf0edAc6f37da032;\n    address public immutable DEFAULT_EP_ADDRESS;\n    address private immutable THIS_ADDRESS;\n\n    using ComposableExecutionLib for InputParam[];\n    using ComposableExecutionLib for OutputParam[];\n\n    error OnlyEntryPointOrAccount();\n    error ZeroAddressNotAllowed();\n    error FailedToReturnMsgValue();\n    error DelegateCallOnly();\n\n    /// @notice Mapping of smart account addresses to the EP address\n    mapping(address => address) private entryPoints;\n\n    constructor(address _defaultEpAddress) {\n        if (_defaultEpAddress == address(0)) {\n            DEFAULT_EP_ADDRESS = ENTRY_POINT_V07_ADDRESS;\n        } else {\n            DEFAULT_EP_ADDRESS = _defaultEpAddress;\n        }\n        THIS_ADDRESS = address(this);\n    }\n\n    /**\n     * @notice Executes a composable transaction with dynamic parameter composition and return value handling\n     * @dev To be used via fallback() from the account\n     * @dev As per ERC-7579 account MUST append original msg.sender address to the calldata in a way specified by\n     * ERC-2771\n     * @dev Returns the msg.value back to the sender (account) if any. This is done because in most cases the\n     * SA.fallback\n     * forwards value to this module. This allows SA receiving value along with the composable execution call processed\n     * via\n     * fallback.\n     */\n    function executeComposable(ComposableExecution[] calldata cExecutions) external payable {\n        // access control\n        address sender = _msgSender();\n        // in most cases, only first condition (against constant) will be checked\n        // so no extra sloads\n        require(\n            sender == DEFAULT_EP_ADDRESS || sender == entryPoints[msg.sender] || sender == msg.sender,\n            OnlyEntryPointOrAccount()\n        );\n        _returnMsgValue();\n        _executeComposable(cExecutions, msg.sender, _executeExecutionCall);\n    }\n\n    /// @notice It doesn't require access control as it is expected to be called by the account itself via .execute()\n    /// @dev !!! Attention !!! This function should NEVER be installed to be used via fallback() as it doesn't implement\n    /// access control\n    /// thus it will be callable by any address account.executeComposableCall => fallback() =>\n    /// this.executeComposableCall\n    function executeComposableCall(ComposableExecution[] calldata cExecutions) external {\n        _executeComposable(cExecutions, msg.sender, _executeExecutionCall);\n    }\n\n    /// @notice It doesn't require access control as it is expected to be called by the account itself via .execute(mode\n    /// =\n    /// delegatecall)\n    function executeComposableDelegateCall(ComposableExecution[] calldata cExecutions) external {\n        require(THIS_ADDRESS != address(this), DelegateCallOnly());\n        _executeComposable(cExecutions, address(this), _executeExecutionDelegatecall);\n    }\n\n    /// @dev internal function to execute the composable execution flow\n    /// @param cExecutions - the composable executions to execute\n    /// @param account - the account to execute the composable executions on\n    /// @param executeExecutionFunction - the function to execute the composable executions\n    function _executeComposable(\n        ComposableExecution[] calldata cExecutions,\n        address account,\n        function(Execution memory) internal returns (bytes[] memory) executeExecutionFunction\n    )\n        internal\n    {\n        // we can not use erc-7579 batch mode here because we may need to compose\n        // the next call in the batch based on the execution result of the previous call\n        uint256 length = cExecutions.length;\n        for (uint256 i; i < length; i++) {\n            ComposableExecution calldata cExecution = cExecutions[i];\n            Execution memory execution = cExecution.inputParams.processInputs(cExecution.functionSig);\n            bytes[] memory returnData;\n            if (execution.target != address(0)) {\n                returnData = executeExecutionFunction(execution);\n            } else {\n                returnData = new bytes[](1);\n                returnData[0] = \"\";\n            }\n            cExecution.outputParams.processOutputs(returnData[0], account);\n        }\n    }\n\n    /// @dev function to be used as an argument for _executeComposable in case of regular call\n    function _executeExecutionCall(Execution memory execution) internal returns (bytes[] memory) {\n        return IERC7579Account(msg.sender)\n            .executeFromExecutor({\n                mode: ModeLib.encodeSimpleSingle(),\n                executionCalldata: ExecutionLib.encodeSingle(execution.target, execution.value, execution.callData)\n            });\n    }\n\n    /// @dev function to be used as an argument for _executeComposable in case of delegatecall\n    function _executeExecutionDelegatecall(Execution memory execution) internal returns (bytes[] memory returnData) {\n        returnData = new bytes[](1);\n        returnData[0] = _execute(execution.target, execution.value, execution.callData);\n    }\n\n    /// @dev sets the entry point for the account\n    function setEntryPoint(address _entryPoint) external {\n        require(_entryPoint != address(0), ZeroAddressNotAllowed());\n        entryPoints[msg.sender] = _entryPoint;\n    }\n\n    /// @dev returns the entry point address\n    function getEntryPoint(address account) external view returns (address) {\n        return entryPoints[account] == address(0) ? DEFAULT_EP_ADDRESS : entryPoints[account];\n    }\n\n    /// @dev called when the module is installed\n    /// @dev expected behavior: reverts if tried to initialize the module for the same account more than once\n    /// inner require checks if some account just sends same data for both fallback and executor\n    function onInstall(bytes calldata data) external override {\n        if (data.length >= 20) {\n            if (entryPoints[msg.sender] != address(0)) {\n                require(entryPoints[msg.sender] == address(bytes20(data[0:20])), AlreadyInitialized(msg.sender));\n                return;\n            }\n            entryPoints[msg.sender] = address(bytes20(data[0:20]));\n        }\n    }\n\n    /// @dev returns true if the module is initialized for the given account\n    function isInitialized(address account) external view returns (bool) {\n        return entryPoints[account] != address(0);\n    }\n\n    /// @dev called when the module is uninstalled\n    function onUninstall(bytes calldata) external override {\n        delete entryPoints[msg.sender];\n    }\n\n    /// @dev Reports that this module is an executor and a fallback module\n    function isModuleType(uint256 moduleTypeId) external pure override returns (bool) {\n        return moduleTypeId == TYPE_EXECUTOR || moduleTypeId == TYPE_FALLBACK;\n    }\n\n    /// @notice Executes a call to a target address with specified value and data.\n    /// @notice calls to an EOA should be counted as successful.\n    /// @param target The address to execute the call on.\n    /// @param value The amount of wei to send with the call.\n    /// @param callData The calldata to send.\n    /// @return result The bytes returned from the execution, which contains the returned data from the target address.\n    function _execute(\n        address target,\n        uint256 value,\n        bytes memory callData\n    )\n        internal\n        virtual\n        returns (bytes memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            if iszero(call(gas(), target, value, add(callData, 0x20), mload(callData), codesize(), 0x00)) {\n                // Bubble up the revert if the call reverts.\n                returndatacopy(result, 0x00, returndatasize())\n                revert(result, returndatasize())\n            }\n            mstore(result, returndatasize()) // Store the length.\n            let o := add(result, 0x20)\n            returndatacopy(o, 0x00, returndatasize()) // Copy the returndata.\n            mstore(0x40, add(o, returndatasize())) // Allocate the memory.\n        }\n    }\n\n    // Returns the msg.value back to the sender (account)\n    function _returnMsgValue() internal {\n        if (msg.value > 0) {\n            (bool success,) = payable(msg.sender).call{ value: msg.value }(\"\");\n            require(success, FailedToReturnMsgValue());\n        }\n    }\n}\n"},"node_modules/@erc7579/implementation/src/interfaces/IERC7579Module.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.21;\n\nimport { PackedUserOperation } from \"account-abstraction/interfaces/PackedUserOperation.sol\";\n\nuint256 constant VALIDATION_SUCCESS = 0;\nuint256 constant VALIDATION_FAILED = 1;\n\nuint256 constant MODULE_TYPE_VALIDATOR = 1;\nuint256 constant MODULE_TYPE_EXECUTOR = 2;\nuint256 constant MODULE_TYPE_FALLBACK = 3;\nuint256 constant MODULE_TYPE_HOOK = 4;\nuint256 constant MODULE_TYPE_PREVALIDATION_HOOK_ERC1271 = 8;\nuint256 constant MODULE_TYPE_PREVALIDATION_HOOK_ERC4337 = 9;\n\ninterface IModule {\n    error AlreadyInitialized(address smartAccount);\n    error NotInitialized(address smartAccount);\n\n    /**\n     * @dev This function is called by the smart account during installation of the module\n     * @param data arbitrary data that may be required on the module during `onInstall`\n     * initialization\n     *\n     * MUST revert on error (i.e. if module is already enabled)\n     */\n    function onInstall(bytes calldata data) external;\n\n    /**\n     * @dev This function is called by the smart account during uninstallation of the module\n     * @param data arbitrary data that may be required on the module during `onUninstall`\n     * de-initialization\n     *\n     * MUST revert on error\n     */\n    function onUninstall(bytes calldata data) external;\n\n    /**\n     * @dev Returns boolean value if module is a certain type\n     * @param moduleTypeId the module type ID according the ERC-7579 spec\n     *\n     * MUST return true if the module is of the given type and false otherwise\n     */\n    function isModuleType(uint256 moduleTypeId) external view returns (bool);\n\n    /**\n     * @dev Returns if the module was already initialized for a provided smartaccount\n     */\n    function isInitialized(address smartAccount) external view returns (bool);\n}\n\ninterface IValidator is IModule {\n    error InvalidTargetAddress(address target);\n\n    /**\n     * @dev Validates a transaction on behalf of the account.\n     *         This function is intended to be called by the MSA during the ERC-4337 validaton phase\n     *         Note: solely relying on bytes32 hash and signature is not suffcient for some\n     * validation implementations (i.e. SessionKeys often need access to userOp.calldata)\n     * @param userOp The user operation to be validated. The userOp MUST NOT contain any metadata.\n     * The MSA MUST clean up the userOp before sending it to the validator.\n     * @param userOpHash The hash of the user operation to be validated\n     * @return return value according to ERC-4337\n     */\n    function validateUserOp(\n        PackedUserOperation calldata userOp,\n        bytes32 userOpHash\n    )\n        external\n        returns (uint256);\n\n    /**\n     * Validator can be used for ERC-1271 validation\n     */\n    function isValidSignatureWithSender(\n        address sender,\n        bytes32 hash,\n        bytes calldata data\n    )\n        external\n        view\n        returns (bytes4);\n}\n\ninterface IExecutor is IModule { }\n\ninterface IHook is IModule {\n    function preCheck(\n        address msgSender,\n        uint256 msgValue,\n        bytes calldata msgData\n    )\n        external\n        returns (bytes memory hookData);\n\n    function postCheck(bytes calldata hookData) external;\n}\n\ninterface IFallback is IModule { }\n\ninterface IPreValidationHookERC1271 is IModule {\n    function preValidationHookERC1271(\n        address sender,\n        bytes32 hash,\n        bytes calldata data\n    )\n        external\n        view\n        returns (bytes32 hookHash, bytes memory hookSignature);\n}\n\ninterface IPreValidationHookERC4337 is IModule {\n    function preValidationHookERC4337(\n        PackedUserOperation calldata userOp,\n        uint256 missingAccountFunds,\n        bytes32 userOpHash\n    )\n        external\n        returns (bytes32 hookHash, bytes memory hookSignature);\n}\n"},"node_modules/@erc7579/implementation/src/interfaces/IERC7579Account.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.21;\n\nimport { CallType, ExecType, ModeCode } from \"../lib/ModeLib.sol\";\n\nstruct Execution {\n    address target;\n    uint256 value;\n    bytes callData;\n}\n\ninterface IERC7579Account {\n    event ModuleInstalled(uint256 moduleTypeId, address module);\n    event ModuleUninstalled(uint256 moduleTypeId, address module);\n\n    /**\n     * @dev Executes a transaction on behalf of the account.\n     *         This function is intended to be called by ERC-4337 EntryPoint.sol\n     * @dev Ensure adequate authorization control: i.e. onlyEntryPointOrSelf\n     *\n     * @dev MSA MUST implement this function signature.\n     * If a mode is requested that is not supported by the Account, it MUST revert\n     * @param mode The encoded execution mode of the transaction. See ModeLib.sol for details\n     * @param executionCalldata The encoded execution call data\n     */\n    function execute(ModeCode mode, bytes calldata executionCalldata) external payable;\n\n    /**\n     * @dev Executes a transaction on behalf of the account.\n     *         This function is intended to be called by Executor Modules\n     * @dev Ensure adequate authorization control: i.e. onlyExecutorModule\n     *\n     * @dev MSA MUST implement this function signature.\n     * If a mode is requested that is not supported by the Account, it MUST revert\n     * @param mode The encoded execution mode of the transaction. See ModeLib.sol for details\n     * @param executionCalldata The encoded execution call data\n     */\n    function executeFromExecutor(\n        ModeCode mode,\n        bytes calldata executionCalldata\n    )\n        external\n        payable\n        returns (bytes[] memory returnData);\n\n    /**\n     * @dev ERC-1271 isValidSignature\n     *         This function is intended to be used to validate a smart account signature\n     * and may forward the call to a validator module\n     *\n     * @param hash The hash of the data that is signed\n     * @param data The data that is signed\n     */\n    function isValidSignature(bytes32 hash, bytes calldata data) external view returns (bytes4);\n\n    /**\n     * @dev installs a Module of a certain type on the smart account\n     * @dev Implement Authorization control of your chosing\n     * @param moduleTypeId the module type ID according the ERC-7579 spec\n     * @param module the module address\n     * @param initData arbitrary data that may be required on the module during `onInstall`\n     * initialization.\n     */\n    function installModule(\n        uint256 moduleTypeId,\n        address module,\n        bytes calldata initData\n    )\n        external\n        payable;\n\n    /**\n     * @dev uninstalls a Module of a certain type on the smart account\n     * @dev Implement Authorization control of your chosing\n     * @param moduleTypeId the module type ID according the ERC-7579 spec\n     * @param module the module address\n     * @param deInitData arbitrary data that may be required on the module during `onUninstall`\n     * de-initialization.\n     */\n    function uninstallModule(\n        uint256 moduleTypeId,\n        address module,\n        bytes calldata deInitData\n    )\n        external\n        payable;\n\n    /**\n     * Function to check if the account supports a certain CallType or ExecType (see ModeLib.sol)\n     * @param encodedMode the encoded mode\n     */\n    function supportsExecutionMode(ModeCode encodedMode) external view returns (bool);\n\n    /**\n     * Function to check if the account supports installation of a certain module type Id\n     * @param moduleTypeId the module type ID according the ERC-7579 spec\n     */\n    function supportsModule(uint256 moduleTypeId) external view returns (bool);\n\n    /**\n     * Function to check if the account has a certain module installed\n     * @param moduleTypeId the module type ID according the ERC-7579 spec\n     *      Note: keep in mind that some contracts can be multiple module types at the same time. It\n     *            thus may be necessary to query multiple module types\n     * @param module the module address\n     * @param additionalContext additional context data that the smart account may interpret to\n     *                          identifiy conditions under which the module is installed.\n     *                          usually this is not necessary, but for some special hooks that\n     *                          are stored in mappings, this param might be needed\n     */\n    function isModuleInstalled(\n        uint256 moduleTypeId,\n        address module,\n        bytes calldata additionalContext\n    )\n        external\n        view\n        returns (bool);\n\n    /**\n     * @dev Returns the account id of the smart account\n     * @return accountImplementationId the account id of the smart account\n     * the accountId should be structured like so:\n     *        \"vendorname.accountname.semver\"\n     */\n    function accountId() external view returns (string memory accountImplementationId);\n}\n"},"node_modules/@erc7579/implementation/src/lib/ModeLib.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\n/**\n * @title ModeLib\n * To allow smart accounts to be very simple, but allow for more complex execution, A custom mode\n * encoding is used.\n *    Function Signature of execute function:\n *           function execute(ModeCode mode, bytes calldata executionCalldata) external payable;\n * This allows for a single bytes32 to be used to encode the execution mode, calltype, execType and\n * context.\n * NOTE: Simple Account implementations only have to scope for the most significant byte. Account  that\n * implement\n * more complex execution modes may use the entire bytes32.\n *\n * |--------------------------------------------------------------------|\n * | CALLTYPE  | EXECTYPE  |   UNUSED   | ModeSelector  |  ModePayload  |\n * |--------------------------------------------------------------------|\n * | 1 byte    | 1 byte    |   4 bytes  | 4 bytes       |   22 bytes    |\n * |--------------------------------------------------------------------|\n *\n * CALLTYPE: 1 byte\n * CallType is used to determine how the executeCalldata paramter of the execute function has to be\n * decoded.\n * It can be either single, batch or delegatecall. In the future different calls could be added.\n * CALLTYPE can be used by a validation module to determine how to decode <userOp.callData[36:]>.\n *\n * EXECTYPE: 1 byte\n * ExecType is used to determine how the account should handle the execution.\n * It can indicate if the execution should revert on failure or continue execution.\n * In the future more execution modes may be added.\n * Default Behavior (EXECTYPE = 0x00) is to revert on a single failed execution. If one execution in\n * a batch fails, the entire batch is reverted\n *\n * UNUSED: 4 bytes\n * Unused bytes are reserved for future use.\n *\n * ModeSelector: bytes4\n * The \"optional\" mode selector can be used by account vendors, to implement custom behavior in\n * their accounts.\n * the way a ModeSelector is to be calculated is bytes4(keccak256(\"vendorname.featurename\"))\n * this is to prevent collisions between different vendors, while allowing innovation and the\n * development of new features without coordination between ERC-7579 implementing accounts\n *\n * ModePayload: 22 bytes\n * Mode payload is used to pass additional data to the smart account execution, this may be\n * interpreted depending on the ModeSelector\n *\n * ExecutionCallData: n bytes\n * single, delegatecall or batch exec abi.encoded as bytes\n */\nimport { Execution } from \"../interfaces/IERC7579Account.sol\";\n\n// Custom type for improved developer experience\ntype ModeCode is bytes32;\n\ntype CallType is bytes1;\n\ntype ExecType is bytes1;\n\ntype ModeSelector is bytes4;\n\ntype ModePayload is bytes22;\n\n// Default CallType\nCallType constant CALLTYPE_SINGLE = CallType.wrap(0x00);\n// Batched CallType\nCallType constant CALLTYPE_BATCH = CallType.wrap(0x01);\n// @dev Implementing delegatecall is OPTIONAL!\n// implement delegatecall with extreme care.\nCallType constant CALLTYPE_STATIC = CallType.wrap(0xFE);\nCallType constant CALLTYPE_DELEGATECALL = CallType.wrap(0xFF);\n\n// @dev default behavior is to revert on failure\n// To allow very simple accounts to use mode encoding, the default behavior is to revert on failure\n// Since this is value 0x00, no additional encoding is required for simple accounts\nExecType constant EXECTYPE_DEFAULT = ExecType.wrap(0x00);\n// @dev account may elect to change execution behavior. For example \"try exec\" / \"allow fail\"\nExecType constant EXECTYPE_TRY = ExecType.wrap(0x01);\n\nModeSelector constant MODE_DEFAULT = ModeSelector.wrap(bytes4(0x00000000));\n// Example declaration of a custom mode selector\nModeSelector constant MODE_OFFSET = ModeSelector.wrap(bytes4(keccak256(\"default.mode.offset\")));\n\n/**\n * @dev ModeLib is a helper library to encode/decode ModeCodes\n */\nlibrary ModeLib {\n    function decode(ModeCode mode)\n        internal\n        pure\n        returns (\n            CallType _calltype,\n            ExecType _execType,\n            ModeSelector _modeSelector,\n            ModePayload _modePayload\n        )\n    {\n        assembly {\n            _calltype := mode\n            _execType := shl(8, mode)\n            _modeSelector := shl(48, mode)\n            _modePayload := shl(80, mode)\n        }\n    }\n\n    function encode(\n        CallType callType,\n        ExecType execType,\n        ModeSelector mode,\n        ModePayload payload\n    )\n        internal\n        pure\n        returns (ModeCode)\n    {\n        return ModeCode.wrap(\n            bytes32(\n                abi.encodePacked(callType, execType, bytes4(0), ModeSelector.unwrap(mode), payload)\n            )\n        );\n    }\n\n    function encodeSimpleBatch() internal pure returns (ModeCode mode) {\n        mode = encode(CALLTYPE_BATCH, EXECTYPE_DEFAULT, MODE_DEFAULT, ModePayload.wrap(0x00));\n    }\n\n    function encodeSimpleSingle() internal pure returns (ModeCode mode) {\n        mode = encode(CALLTYPE_SINGLE, EXECTYPE_DEFAULT, MODE_DEFAULT, ModePayload.wrap(0x00));\n    }\n\n    function getCallType(ModeCode mode) internal pure returns (CallType calltype) {\n        assembly {\n            calltype := mode\n        }\n    }\n}\n\nusing { eqModeSelector as == } for ModeSelector global;\nusing { eqCallType as == } for CallType global;\nusing { eqExecType as == } for ExecType global;\n\nfunction eqCallType(CallType a, CallType b) pure returns (bool) {\n    return CallType.unwrap(a) == CallType.unwrap(b);\n}\n\nfunction eqExecType(ExecType a, ExecType b) pure returns (bool) {\n    return ExecType.unwrap(a) == ExecType.unwrap(b);\n}\n\nfunction eqModeSelector(ModeSelector a, ModeSelector b) pure returns (bool) {\n    return ModeSelector.unwrap(a) == ModeSelector.unwrap(b);\n}\n"},"node_modules/@erc7579/implementation/src/lib/ExecutionLib.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\nimport { Execution } from \"../interfaces/IERC7579Account.sol\";\n\n/**\n * Helper Library for decoding Execution calldata\n * malloc for memory allocation is bad for gas. use this assembly instead\n */\nlibrary ExecutionLib {\n    error ERC7579DecodingError();\n\n    /**\n     * @notice Decode a batch of `Execution` executionBatch from a `bytes` calldata.\n     * @dev code is copied from solady's LibERC7579.sol\n     * https://github.com/Vectorized/solady/blob/740812cedc9a1fc11e17cb3d4569744367dedf19/src/accounts/LibERC7579.sol#L146\n     *      Credits to Vectorized and the Solady Team\n     */\n    function decodeBatch(bytes calldata executionCalldata)\n        internal\n        pure\n        returns (Execution[] calldata executionBatch)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let u := calldataload(executionCalldata.offset)\n            let s := add(executionCalldata.offset, u)\n            let e := sub(add(executionCalldata.offset, executionCalldata.length), 0x20)\n            executionBatch.offset := add(s, 0x20)\n            executionBatch.length := calldataload(s)\n            if or(shr(64, u), gt(add(s, shl(5, executionBatch.length)), e)) {\n                mstore(0x00, 0xba597e7e) // `DecodingError()`.\n                revert(0x1c, 0x04)\n            }\n            if executionBatch.length {\n                // Perform bounds checks on the decoded `executionBatch`.\n                // Loop runs out-of-gas if `executionBatch.length` is big enough to cause overflows.\n                for { let i := executionBatch.length } 1 { } {\n                    i := sub(i, 1)\n                    let p := calldataload(add(executionBatch.offset, shl(5, i)))\n                    let c := add(executionBatch.offset, p)\n                    let q := calldataload(add(c, 0x40))\n                    let o := add(c, q)\n                    // forgefmt: disable-next-item\n                    if or(shr(64, or(calldataload(o), or(p, q))),\n                        or(gt(add(c, 0x40), e), gt(add(o, calldataload(o)), e))) {\n                        mstore(0x00, 0xba597e7e) // `DecodingError()`.\n                        revert(0x1c, 0x04)\n                    }\n                    if iszero(i) { break }\n                }\n            }\n        }\n    }\n\n    function encodeBatch(Execution[] memory executions)\n        internal\n        pure\n        returns (bytes memory callData)\n    {\n        callData = abi.encode(executions);\n    }\n\n    function decodeSingle(bytes calldata executionCalldata)\n        internal\n        pure\n        returns (address target, uint256 value, bytes calldata callData)\n    {\n        target = address(bytes20(executionCalldata[0:20]));\n        value = uint256(bytes32(executionCalldata[20:52]));\n        callData = executionCalldata[52:];\n    }\n\n    function encodeSingle(\n        address target,\n        uint256 value,\n        bytes memory callData\n    )\n        internal\n        pure\n        returns (bytes memory userOpCalldata)\n    {\n        userOpCalldata = abi.encodePacked(target, value, callData);\n    }\n}\n"},"node_modules/@rhinestone/module-bases/src/ERC7579FallbackBase.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.25;\n\nimport { IERC7579Fallback } from \"./external/ERC7579.sol\";\nimport { ERC7579ModuleBase } from \"./ERC7579ModuleBase.sol\";\n\nabstract contract ERC7579FallbackBase is IERC7579Fallback, ERC7579ModuleBase {\n    /**\n     * @notice Allows fetching the original caller address.\n     * @dev This is only reliable in combination with a FallbackManager that supports this (e.g. Safe\n     * contract >=1.3.0).\n     *      When using this functionality make sure that the linked _manager (aka msg.sender)\n     * supports this.\n     *      This function does not rely on a trusted forwarder. Use the returned value only to\n     *      check information against the calling manager.\n     * @return sender Original caller address.\n     */\n    function _msgSender() internal pure returns (address sender) {\n        // The assembly code is more direct than the Solidity version using `abi.decode`.\n        /* solhint-disable no-inline-assembly */\n        /// @solidity memory-safe-assembly\n        assembly {\n            sender := shr(96, calldataload(sub(calldatasize(), 20)))\n        }\n        /* solhint-enable no-inline-assembly */\n    }\n}\n"},"contracts/interfaces/IComposableExecution.sol":{"content":"// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity ^0.8.23;\n\nimport { ComposableExecution } from \"../types/ComposabilityDataTypes.sol\";\n\ninterface IComposableExecution {\n    function executeComposable(ComposableExecution[] calldata cExecutions) external payable;\n}\n\ninterface IComposableExecutionModule is IComposableExecution {\n    function executeComposableCall(ComposableExecution[] calldata cExecutions) external;\n    function executeComposableDelegateCall(ComposableExecution[] calldata cExecutions) external;\n}\n"},"contracts/composability/ComposableExecutionLib.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\nimport { ComposableStorage } from \"./ComposableStorage.sol\";\nimport {\n    InputParam,\n    OutputParam,\n    Constraint,\n    ConstraintType,\n    InputParamType,\n    InputParamFetcherType,\n    OutputParamFetcherType\n} from \"../types/ComposabilityDataTypes.sol\";\nimport { Execution } from \"erc7579/interfaces/IERC7579Account.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n// Library for composable execution handling\nlibrary ComposableExecutionLib {\n    error ConstraintNotMet(ConstraintType constraintType);\n    error Output_StaticCallFailed();\n    error InvalidParameterEncoding(string message);\n    error InvalidOutputParamFetcherType();\n    error InvalidConstraintType();\n    error InvalidSetOfInputParams(string message);\n\n    // Process the input parameters and return the composed calldata\n    function processInputs(\n        InputParam[] calldata inputParams,\n        bytes4 functionSig\n    )\n        internal\n        view\n        returns (Execution memory)\n    {\n        address composedTarget;\n        uint256 composedValue;\n        bytes memory composedCalldata = abi.encodePacked(functionSig);\n        uint256 length = inputParams.length;\n\n        // Bit 0: TARGET param type set, Bit 1: VALUE param type set\n        uint256 paramTypeFlags = 0;\n        for (uint256 i; i < length; i++) {\n            bytes memory processedInput = processInput(inputParams[i]);\n            if (inputParams[i].paramType == InputParamType.TARGET) {\n                if (inputParams[i].fetcherType == InputParamFetcherType.BALANCE) {\n                    revert InvalidParameterEncoding(\"BALANCE fetcher type is not supported for TARGET param type\");\n                }\n                // Check if TARGET has already been set (bit 0)\n                if (paramTypeFlags & 1 != 0) {\n                    revert InvalidSetOfInputParams(\"TARGET param type can only be set once\");\n                }\n                paramTypeFlags |= 1; // Set bit 0\n                composedTarget = abi.decode(processedInput, (address));\n            } else if (inputParams[i].paramType == InputParamType.VALUE) {\n                // Check if VALUE has already been set (bit 1)\n                if (paramTypeFlags & 2 != 0) {\n                    revert InvalidSetOfInputParams(\"VALUE param type can only be set once\");\n                }\n                paramTypeFlags |= 2; // Set bit 1\n                composedValue = abi.decode(processedInput, (uint256));\n            } else if (inputParams[i].paramType == InputParamType.CALL_DATA) {\n                composedCalldata = bytes.concat(composedCalldata, processedInput);\n            } else {\n                revert InvalidParameterEncoding(\"Invalid param type\");\n            }\n        }\n        // if a param with TARGET type was not provided, it will be address(0)\n        // we don't restrict it since some calls may want to call address(0)\n        // if a param with VALUE type was not provided, it will be 0\n        // this is even more often case, as many calls happen with 0 value\n        return Execution({ target: composedTarget, value: composedValue, callData: composedCalldata });\n    }\n\n    // Process a single input parameter and return the composed calldata\n    function processInput(InputParam calldata param) internal view returns (bytes memory) {\n        if (param.fetcherType == InputParamFetcherType.RAW_BYTES) {\n            _validateConstraints(param.paramData, param.constraints);\n            return param.paramData;\n        } else if (param.fetcherType == InputParamFetcherType.STATIC_CALL) {\n            address contractAddr;\n            bytes calldata callData;\n            bytes calldata paramData = param.paramData;\n            // expect paramData to be abi.encode(address contractAddr, bytes callData)\n            assembly {\n                contractAddr := calldataload(paramData.offset)\n                let s := calldataload(add(paramData.offset, 0x20))\n                let u := add(paramData.offset, s)\n                callData.offset := add(u, 0x20)\n                callData.length := calldataload(u)\n            }\n            (bool success, bytes memory returnData) = contractAddr.staticcall(callData);\n            assembly {\n                if iszero(success) {\n                    // revert ComposableExecutionFailed()\n                    mstore(0x00, 0x6533cc8d)\n                    revert(0x1c, 0x04)\n                }\n            }\n            _validateConstraints(returnData, param.constraints);\n            return returnData;\n        } else if (param.fetcherType == InputParamFetcherType.BALANCE) {\n            address tokenAddr;\n            address account;\n            bytes calldata paramData = param.paramData;\n\n            // expect paramData to be abi.encodePacked(address token, address account)\n            // Validate exact length requirement\n            require(paramData.length == 40, InvalidParameterEncoding(\"Invalid paramData length\"));\n            assembly {\n                tokenAddr := shr(96, calldataload(paramData.offset))\n                account := shr(96, calldataload(add(paramData.offset, 0x14)))\n            }\n\n            uint256 balance;\n            if (tokenAddr == address(0)) {\n                balance = account.balance;\n            } else {\n                balance = IERC20(tokenAddr).balanceOf(account);\n            }\n            _validateConstraints(abi.encode(balance), param.constraints);\n            return abi.encode(balance);\n        } else {\n            revert InvalidParameterEncoding(\"Invalid param fetcher type\");\n        }\n    }\n\n    // Process the output parameters\n    function processOutputs(OutputParam[] calldata outputParams, bytes memory returnData, address account) internal {\n        uint256 length = outputParams.length;\n        for (uint256 i; i < length; i++) {\n            processOutput(outputParams[i], returnData, account);\n        }\n    }\n\n    // Process a single output parameter and write to storage\n    function processOutput(OutputParam calldata param, bytes memory returnData, address account) internal {\n        // only static types are supported for now as return values\n        // can also process all the static return values which are before the first dynamic return value in the\n        // returnData\n        if (param.fetcherType == OutputParamFetcherType.EXEC_RESULT) {\n            uint256 returnValues;\n            address targetStorageContract;\n            bytes32 targetStorageSlot;\n            bytes calldata paramData = param.paramData;\n            assembly {\n                returnValues := calldataload(paramData.offset)\n                targetStorageContract := calldataload(add(paramData.offset, 0x20))\n                targetStorageSlot := calldataload(add(paramData.offset, 0x40))\n            }\n            _parseReturnDataAndWriteToStorage(\n                returnValues, returnData, targetStorageContract, targetStorageSlot, account\n            );\n            // same for static calls\n        } else if (param.fetcherType == OutputParamFetcherType.STATIC_CALL) {\n            uint256 returnValues;\n            address sourceContract;\n            bytes calldata sourceCallData;\n            address targetStorageContract;\n            bytes32 targetStorageSlot;\n            bytes calldata paramData = param.paramData;\n            assembly {\n                returnValues := calldataload(paramData.offset)\n                sourceContract := calldataload(add(paramData.offset, 0x20))\n                let s := calldataload(add(paramData.offset, 0x40))\n                let u := add(paramData.offset, s)\n                sourceCallData.offset := add(u, 0x20)\n                sourceCallData.length := calldataload(u)\n                targetStorageContract := calldataload(add(paramData.offset, 0x60))\n                targetStorageSlot := calldataload(add(paramData.offset, 0x80))\n            }\n            (bool outputSuccess, bytes memory outputReturnData) = sourceContract.staticcall(sourceCallData);\n            if (!outputSuccess) {\n                revert Output_StaticCallFailed();\n            }\n            _parseReturnDataAndWriteToStorage(\n                returnValues, outputReturnData, targetStorageContract, targetStorageSlot, account\n            );\n        } else {\n            revert InvalidOutputParamFetcherType();\n        }\n    }\n\n    /// @dev Validate the constraints => compare the value with the reference data\n    function _validateConstraints(bytes memory rawValue, Constraint[] calldata constraints) private pure {\n        if (constraints.length > 0) {\n            for (uint256 i; i < constraints.length; i++) {\n                Constraint memory constraint = constraints[i];\n                bytes32 returnValue;\n                assembly {\n                    returnValue := mload(add(rawValue, add(0x20, mul(i, 0x20))))\n                }\n                if (constraint.constraintType == ConstraintType.EQ) {\n                    require(returnValue == bytes32(constraint.referenceData), ConstraintNotMet(ConstraintType.EQ));\n                } else if (constraint.constraintType == ConstraintType.GTE) {\n                    require(returnValue >= bytes32(constraint.referenceData), ConstraintNotMet(ConstraintType.GTE));\n                } else if (constraint.constraintType == ConstraintType.LTE) {\n                    require(returnValue <= bytes32(constraint.referenceData), ConstraintNotMet(ConstraintType.LTE));\n                } else if (constraint.constraintType == ConstraintType.IN) {\n                    (bytes32 lowerBound, bytes32 upperBound) = abi.decode(constraint.referenceData, (bytes32, bytes32));\n                    require(returnValue >= lowerBound && returnValue <= upperBound, ConstraintNotMet(ConstraintType.IN));\n                } else {\n                    revert InvalidConstraintType();\n                }\n            }\n        }\n    }\n\n    /// @dev Parse the return data and write to the appropriate storage contract\n    function _parseReturnDataAndWriteToStorage(\n        uint256 returnValues,\n        bytes memory returnData,\n        address targetStorageContract,\n        bytes32 targetStorageSlot,\n        address account\n    )\n        internal\n    {\n        for (uint256 i; i < returnValues; i++) {\n            bytes32 value;\n            assembly {\n                value := mload(add(returnData, add(0x20, mul(i, 0x20))))\n            }\n            ComposableStorage(targetStorageContract)\n                .writeStorage({\n                    slot: keccak256(abi.encodePacked(targetStorageSlot, i)), value: value, account: account\n                });\n        }\n    }\n}\n"},"contracts/types/ComposabilityDataTypes.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\n// Type of the input parameter\nenum InputParamType {\n    TARGET, // The target address\n    VALUE, // The value\n    CALL_DATA // The call data\n}\n\n// Parameter type for composition\nenum InputParamFetcherType {\n    RAW_BYTES, // Already encoded bytes\n    STATIC_CALL, // Perform a static call\n    BALANCE // Get the balance of an address\n}\n\nenum OutputParamFetcherType {\n    EXEC_RESULT, // The return of the execution call\n    STATIC_CALL // Call to some other function\n}\n\n// Constraint type for parameter validation\nenum ConstraintType {\n    EQ, // Equal to\n    GTE, // Greater than or equal to\n    LTE, // Less than or equal to\n    IN // In range\n}\n\n// Constraint for parameter validation\nstruct Constraint {\n    ConstraintType constraintType;\n    bytes referenceData;\n}\n\n// Structure to define parameter composition\nstruct InputParam {\n    InputParamType paramType;\n    InputParamFetcherType fetcherType; // How to fetch the parameter\n    bytes paramData;\n    Constraint[] constraints;\n}\n\n// Structure to define return value handling\nstruct OutputParam {\n    OutputParamFetcherType fetcherType; // How to fetch the parameter\n    bytes paramData;\n}\n\n// Structure to define a composable execution\nstruct ComposableExecution {\n    bytes4 functionSig;\n    InputParam[] inputParams;\n    OutputParam[] outputParams;\n}\n"},"node_modules/account-abstraction/contracts/interfaces/PackedUserOperation.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.5;\n\n/**\n * User Operation struct\n * @param sender                - The sender account of this request.\n * @param nonce                 - Unique value the sender uses to verify it is not a replay.\n * @param initCode              - If set, the account contract will be created by this constructor/\n * @param callData              - The method call to execute on this account.\n * @param accountGasLimits      - Packed gas limits for validateUserOp and gas limit passed to the callData method call.\n * @param preVerificationGas    - Gas not calculated by the handleOps method, but added to the gas paid.\n *                                Covers batch overhead.\n * @param gasFees               - packed gas fields maxPriorityFeePerGas and maxFeePerGas - Same as EIP-1559 gas parameters.\n * @param paymasterAndData      - If set, this field holds the paymaster address, verification gas limit, postOp gas limit and paymaster-specific extra data\n *                                The paymaster will pay for the transaction instead of the sender.\n * @param signature             - Sender-verified signature over the entire request, the EntryPoint address and the chain ID.\n */\nstruct PackedUserOperation {\n    address sender;\n    uint256 nonce;\n    bytes initCode;\n    bytes callData;\n    bytes32 accountGasLimits;\n    uint256 preVerificationGas;\n    bytes32 gasFees;\n    bytes paymasterAndData;\n    bytes signature;\n}\n"},"node_modules/@rhinestone/module-bases/src/external/ERC7579.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\n/* solhint-disable no-unused-import */\nimport { MSAFactory as ERC7579AccountFactory } from \"erc7579/MSAFactory.sol\";\nimport { MSAAdvanced as ERC7579Account } from \"erc7579/MSAAdvanced.sol\";\nimport { Execution, IERC7579Account } from \"erc7579/interfaces/IERC7579Account.sol\";\nimport {\n    IModule as IERC7579Module,\n    IValidator as IERC7579Validator,\n    IExecutor as IERC7579Executor,\n    IHook as IERC7579Hook,\n    IFallback as IERC7579Fallback,\n    MODULE_TYPE_VALIDATOR,\n    MODULE_TYPE_EXECUTOR,\n    MODULE_TYPE_HOOK,\n    MODULE_TYPE_FALLBACK\n} from \"erc7579/interfaces/IERC7579Module.sol\";\n\nimport {\n    ModeLib as ERC7579ModeLib,\n    ModeCode,\n    CallType,\n    ExecType,\n    ModePayload,\n    CALLTYPE_SINGLE,\n    CALLTYPE_BATCH,\n    CALLTYPE_DELEGATECALL,\n    EXECTYPE_DEFAULT,\n    MODE_DEFAULT\n} from \"erc7579/lib/ModeLib.sol\";\nimport { Execution, ExecutionLib as ERC7579ExecutionLib } from \"erc7579/lib/ExecutionLib.sol\";\n\nimport {\n    Bootstrap as ERC7579Bootstrap,\n    BootstrapConfig as ERC7579BootstrapConfig\n} from \"erc7579/utils/Bootstrap.sol\";\n/* solhint-enable no-unused-import */\n"},"node_modules/@rhinestone/module-bases/src/ERC7579ModuleBase.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.25;\n\nimport { IERC7579Module } from \"./external/ERC7579.sol\";\n\nabstract contract ERC7579ModuleBase is IERC7579Module {\n    uint256 constant TYPE_VALIDATOR = 1;\n    uint256 constant TYPE_EXECUTOR = 2;\n    uint256 constant TYPE_FALLBACK = 3;\n    uint256 constant TYPE_HOOK = 4;\n    uint256 constant TYPE_POLICY = 7;\n}\n"},"contracts/composability/ComposableStorage.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport { EfficientHashLib } from \"solady/utils/EfficientHashLib.sol\";\n\n/**\n * @title ComposableStorage\n * @dev Contract to handle generic storage operations with cross-chain support\n */\ncontract ComposableStorage {\n    using EfficientHashLib for *;\n\n    error SlotNotInitialized();\n\n    // Mapping to track initialized slots\n    mapping(bytes32 => bool) private initializedSlots;\n\n    // Mapping to track length of dynamic data\n    mapping(bytes32 => uint256) private dynamicDataLength;\n\n    /**\n     * @dev Internal function to write a value to a specific storage slot\n     */\n    function _writeStorage(bytes32 slot, bytes32 value, bytes32 namespace) private {\n        bytes32 namespacedSlot = getNamespacedSlot(namespace, slot);\n        initializedSlots[namespacedSlot] = true;\n        assembly {\n            sstore(namespacedSlot, value)\n        }\n    }\n\n    /**\n     * @dev Write a value to a specific storage slot\n     * @param slot The storage slot to write to\n     * @param value The value to write\n     */\n    function writeStorage(bytes32 slot, bytes32 value, address account) external {\n        bytes32 namespace = getNamespace(account, msg.sender);\n        _writeStorage(slot, value, namespace);\n    }\n\n    /**\n     * @dev Read a value from a specific namespace and slot\n     * @param namespace The namespace (typically a contract address)\n     * @param slot The storage slot to read from\n     * @return The value stored at the specified namespaced slot\n     */\n    function readStorage(bytes32 namespace, bytes32 slot) external view returns (bytes32) {\n        bytes32 namespacedSlot = getNamespacedSlot(namespace, slot);\n        if (!initializedSlots[namespacedSlot]) {\n            revert SlotNotInitialized();\n        }\n        bytes32 value;\n        assembly {\n            value := sload(namespacedSlot)\n        }\n        return value;\n    }\n\n    /**\n     * @dev Generates a namespaced slot\n     * @param namespace The namespace (typically a contract address)\n     * @param slot The storage slot to read from\n     * return The namespaced slot\n     */\n    function getNamespacedSlot(bytes32 namespace, bytes32 slot) public pure returns (bytes32 result) {\n        assembly {\n            mstore(0x00, namespace)\n            mstore(0x20, slot)\n            result := keccak256(0x00, 0x40)\n        }\n    }\n\n    /**\n     * @dev Generates a namespace for a given account and caller\n     * @param account The account address\n     * @param _caller The caller address\n     * return The generated namespace\n     */\n    function getNamespace(address account, address _caller) public pure returns (bytes32 result) {\n        assembly {\n            mstore(0x00, account)\n            mstore(0x14, _caller)\n            result := keccak256(0x0c, 0x28)\n        }\n    }\n\n    /**\n     * @dev Check if a slot has been initialized\n     */\n    function isSlotInitialized(bytes32 namespace, bytes32 slot) external view returns (bool) {\n        bytes32 namespacedSlot = getNamespacedSlot(namespace, slot);\n        return initializedSlots[namespacedSlot];\n    }\n}\n"},"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"},"node_modules/@erc7579/implementation/src/MSAFactory.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.21;\n\nimport { IMSA } from \"./interfaces/IMSA.sol\";\nimport { MSAProxy } from \"./utils/MSAProxy.sol\";\n\ncontract MSAFactory {\n    address public immutable implementation;\n\n    constructor(address _msaImplementation) {\n        implementation = _msaImplementation;\n    }\n\n    function createAccount(\n        bytes32 salt,\n        bytes calldata initCode\n    )\n        public\n        payable\n        virtual\n        returns (address)\n    {\n        address account = address(\n            new MSAProxy{ salt: salt, value: msg.value }(\n                implementation, abi.encodeCall(IMSA.initializeAccount, initCode)\n            )\n        );\n\n        return account;\n    }\n\n    function getAddress(\n        bytes32 salt,\n        bytes calldata initcode\n    )\n        public\n        view\n        virtual\n        returns (address)\n    {\n        bytes32 hash = keccak256(\n            abi.encodePacked(\n                bytes1(0xff),\n                address(this),\n                salt,\n                keccak256(\n                    abi.encodePacked(\n                        type(MSAProxy).creationCode,\n                        abi.encode(implementation, abi.encodeCall(IMSA.initializeAccount, initcode))\n                    )\n                )\n            )\n        );\n\n        return address(uint160(uint256(hash)));\n    }\n}\n"},"node_modules/@erc7579/implementation/src/MSAAdvanced.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\nimport \"./lib/ModeLib.sol\";\nimport { ExecutionLib } from \"./lib/ExecutionLib.sol\";\nimport { ExecutionHelper } from \"./core/ExecutionHelper.sol\";\nimport { PackedUserOperation } from \"account-abstraction/interfaces/PackedUserOperation.sol\";\nimport \"./interfaces/IERC7579Module.sol\";\nimport { IERC7579Account } from \"./interfaces/IERC7579Account.sol\";\nimport { IMSA } from \"./interfaces/IMSA.sol\";\nimport { ModuleManager } from \"./core/ModuleManager.sol\";\nimport { HookManager } from \"./core/HookManager.sol\";\nimport { RegistryAdapter } from \"./core/RegistryAdapter.sol\";\nimport { HashLib } from \"./lib/HashLib.sol\";\nimport { ECDSA } from \"solady/utils/ECDSA.sol\";\nimport { Initializable } from \"./lib/Initializable.sol\";\nimport { ERC7779Adapter } from \"./core/ERC7779Adapter.sol\";\nimport { SentinelListLib } from \"sentinellist/SentinelList.sol\";\nimport { PreValidationHookManager } from \"./core/PreValidationHookManager.sol\";\n\n/**\n * @author zeroknots.eth | rhinestone.wtf\n * Reference implementation of a very simple ERC7579 Account.\n * This account implements CallType: SINGLE, BATCH and DELEGATECALL.\n * This account implements ExecType: DEFAULT and TRY.\n * Hook support is implemented\n */\ncontract MSAAdvanced is\n    IMSA,\n    ExecutionHelper,\n    ModuleManager,\n    HookManager,\n    PreValidationHookManager,\n    RegistryAdapter,\n    ERC7779Adapter\n{\n    using ExecutionLib for bytes;\n    using ModeLib for ModeCode;\n    using ECDSA for bytes32;\n    using SentinelListLib for SentinelListLib.SentinelList;\n\n    /**\n     * @inheritdoc IERC7579Account\n     * @dev this function is only callable by the entry point or the account itself\n     * @dev this function demonstrates how to implement\n     * CallType SINGLE and BATCH and ExecType DEFAULT and TRY\n     * @dev this function demonstrates how to implement hook support (modifier)\n     */\n    function execute(\n        ModeCode mode,\n        bytes calldata executionCalldata\n    )\n        external\n        payable\n        onlyEntryPointOrSelf\n        withHook\n    {\n        (CallType callType, ExecType execType,,) = mode.decode();\n\n        // check if calltype is batch or single\n        if (callType == CALLTYPE_BATCH) {\n            // destructure executionCallData according to batched exec\n            Execution[] calldata executions = executionCalldata.decodeBatch();\n            // check if execType is revert or try\n            if (execType == EXECTYPE_DEFAULT) _execute(executions);\n            else if (execType == EXECTYPE_TRY) _tryExecute(executions);\n            else revert UnsupportedExecType(execType);\n        } else if (callType == CALLTYPE_SINGLE) {\n            // destructure executionCallData according to single exec\n            (address target, uint256 value, bytes calldata callData) =\n                executionCalldata.decodeSingle();\n            // check if execType is revert or try\n            if (execType == EXECTYPE_DEFAULT) _execute(target, value, callData);\n            // TODO: implement event emission for tryExecute singleCall\n            else if (execType == EXECTYPE_TRY) _tryExecute(target, value, callData);\n            else revert UnsupportedExecType(execType);\n        } else if (callType == CALLTYPE_DELEGATECALL) {\n            // destructure executionCallData according to single exec\n            address delegate = address(uint160(bytes20(executionCalldata[0:20])));\n            bytes calldata callData = executionCalldata[20:];\n            // check if execType is revert or try\n            if (execType == EXECTYPE_DEFAULT) _executeDelegatecall(delegate, callData);\n            else if (execType == EXECTYPE_TRY) _tryExecuteDelegatecall(delegate, callData);\n            else revert UnsupportedExecType(execType);\n        } else {\n            revert UnsupportedCallType(callType);\n        }\n    }\n\n    /**\n     * @inheritdoc IERC7579Account\n     * @dev this function is only callable by an installed executor module\n     * @dev this function demonstrates how to implement\n     * CallType SINGLE and BATCH and ExecType DEFAULT and TRY\n     * @dev this function demonstrates how to implement hook support (modifier)\n     */\n    function executeFromExecutor(\n        ModeCode mode,\n        bytes calldata executionCalldata\n    )\n        external\n        payable\n        onlyExecutorModule\n        withHook\n        withRegistry(msg.sender, MODULE_TYPE_EXECUTOR)\n        returns (\n            bytes[] memory returnData // TODO returnData is not used\n        )\n    {\n        (CallType callType, ExecType execType,,) = mode.decode();\n\n        // check if calltype is batch or single\n        if (callType == CALLTYPE_BATCH) {\n            // destructure executionCallData according to batched exec\n            Execution[] calldata executions = executionCalldata.decodeBatch();\n            // check if execType is revert or try\n            if (execType == EXECTYPE_DEFAULT) returnData = _execute(executions);\n            else if (execType == EXECTYPE_TRY) returnData = _tryExecute(executions);\n            else revert UnsupportedExecType(execType);\n        } else if (callType == CALLTYPE_SINGLE) {\n            // destructure executionCallData according to single exec\n            (address target, uint256 value, bytes calldata callData) =\n                executionCalldata.decodeSingle();\n            returnData = new bytes[](1);\n            bool success;\n            // check if execType is revert or try\n            if (execType == EXECTYPE_DEFAULT) {\n                returnData[0] = _execute(target, value, callData);\n            }\n            // TODO: implement event emission for tryExecute singleCall\n            else if (execType == EXECTYPE_TRY) {\n                (success, returnData[0]) = _tryExecute(target, value, callData);\n                if (!success) emit TryExecuteUnsuccessful(0, returnData[0]);\n            } else {\n                revert UnsupportedExecType(execType);\n            }\n        } else if (callType == CALLTYPE_DELEGATECALL) {\n            // destructure executionCallData according to single exec\n            address delegate = address(uint160(bytes20(executionCalldata[0:20])));\n            bytes calldata callData = executionCalldata[20:];\n            // check if execType is revert or try\n            if (execType == EXECTYPE_DEFAULT) _executeDelegatecall(delegate, callData);\n            else if (execType == EXECTYPE_TRY) _tryExecuteDelegatecall(delegate, callData);\n            else revert UnsupportedExecType(execType);\n        } else {\n            revert UnsupportedCallType(callType);\n        }\n    }\n\n    /**\n     * @dev ERC-4337 executeUserOp according to ERC-4337 v0.7\n     *         This function is intended to be called by ERC-4337 EntryPoint.sol\n     * @dev Ensure adequate authorization control: i.e. onlyEntryPointOrSelf\n     *      The implementation of the function is OPTIONAL\n     *\n     * @param userOp PackedUserOperation struct (see ERC-4337 v0.7+)\n     */\n    function executeUserOp(\n        PackedUserOperation calldata userOp,\n        bytes32 // userOpHash\n    )\n        external\n        payable\n        onlyEntryPoint\n    {\n        bytes calldata callData = userOp.callData[4:];\n        (bool success,) = address(this).delegatecall(callData);\n        if (!success) revert ExecutionFailed();\n    }\n\n    /**\n     * @inheritdoc IERC7579Account\n     */\n    function installModule(\n        uint256 moduleTypeId,\n        address module,\n        bytes calldata initData\n    )\n        external\n        payable\n        onlyEntryPointOrSelf\n        withHook\n        withRegistry(module, moduleTypeId)\n    {\n        if (!IModule(module).isModuleType(moduleTypeId)) revert MismatchModuleTypeId(moduleTypeId);\n\n        if (moduleTypeId == MODULE_TYPE_VALIDATOR) {\n            _installValidator(module, initData);\n        } else if (moduleTypeId == MODULE_TYPE_EXECUTOR) {\n            _installExecutor(module, initData);\n        } else if (moduleTypeId == MODULE_TYPE_FALLBACK) {\n            _installFallbackHandler(module, initData);\n        } else if (moduleTypeId == MODULE_TYPE_HOOK) {\n            _installHook(module, initData);\n        } else if (\n            moduleTypeId == MODULE_TYPE_PREVALIDATION_HOOK_ERC1271\n                || moduleTypeId == MODULE_TYPE_PREVALIDATION_HOOK_ERC4337\n        ) {\n            _installPreValidationHook(module, moduleTypeId, initData);\n        } else {\n            revert UnsupportedModuleType(moduleTypeId);\n        }\n        emit ModuleInstalled(moduleTypeId, module);\n    }\n\n    /**\n     * @inheritdoc IERC7579Account\n     */\n    function uninstallModule(\n        uint256 moduleTypeId,\n        address module,\n        bytes calldata deInitData\n    )\n        external\n        payable\n        onlyEntryPointOrSelf\n        withHook\n    {\n        if (moduleTypeId == MODULE_TYPE_VALIDATOR) {\n            _uninstallValidator(module, deInitData);\n        } else if (moduleTypeId == MODULE_TYPE_EXECUTOR) {\n            _uninstallExecutor(module, deInitData);\n        } else if (moduleTypeId == MODULE_TYPE_FALLBACK) {\n            _uninstallFallbackHandler(module, deInitData);\n        } else if (moduleTypeId == MODULE_TYPE_HOOK) {\n            _uninstallHook(module, deInitData);\n        } else if (\n            moduleTypeId == MODULE_TYPE_PREVALIDATION_HOOK_ERC1271\n                || moduleTypeId == MODULE_TYPE_PREVALIDATION_HOOK_ERC4337\n        ) {\n            _uninstallPreValidationHook(module, moduleTypeId, deInitData);\n        } else {\n            revert UnsupportedModuleType(moduleTypeId);\n        }\n        emit ModuleUninstalled(moduleTypeId, module);\n    }\n\n    /**\n     * @dev ERC-4337 validateUserOp according to ERC-4337 v0.7\n     *         This function is intended to be called by ERC-4337 EntryPoint.sol\n     * this validation function should decode / sload the validator module to validate the userOp\n     * and call it.\n     *\n     * @dev MSA MUST implement this function signature.\n     * @param userOp PackedUserOperation struct (see ERC-4337 v0.7+)\n     */\n    function validateUserOp(\n        PackedUserOperation memory userOp,\n        bytes32 userOpHash,\n        uint256 missingAccountFunds\n    )\n        external\n        payable\n        virtual\n        onlyEntryPoint\n        payPrefund(missingAccountFunds)\n        returns (uint256 validSignature)\n    {\n        address validator;\n        // @notice validator encoding in nonce is just an example!\n        // @notice this is not part of the standard!\n        // Account Vendors may choose any other way to implement validator selection\n        uint256 nonce = userOp.nonce;\n        assembly {\n            validator := shr(96, nonce)\n        }\n\n        // check if validator is enabled. If not terminate the validation phase.\n        if (!_isValidatorInstalled(validator)) {\n            if (!isAlreadyInitialized()) {\n                address signer =\n                    ECDSA.recover(userOpHash.toEthSignedMessageHash(), userOp.signature);\n                if (signer != address(this)) {\n                    return VALIDATION_FAILED;\n                }\n                return VALIDATION_SUCCESS;\n            } else {\n                return VALIDATION_FAILED;\n            }\n        } else {\n            (userOpHash, userOp.signature) =\n                _withPreValidationHook(userOpHash, userOp, missingAccountFunds);\n            // bubble up the return value of the validator module\n            validSignature = IValidator(validator).validateUserOp(userOp, userOpHash);\n        }\n    }\n\n    /**\n     * @dev ERC-1271 isValidSignature\n     *         This function is intended to be used to validate a smart account signature\n     * and may forward the call to a validator module\n     *\n     * @param hash The hash of the data that is signed\n     * @param data The data that is signed\n     */\n    function isValidSignature(\n        bytes32 hash,\n        bytes calldata data\n    )\n        external\n        view\n        virtual\n        override\n        returns (bytes4)\n    {\n        address validator = address(bytes20(data[0:20]));\n        if (!_isValidatorInstalled(validator)) {\n            if (!isAlreadyInitialized()) {\n                address signer = ECDSA.recover(hash.toEthSignedMessageHash(), data);\n                if (signer == address(this)) {\n                    return 0x1626ba7e; // EIP1271MagicValue\n                }\n            }\n            revert InvalidModule(validator);\n        }\n        bytes memory signature_;\n        (hash, signature_) = _withPreValidationHook(hash, data[20:]);\n        return IValidator(validator).isValidSignatureWithSender(msg.sender, hash, signature_);\n    }\n\n    /**\n     * @inheritdoc IERC7579Account\n     */\n    function isModuleInstalled(\n        uint256 moduleTypeId,\n        address module,\n        bytes calldata additionalContext\n    )\n        external\n        view\n        override\n        returns (bool)\n    {\n        if (moduleTypeId == MODULE_TYPE_VALIDATOR) {\n            return _isValidatorInstalled(module);\n        } else if (moduleTypeId == MODULE_TYPE_EXECUTOR) {\n            return _isExecutorInstalled(module);\n        } else if (moduleTypeId == MODULE_TYPE_FALLBACK) {\n            return _isFallbackHandlerInstalled(abi.decode(additionalContext, (bytes4)), module);\n        } else if (moduleTypeId == MODULE_TYPE_HOOK) {\n            return _isHookInstalled(module);\n        } else if (\n            moduleTypeId == MODULE_TYPE_PREVALIDATION_HOOK_ERC1271\n                || moduleTypeId == MODULE_TYPE_PREVALIDATION_HOOK_ERC4337\n        ) {\n            return _isPreValidationHookInstalled(module, moduleTypeId);\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @inheritdoc IERC7579Account\n     */\n    function accountId() external view virtual override returns (string memory) {\n        // vendor.flavour.SemVer\n        return \"uMSA.advanced/withHook.v0.1\";\n    }\n\n    /**\n     * @inheritdoc IERC7579Account\n     */\n    function supportsExecutionMode(ModeCode mode)\n        external\n        view\n        virtual\n        override\n        returns (bool isSupported)\n    {\n        (CallType callType, ExecType execType,,) = mode.decode();\n        if (callType == CALLTYPE_BATCH) isSupported = true;\n        else if (callType == CALLTYPE_SINGLE) isSupported = true;\n        else if (callType == CALLTYPE_DELEGATECALL) isSupported = true;\n        // if callType is not single, batch or delegatecall return false\n        else return false;\n\n        if (execType == EXECTYPE_DEFAULT) isSupported = true;\n        else if (execType == EXECTYPE_TRY) isSupported = true;\n        // if execType is not default or try, return false\n        else return false;\n    }\n\n    /**\n     * @inheritdoc IERC7579Account\n     */\n    function supportsModule(uint256 modulTypeId) external view virtual override returns (bool) {\n        if (modulTypeId == MODULE_TYPE_VALIDATOR) return true;\n        else if (modulTypeId == MODULE_TYPE_EXECUTOR) return true;\n        else if (modulTypeId == MODULE_TYPE_FALLBACK) return true;\n        else if (modulTypeId == MODULE_TYPE_HOOK) return true;\n        else if (\n            modulTypeId == MODULE_TYPE_PREVALIDATION_HOOK_ERC1271\n                || modulTypeId == MODULE_TYPE_PREVALIDATION_HOOK_ERC4337\n        ) return true;\n        else return false;\n    }\n\n    /**\n     * @dev Initializes the account. Function might be called directly, or by a Factory\n     * @param data. encoded data that can be used during the initialization phase\n     */\n    function initializeAccount(bytes calldata data) public payable virtual {\n        // protect this function to only be callable when used with the proxy factory or when\n        // account calls itself\n        if (msg.sender != address(this)) {\n            Initializable.checkInitializable();\n        }\n\n        // checks if already initialized and reverts before setting the state to initialized\n        _initModuleManager();\n        bool isERC7702;\n        assembly {\n            isERC7702 :=\n                eq(\n                    extcodehash(address()),\n                    0xeadcdba66a79ab5dce91622d1d75c8cff5cff0b96944c3bf1072cd08ce018329 // (keccak256(0xef01))\n                )\n        }\n        if (isERC7702) {\n            _addStorageBase(MODULEMANAGER_STORAGE_LOCATION);\n            _addStorageBase(HOOKMANAGER_STORAGE_LOCATION);\n        }\n\n        // bootstrap the account\n        (address bootstrap, bytes memory bootstrapCall) = abi.decode(data, (address, bytes));\n        _initAccount(bootstrap, bootstrapCall);\n    }\n\n    /**\n     * @dev Bootstrap function to initialize the account\n     * @param bootstrap. address of the bootstrap contract,\n     * @param bootstrapCall. encoded data that can be used during the initialization phase\n     */\n    function _initAccount(address bootstrap, bytes memory bootstrapCall) private {\n        // this is just implemented for demonstration purposes. You can use any other initialization\n        // logic here.\n        (bool success,) = bootstrap.delegatecall(bootstrapCall);\n        if (!success) revert();\n    }\n\n    function _onRedelegation() internal override {\n        _tryUninstallValidators();\n        _tryUninstallExecutors();\n        _tryUninstallHook(_getHook());\n        _initModuleManager();\n    }\n}\n"},"node_modules/@erc7579/implementation/src/utils/Bootstrap.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.21;\n\nimport \"../core/ModuleManager.sol\";\nimport \"../core/HookManager.sol\";\n\nimport \"../interfaces/IERC7579Module.sol\";\n\nstruct BootstrapConfig {\n    address module;\n    bytes data;\n}\n\ncontract Bootstrap is ModuleManager, HookManager {\n    function singleInitMSA(IModule validator, bytes calldata data) external {\n        // init validator\n        _installValidator(address(validator), data);\n    }\n\n    /**\n     * This function is intended to be called by the MSA with a delegatecall.\n     * Make sure that the MSA already initilazed the linked lists in the ModuleManager prior to\n     * calling this function\n     */\n    function initMSA(\n        BootstrapConfig[] calldata $valdiators,\n        BootstrapConfig[] calldata $executors,\n        BootstrapConfig calldata _hook,\n        BootstrapConfig[] calldata _fallbacks\n    )\n        external\n    {\n        // init validators\n        for (uint256 i; i < $valdiators.length; i++) {\n            _installValidator($valdiators[i].module, $valdiators[i].data);\n        }\n\n        // init executors\n        for (uint256 i; i < $executors.length; i++) {\n            if ($executors[i].module == address(0)) continue;\n            _installExecutor($executors[i].module, $executors[i].data);\n        }\n\n        // init hook\n        if (_hook.module != address(0)) {\n            _installHook(_hook.module, _hook.data);\n        }\n\n        // init fallback\n        for (uint256 i; i < _fallbacks.length; i++) {\n            if (_fallbacks[i].module == address(0)) continue;\n            _installFallbackHandler(_fallbacks[i].module, _fallbacks[i].data);\n        }\n    }\n\n    function _getInitMSACalldata(\n        BootstrapConfig[] calldata $valdiators,\n        BootstrapConfig[] calldata $executors,\n        BootstrapConfig calldata _hook,\n        BootstrapConfig[] calldata _fallbacks\n    )\n        external\n        view\n        returns (bytes memory init)\n    {\n        init = abi.encode(\n            address(this),\n            abi.encodeCall(this.initMSA, ($valdiators, $executors, _hook, _fallbacks))\n        );\n    }\n}\n"},"node_modules/solady/src/utils/EfficientHashLib.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Library for efficiently performing keccak256 hashes.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/EfficientHashLib.sol)\n/// @dev To avoid stack-too-deep, you can use:\n/// ```\n/// bytes32[] memory buffer = EfficientHashLib.malloc(10);\n/// EfficientHashLib.set(buffer, 0, value0);\n/// ..\n/// EfficientHashLib.set(buffer, 9, value9);\n/// bytes32 finalHash = EfficientHashLib.hash(buffer);\n/// ```\nlibrary EfficientHashLib {\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*               MALLOC-LESS HASHING OPERATIONS               */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev Returns `keccak256(abi.encode(v0))`.\n    function hash(bytes32 v0) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, v0)\n            result := keccak256(0x00, 0x20)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0))`.\n    function hash(uint256 v0) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, v0)\n            result := keccak256(0x00, 0x20)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, v1))`.\n    function hash(bytes32 v0, bytes32 v1) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, v0)\n            mstore(0x20, v1)\n            result := keccak256(0x00, 0x40)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, v1))`.\n    function hash(uint256 v0, uint256 v1) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, v0)\n            mstore(0x20, v1)\n            result := keccak256(0x00, 0x40)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, v1, v2))`.\n    function hash(bytes32 v0, bytes32 v1, bytes32 v2) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            result := keccak256(m, 0x60)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, v1, v2))`.\n    function hash(uint256 v0, uint256 v1, uint256 v2) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            result := keccak256(m, 0x60)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, v1, v2, v3))`.\n    function hash(bytes32 v0, bytes32 v1, bytes32 v2, bytes32 v3)\n        internal\n        pure\n        returns (bytes32 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            result := keccak256(m, 0x80)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, v1, v2, v3))`.\n    function hash(uint256 v0, uint256 v1, uint256 v2, uint256 v3)\n        internal\n        pure\n        returns (bytes32 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            result := keccak256(m, 0x80)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, .., v4))`.\n    function hash(bytes32 v0, bytes32 v1, bytes32 v2, bytes32 v3, bytes32 v4)\n        internal\n        pure\n        returns (bytes32 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            result := keccak256(m, 0xa0)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, .., v4))`.\n    function hash(uint256 v0, uint256 v1, uint256 v2, uint256 v3, uint256 v4)\n        internal\n        pure\n        returns (bytes32 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            result := keccak256(m, 0xa0)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, .., v5))`.\n    function hash(bytes32 v0, bytes32 v1, bytes32 v2, bytes32 v3, bytes32 v4, bytes32 v5)\n        internal\n        pure\n        returns (bytes32 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            result := keccak256(m, 0xc0)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, .., v5))`.\n    function hash(uint256 v0, uint256 v1, uint256 v2, uint256 v3, uint256 v4, uint256 v5)\n        internal\n        pure\n        returns (bytes32 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            result := keccak256(m, 0xc0)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, .., v6))`.\n    function hash(\n        bytes32 v0,\n        bytes32 v1,\n        bytes32 v2,\n        bytes32 v3,\n        bytes32 v4,\n        bytes32 v5,\n        bytes32 v6\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            result := keccak256(m, 0xe0)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, .., v6))`.\n    function hash(\n        uint256 v0,\n        uint256 v1,\n        uint256 v2,\n        uint256 v3,\n        uint256 v4,\n        uint256 v5,\n        uint256 v6\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            result := keccak256(m, 0xe0)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, .., v7))`.\n    function hash(\n        bytes32 v0,\n        bytes32 v1,\n        bytes32 v2,\n        bytes32 v3,\n        bytes32 v4,\n        bytes32 v5,\n        bytes32 v6,\n        bytes32 v7\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            mstore(add(m, 0xe0), v7)\n            result := keccak256(m, 0x100)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, .., v7))`.\n    function hash(\n        uint256 v0,\n        uint256 v1,\n        uint256 v2,\n        uint256 v3,\n        uint256 v4,\n        uint256 v5,\n        uint256 v6,\n        uint256 v7\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            mstore(add(m, 0xe0), v7)\n            result := keccak256(m, 0x100)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, .., v8))`.\n    function hash(\n        bytes32 v0,\n        bytes32 v1,\n        bytes32 v2,\n        bytes32 v3,\n        bytes32 v4,\n        bytes32 v5,\n        bytes32 v6,\n        bytes32 v7,\n        bytes32 v8\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            mstore(add(m, 0xe0), v7)\n            mstore(add(m, 0x100), v8)\n            result := keccak256(m, 0x120)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, .., v8))`.\n    function hash(\n        uint256 v0,\n        uint256 v1,\n        uint256 v2,\n        uint256 v3,\n        uint256 v4,\n        uint256 v5,\n        uint256 v6,\n        uint256 v7,\n        uint256 v8\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            mstore(add(m, 0xe0), v7)\n            mstore(add(m, 0x100), v8)\n            result := keccak256(m, 0x120)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, .., v9))`.\n    function hash(\n        bytes32 v0,\n        bytes32 v1,\n        bytes32 v2,\n        bytes32 v3,\n        bytes32 v4,\n        bytes32 v5,\n        bytes32 v6,\n        bytes32 v7,\n        bytes32 v8,\n        bytes32 v9\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            mstore(add(m, 0xe0), v7)\n            mstore(add(m, 0x100), v8)\n            mstore(add(m, 0x120), v9)\n            result := keccak256(m, 0x140)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, .., v9))`.\n    function hash(\n        uint256 v0,\n        uint256 v1,\n        uint256 v2,\n        uint256 v3,\n        uint256 v4,\n        uint256 v5,\n        uint256 v6,\n        uint256 v7,\n        uint256 v8,\n        uint256 v9\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            mstore(add(m, 0xe0), v7)\n            mstore(add(m, 0x100), v8)\n            mstore(add(m, 0x120), v9)\n            result := keccak256(m, 0x140)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, .., v10))`.\n    function hash(\n        bytes32 v0,\n        bytes32 v1,\n        bytes32 v2,\n        bytes32 v3,\n        bytes32 v4,\n        bytes32 v5,\n        bytes32 v6,\n        bytes32 v7,\n        bytes32 v8,\n        bytes32 v9,\n        bytes32 v10\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            mstore(add(m, 0xe0), v7)\n            mstore(add(m, 0x100), v8)\n            mstore(add(m, 0x120), v9)\n            mstore(add(m, 0x140), v10)\n            result := keccak256(m, 0x160)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, .., v10))`.\n    function hash(\n        uint256 v0,\n        uint256 v1,\n        uint256 v2,\n        uint256 v3,\n        uint256 v4,\n        uint256 v5,\n        uint256 v6,\n        uint256 v7,\n        uint256 v8,\n        uint256 v9,\n        uint256 v10\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            mstore(add(m, 0xe0), v7)\n            mstore(add(m, 0x100), v8)\n            mstore(add(m, 0x120), v9)\n            mstore(add(m, 0x140), v10)\n            result := keccak256(m, 0x160)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, .., v11))`.\n    function hash(\n        bytes32 v0,\n        bytes32 v1,\n        bytes32 v2,\n        bytes32 v3,\n        bytes32 v4,\n        bytes32 v5,\n        bytes32 v6,\n        bytes32 v7,\n        bytes32 v8,\n        bytes32 v9,\n        bytes32 v10,\n        bytes32 v11\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            mstore(add(m, 0xe0), v7)\n            mstore(add(m, 0x100), v8)\n            mstore(add(m, 0x120), v9)\n            mstore(add(m, 0x140), v10)\n            mstore(add(m, 0x160), v11)\n            result := keccak256(m, 0x180)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, .., v11))`.\n    function hash(\n        uint256 v0,\n        uint256 v1,\n        uint256 v2,\n        uint256 v3,\n        uint256 v4,\n        uint256 v5,\n        uint256 v6,\n        uint256 v7,\n        uint256 v8,\n        uint256 v9,\n        uint256 v10,\n        uint256 v11\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            mstore(add(m, 0xe0), v7)\n            mstore(add(m, 0x100), v8)\n            mstore(add(m, 0x120), v9)\n            mstore(add(m, 0x140), v10)\n            mstore(add(m, 0x160), v11)\n            result := keccak256(m, 0x180)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, .., v12))`.\n    function hash(\n        bytes32 v0,\n        bytes32 v1,\n        bytes32 v2,\n        bytes32 v3,\n        bytes32 v4,\n        bytes32 v5,\n        bytes32 v6,\n        bytes32 v7,\n        bytes32 v8,\n        bytes32 v9,\n        bytes32 v10,\n        bytes32 v11,\n        bytes32 v12\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            mstore(add(m, 0xe0), v7)\n            mstore(add(m, 0x100), v8)\n            mstore(add(m, 0x120), v9)\n            mstore(add(m, 0x140), v10)\n            mstore(add(m, 0x160), v11)\n            mstore(add(m, 0x180), v12)\n            result := keccak256(m, 0x1a0)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, .., v12))`.\n    function hash(\n        uint256 v0,\n        uint256 v1,\n        uint256 v2,\n        uint256 v3,\n        uint256 v4,\n        uint256 v5,\n        uint256 v6,\n        uint256 v7,\n        uint256 v8,\n        uint256 v9,\n        uint256 v10,\n        uint256 v11,\n        uint256 v12\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            mstore(add(m, 0xe0), v7)\n            mstore(add(m, 0x100), v8)\n            mstore(add(m, 0x120), v9)\n            mstore(add(m, 0x140), v10)\n            mstore(add(m, 0x160), v11)\n            mstore(add(m, 0x180), v12)\n            result := keccak256(m, 0x1a0)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, .., v13))`.\n    function hash(\n        bytes32 v0,\n        bytes32 v1,\n        bytes32 v2,\n        bytes32 v3,\n        bytes32 v4,\n        bytes32 v5,\n        bytes32 v6,\n        bytes32 v7,\n        bytes32 v8,\n        bytes32 v9,\n        bytes32 v10,\n        bytes32 v11,\n        bytes32 v12,\n        bytes32 v13\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            mstore(add(m, 0xe0), v7)\n            mstore(add(m, 0x100), v8)\n            mstore(add(m, 0x120), v9)\n            mstore(add(m, 0x140), v10)\n            mstore(add(m, 0x160), v11)\n            mstore(add(m, 0x180), v12)\n            mstore(add(m, 0x1a0), v13)\n            result := keccak256(m, 0x1c0)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, .., v13))`.\n    function hash(\n        uint256 v0,\n        uint256 v1,\n        uint256 v2,\n        uint256 v3,\n        uint256 v4,\n        uint256 v5,\n        uint256 v6,\n        uint256 v7,\n        uint256 v8,\n        uint256 v9,\n        uint256 v10,\n        uint256 v11,\n        uint256 v12,\n        uint256 v13\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            mstore(add(m, 0xe0), v7)\n            mstore(add(m, 0x100), v8)\n            mstore(add(m, 0x120), v9)\n            mstore(add(m, 0x140), v10)\n            mstore(add(m, 0x160), v11)\n            mstore(add(m, 0x180), v12)\n            mstore(add(m, 0x1a0), v13)\n            result := keccak256(m, 0x1c0)\n        }\n    }\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*             BYTES32 BUFFER HASHING OPERATIONS              */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev Returns `keccak256(abi.encode(buffer[0], .., buffer[buffer.length - 1]))`.\n    function hash(bytes32[] memory buffer) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := keccak256(add(buffer, 0x20), shl(5, mload(buffer)))\n        }\n    }\n\n    /// @dev Sets `buffer[i]` to `value`, without a bounds check.\n    /// Returns the `buffer` for function chaining.\n    function set(bytes32[] memory buffer, uint256 i, bytes32 value)\n        internal\n        pure\n        returns (bytes32[] memory)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(add(buffer, shl(5, add(1, i))), value)\n        }\n        return buffer;\n    }\n\n    /// @dev Sets `buffer[i]` to `value`, without a bounds check.\n    /// Returns the `buffer` for function chaining.\n    function set(bytes32[] memory buffer, uint256 i, uint256 value)\n        internal\n        pure\n        returns (bytes32[] memory)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(add(buffer, shl(5, add(1, i))), value)\n        }\n        return buffer;\n    }\n\n    /// @dev Returns `new bytes32[](n)`, without zeroing out the memory.\n    function malloc(uint256 n) internal pure returns (bytes32[] memory buffer) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            buffer := mload(0x40)\n            mstore(buffer, n)\n            mstore(0x40, add(shl(5, add(1, n)), buffer))\n        }\n    }\n\n    /// @dev Frees memory that has been allocated for `buffer`.\n    /// No-op if `buffer.length` is zero, or if new memory has been allocated after `buffer`.\n    function free(bytes32[] memory buffer) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(buffer)\n            mstore(shl(6, lt(iszero(n), eq(add(shl(5, add(1, n)), buffer), mload(0x40)))), buffer)\n        }\n    }\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                      EQUALITY CHECKS                       */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev Returns `a == abi.decode(b, (bytes32))`.\n    function eq(bytes32 a, bytes memory b) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := and(eq(0x20, mload(b)), eq(a, mload(add(b, 0x20))))\n        }\n    }\n\n    /// @dev Returns `abi.decode(a, (bytes32)) == b`.\n    function eq(bytes memory a, bytes32 b) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := and(eq(0x20, mload(a)), eq(b, mload(add(a, 0x20))))\n        }\n    }\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*               BYTE SLICE HASHING OPERATIONS                */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev Returns the keccak256 of the slice from `start` to `end` (exclusive).\n    /// `start` and `end` are byte offsets.\n    function hash(bytes memory b, uint256 start, uint256 end)\n        internal\n        pure\n        returns (bytes32 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(b)\n            end := xor(end, mul(xor(end, n), lt(n, end)))\n            start := xor(start, mul(xor(start, n), lt(n, start)))\n            result := keccak256(add(add(b, 0x20), start), mul(gt(end, start), sub(end, start)))\n        }\n    }\n\n    /// @dev Returns the keccak256 of the slice from `start` to the end of the bytes.\n    function hash(bytes memory b, uint256 start) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(b)\n            start := xor(start, mul(xor(start, n), lt(n, start)))\n            result := keccak256(add(add(b, 0x20), start), mul(gt(n, start), sub(n, start)))\n        }\n    }\n\n    /// @dev Returns the keccak256 of the bytes.\n    function hash(bytes memory b) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := keccak256(add(b, 0x20), mload(b))\n        }\n    }\n\n    /// @dev Returns the keccak256 of the slice from `start` to `end` (exclusive).\n    /// `start` and `end` are byte offsets.\n    function hashCalldata(bytes calldata b, uint256 start, uint256 end)\n        internal\n        pure\n        returns (bytes32 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            end := xor(end, mul(xor(end, b.length), lt(b.length, end)))\n            start := xor(start, mul(xor(start, b.length), lt(b.length, start)))\n            let n := mul(gt(end, start), sub(end, start))\n            calldatacopy(mload(0x40), add(b.offset, start), n)\n            result := keccak256(mload(0x40), n)\n        }\n    }\n\n    /// @dev Returns the keccak256 of the slice from `start` to the end of the bytes.\n    function hashCalldata(bytes calldata b, uint256 start) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            start := xor(start, mul(xor(start, b.length), lt(b.length, start)))\n            let n := mul(gt(b.length, start), sub(b.length, start))\n            calldatacopy(mload(0x40), add(b.offset, start), n)\n            result := keccak256(mload(0x40), n)\n        }\n    }\n\n    /// @dev Returns the keccak256 of the bytes.\n    function hashCalldata(bytes calldata b) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            calldatacopy(mload(0x40), b.offset, b.length)\n            result := keccak256(mload(0x40), b.length)\n        }\n    }\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                      SHA2-256 HELPERS                      */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev Returns `sha256(abi.encode(b))`. Yes, it's more efficient.\n    function sha2(bytes32 b) internal view returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, b)\n            result := mload(staticcall(gas(), 2, 0x00, 0x20, 0x01, 0x20))\n            if iszero(returndatasize()) { invalid() }\n        }\n    }\n\n    /// @dev Returns the sha256 of the slice from `start` to `end` (exclusive).\n    /// `start` and `end` are byte offsets.\n    function sha2(bytes memory b, uint256 start, uint256 end)\n        internal\n        view\n        returns (bytes32 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(b)\n            end := xor(end, mul(xor(end, n), lt(n, end)))\n            start := xor(start, mul(xor(start, n), lt(n, start)))\n            // forgefmt: disable-next-item\n            result := mload(staticcall(gas(), 2, add(add(b, 0x20), start),\n                mul(gt(end, start), sub(end, start)), 0x01, 0x20))\n            if iszero(returndatasize()) { invalid() }\n        }\n    }\n\n    /// @dev Returns the sha256 of the slice from `start` to the end of the bytes.\n    function sha2(bytes memory b, uint256 start) internal view returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(b)\n            start := xor(start, mul(xor(start, n), lt(n, start)))\n            // forgefmt: disable-next-item\n            result := mload(staticcall(gas(), 2, add(add(b, 0x20), start),\n                mul(gt(n, start), sub(n, start)), 0x01, 0x20))\n            if iszero(returndatasize()) { invalid() }\n        }\n    }\n\n    /// @dev Returns the sha256 of the bytes.\n    function sha2(bytes memory b) internal view returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(staticcall(gas(), 2, add(b, 0x20), mload(b), 0x01, 0x20))\n            if iszero(returndatasize()) { invalid() }\n        }\n    }\n\n    /// @dev Returns the sha256 of the slice from `start` to `end` (exclusive).\n    /// `start` and `end` are byte offsets.\n    function sha2Calldata(bytes calldata b, uint256 start, uint256 end)\n        internal\n        view\n        returns (bytes32 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            end := xor(end, mul(xor(end, b.length), lt(b.length, end)))\n            start := xor(start, mul(xor(start, b.length), lt(b.length, start)))\n            let n := mul(gt(end, start), sub(end, start))\n            calldatacopy(mload(0x40), add(b.offset, start), n)\n            result := mload(staticcall(gas(), 2, mload(0x40), n, 0x01, 0x20))\n            if iszero(returndatasize()) { invalid() }\n        }\n    }\n\n    /// @dev Returns the sha256 of the slice from `start` to the end of the bytes.\n    function sha2Calldata(bytes calldata b, uint256 start) internal view returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            start := xor(start, mul(xor(start, b.length), lt(b.length, start)))\n            let n := mul(gt(b.length, start), sub(b.length, start))\n            calldatacopy(mload(0x40), add(b.offset, start), n)\n            result := mload(staticcall(gas(), 2, mload(0x40), n, 0x01, 0x20))\n            if iszero(returndatasize()) { invalid() }\n        }\n    }\n\n    /// @dev Returns the sha256 of the bytes.\n    function sha2Calldata(bytes calldata b) internal view returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            calldatacopy(mload(0x40), b.offset, b.length)\n            result := mload(staticcall(gas(), 2, mload(0x40), b.length, 0x01, 0x20))\n            if iszero(returndatasize()) { invalid() }\n        }\n    }\n}\n"},"node_modules/@erc7579/implementation/src/interfaces/IMSA.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.21;\n\nimport { IERC7579Account } from \"./IERC7579Account.sol\";\nimport { IERC4337Account } from \"./IERC4337Account.sol\";\nimport { IERC7779 } from \"./IERC7779.sol\";\n\nimport { CallType, ExecType, ModeCode } from \"../lib/ModeLib.sol\";\n\ninterface IMSA is IERC7579Account, IERC4337Account, IERC7779 {\n    // Error thrown when an unsupported ModuleType is requested\n    error UnsupportedModuleType(uint256 moduleTypeId);\n    // Error thrown when an execution with an unsupported CallType was made\n    error UnsupportedCallType(CallType callType);\n    // Error thrown when an execution with an unsupported ExecType was made\n    error UnsupportedExecType(ExecType execType);\n    // Error thrown when account initialization fails\n    error AccountInitializationFailed();\n    // Error thrown when account installs/unistalls module with mismatched input `moduleTypeId`\n    error MismatchModuleTypeId(uint256 moduleTypeId);\n\n    /**\n     * @dev Initializes the account. Function might be called directly, or by a Factory\n     * @param data. encoded data that can be used during the initialization phase\n     */\n    function initializeAccount(bytes calldata data) external payable;\n}\n"},"node_modules/@erc7579/implementation/src/utils/MSAProxy.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\nimport { Proxy } from \"@openzeppelin/contracts/proxy/Proxy.sol\";\nimport { ERC1967Utils } from \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Utils.sol\";\nimport { Initializable } from \"../lib/Initializable.sol\";\n\ncontract MSAProxy is Proxy {\n    constructor(address implementation, bytes memory _data) payable {\n        Initializable.setInitializable();\n        ERC1967Utils.upgradeToAndCall(implementation, _data);\n    }\n\n    function _implementation() internal view virtual override returns (address) {\n        return ERC1967Utils.getImplementation();\n    }\n}\n"},"node_modules/@erc7579/implementation/src/core/ExecutionHelper.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\nimport { Execution } from \"../interfaces/IERC7579Account.sol\";\n\n/**\n * @title Execution\n * @dev This contract executes calls in the context of this contract.\n * @author zeroknots.eth | rhinestone.wtf\n * shoutout to solady (vectorized, ross) for this code\n * https://github.com/Vectorized/solady/blob/main/src/accounts/ERC4337.sol\n */\ncontract ExecutionHelper {\n    error ExecutionFailed();\n\n    event TryExecuteUnsuccessful(uint256 batchExecutionindex, bytes result);\n\n    function _execute(Execution[] calldata executions) internal returns (bytes[] memory result) {\n        uint256 length = executions.length;\n        result = new bytes[](length);\n\n        for (uint256 i; i < length; i++) {\n            Execution calldata _exec = executions[i];\n            result[i] = _execute(_exec.target, _exec.value, _exec.callData);\n        }\n    }\n\n    function _tryExecute(Execution[] calldata executions)\n        internal\n        returns (bytes[] memory result)\n    {\n        uint256 length = executions.length;\n        result = new bytes[](length);\n\n        for (uint256 i; i < length; i++) {\n            Execution calldata _exec = executions[i];\n            bool success;\n            (success, result[i]) = _tryExecute(_exec.target, _exec.value, _exec.callData);\n            if (!success) emit TryExecuteUnsuccessful(i, result[i]);\n        }\n    }\n\n    function _execute(\n        address target,\n        uint256 value,\n        bytes calldata callData\n    )\n        internal\n        virtual\n        returns (bytes memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            calldatacopy(result, callData.offset, callData.length)\n            if iszero(call(gas(), target, value, result, callData.length, codesize(), 0x00)) {\n                // Bubble up the revert if the call reverts.\n                returndatacopy(result, 0x00, returndatasize())\n                revert(result, returndatasize())\n            }\n            mstore(result, returndatasize()) // Store the length.\n            let o := add(result, 0x20)\n            returndatacopy(o, 0x00, returndatasize()) // Copy the returndata.\n            mstore(0x40, add(o, returndatasize())) // Allocate the memory.\n        }\n    }\n\n    function _tryExecute(\n        address target,\n        uint256 value,\n        bytes calldata callData\n    )\n        internal\n        virtual\n        returns (bool success, bytes memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            calldatacopy(result, callData.offset, callData.length)\n            success := call(gas(), target, value, result, callData.length, codesize(), 0x00)\n            mstore(result, returndatasize()) // Store the length.\n            let o := add(result, 0x20)\n            returndatacopy(o, 0x00, returndatasize()) // Copy the returndata.\n            mstore(0x40, add(o, returndatasize())) // Allocate the memory.\n        }\n    }\n\n    /// @dev Execute a delegatecall with `delegate` on this account.\n    function _executeDelegatecall(\n        address delegate,\n        bytes calldata callData\n    )\n        internal\n        returns (bytes memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            calldatacopy(result, callData.offset, callData.length)\n            // Forwards the `data` to `delegate` via delegatecall.\n            if iszero(delegatecall(gas(), delegate, result, callData.length, codesize(), 0x00)) {\n                // Bubble up the revert if the call reverts.\n                returndatacopy(result, 0x00, returndatasize())\n                revert(result, returndatasize())\n            }\n            mstore(result, returndatasize()) // Store the length.\n            let o := add(result, 0x20)\n            returndatacopy(o, 0x00, returndatasize()) // Copy the returndata.\n            mstore(0x40, add(o, returndatasize())) // Allocate the memory.\n        }\n    }\n\n    /// @dev Execute a delegatecall with `delegate` on this account and catch reverts.\n    function _tryExecuteDelegatecall(\n        address delegate,\n        bytes calldata callData\n    )\n        internal\n        returns (bool success, bytes memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            calldatacopy(result, callData.offset, callData.length)\n            // Forwards the `data` to `delegate` via delegatecall.\n            success := delegatecall(gas(), delegate, result, callData.length, codesize(), 0x00)\n            mstore(result, returndatasize()) // Store the length.\n            let o := add(result, 0x20)\n            returndatacopy(o, 0x00, returndatasize()) // Copy the returndata.\n            mstore(0x40, add(o, returndatasize())) // Allocate the memory.\n        }\n    }\n}\n"},"node_modules/@erc7579/implementation/src/core/ModuleManager.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.21;\n\nimport { SentinelListLib, SENTINEL } from \"sentinellist/SentinelList.sol\";\nimport {\n    CallType, CALLTYPE_SINGLE, CALLTYPE_DELEGATECALL, CALLTYPE_STATIC\n} from \"../lib/ModeLib.sol\";\nimport { AccountBase } from \"./AccountBase.sol\";\nimport \"../interfaces/IERC7579Module.sol\";\nimport \"forge-std/interfaces/IERC165.sol\";\nimport \"./Receiver.sol\";\n\n/**\n * @title ModuleManager\n * @author zeroknots.eth | rhinestone.wtf\n * @dev This contract manages Validator, Executor and Fallback modules for the MSA\n * @dev it uses SentinelList to manage the linked list of modules\n * NOTE: the linked list is just an example. accounts may implement this differently\n */\nabstract contract ModuleManager is AccountBase, Receiver {\n    using SentinelListLib for SentinelListLib.SentinelList;\n\n    error InvalidModule(address module);\n    error NoFallbackHandler(bytes4 selector);\n    error CannotRemoveLastValidator();\n\n    event ValidatorUninstallFailed(address validator, bytes data);\n    event ExecutorUninstallFailed(address executor, bytes data);\n\n    // forgefmt: disable-next-line\n    // keccak256(abi.encode(uint256(keccak256(\"modulemanager.storage.msa\")) - 1)) & ~bytes32(uint256(0xff));\n    bytes32 internal constant MODULEMANAGER_STORAGE_LOCATION =\n        0xe3a55571e8f241b58442871487cc151a8cb048bb4ad24e833467f724ec89a900;\n\n    struct FallbackHandler {\n        address handler;\n        CallType calltype;\n    }\n\n    /// @custom:storage-location erc7201:modulemanager.storage.msa\n    struct ModuleManagerStorage {\n        // linked list of validators. List is initialized by initializeAccount()\n        SentinelListLib.SentinelList $valdiators;\n        // linked list of executors. List is initialized by initializeAccount()\n        SentinelListLib.SentinelList $executors;\n        // single fallback handler for all fallbacks\n        // account vendors may implement this differently. This is just a reference implementation\n        mapping(bytes4 selector => FallbackHandler fallbackHandler) $fallbacks;\n    }\n\n    function $moduleManager() internal pure virtual returns (ModuleManagerStorage storage $ims) {\n        bytes32 position = MODULEMANAGER_STORAGE_LOCATION;\n        assembly {\n            $ims.slot := position\n        }\n    }\n\n    modifier onlyExecutorModule() {\n        SentinelListLib.SentinelList storage $executors = $moduleManager().$executors;\n        if (!$executors.contains(msg.sender)) revert InvalidModule(msg.sender);\n        _;\n    }\n\n    modifier onlyValidatorModule(address validator) {\n        SentinelListLib.SentinelList storage $valdiators = $moduleManager().$valdiators;\n        if (!$valdiators.contains(validator)) revert InvalidModule(validator);\n        _;\n    }\n\n    function _initModuleManager() internal virtual {\n        ModuleManagerStorage storage $ims = $moduleManager();\n        $ims.$executors.init();\n        $ims.$valdiators.init();\n    }\n\n    function isAlreadyInitialized() internal view virtual returns (bool) {\n        ModuleManagerStorage storage $ims = $moduleManager();\n        return $ims.$valdiators.alreadyInitialized();\n    }\n\n    /////////////////////////////////////////////////////\n    //  Manage Validators\n    ////////////////////////////////////////////////////\n    function _installValidator(address validator, bytes calldata data) internal virtual {\n        SentinelListLib.SentinelList storage $valdiators = $moduleManager().$valdiators;\n        $valdiators.push(validator);\n        IValidator(validator).onInstall(data);\n    }\n\n    function _uninstallValidator(address validator, bytes calldata data) internal {\n        // TODO: check if its the last validator. this might brick the account\n        SentinelListLib.SentinelList storage $valdiators = $moduleManager().$valdiators;\n        (address prev, bytes memory disableModuleData) = abi.decode(data, (address, bytes));\n        $valdiators.pop(prev, validator);\n        IValidator(validator).onUninstall(disableModuleData);\n    }\n\n    /*\n    function _tryUninstallValidators(bytes[] calldata data) internal {\n        SentinelListLib.SentinelList storage $valdiators = $moduleManager().$valdiators;\n        uint256 length = data.length;\n        uint256 index;\n        address validator = $valdiators.getNext(SENTINEL);\n        while (validator != SENTINEL) {\n            bytes memory uninstallData;\n            if (index < length) {\n                uninstallData = data[index];\n            }\n            try IValidator(validator).onUninstall(uninstallData) {} catch {\n                emit ValidatorUninstallFailed(validator, uninstallData);\n            }\n            validator = $valdiators.getNext(validator);\n            index++;\n        }\n        $valdiators.popAll();\n    }\n    */\n\n    function _tryUninstallValidators() internal {\n        SentinelListLib.SentinelList storage $valdiators = $moduleManager().$valdiators;\n        address validator = $valdiators.getNext(SENTINEL);\n        while (validator != SENTINEL) {\n            try IValidator(validator).onUninstall(\"\") { }\n            catch {\n                emit ValidatorUninstallFailed(validator, \"\");\n            }\n            validator = $valdiators.getNext(validator);\n        }\n        $valdiators.popAll();\n    }\n\n    function _isValidatorInstalled(address validator) internal view virtual returns (bool) {\n        SentinelListLib.SentinelList storage $valdiators = $moduleManager().$valdiators;\n        return $valdiators.contains(validator);\n    }\n\n    /**\n     * THIS IS NOT PART OF THE STANDARD\n     * Helper Function to access linked list\n     */\n    function getValidatorsPaginated(\n        address cursor,\n        uint256 size\n    )\n        external\n        view\n        virtual\n        returns (address[] memory array, address next)\n    {\n        SentinelListLib.SentinelList storage $valdiators = $moduleManager().$valdiators;\n        return $valdiators.getEntriesPaginated(cursor, size);\n    }\n\n    /////////////////////////////////////////////////////\n    //  Manage Executors\n    ////////////////////////////////////////////////////\n\n    function _installExecutor(address executor, bytes calldata data) internal {\n        SentinelListLib.SentinelList storage $executors = $moduleManager().$executors;\n        $executors.push(executor);\n        IExecutor(executor).onInstall(data);\n    }\n\n    function _uninstallExecutor(address executor, bytes calldata data) internal {\n        SentinelListLib.SentinelList storage $executors = $moduleManager().$executors;\n        (address prev, bytes memory disableModuleData) = abi.decode(data, (address, bytes));\n        $executors.pop(prev, executor);\n        IExecutor(executor).onUninstall(disableModuleData);\n    }\n\n    /*\n    function _tryUninstallExecutors(bytes[] calldata data) internal {\n        SentinelListLib.SentinelList storage $executors = $moduleManager().$executors;\n        uint256 length = data.length;\n        uint256 index;\n        address executor = $executors.getNext(SENTINEL);\n        while (executor != SENTINEL) {\n            bytes memory uninstallData;\n            if (index < length) {\n                uninstallData = data[index];\n            }\n            try IExecutor(executor).onUninstall(uninstallData) {} catch {\n                emit ExecutorUninstallFailed(executor, uninstallData);\n            }\n            executor = $executors.getNext(executor);\n            index++;\n        }\n        $executors.popAll();\n    }\n    */\n\n    function _tryUninstallExecutors() internal {\n        SentinelListLib.SentinelList storage $executors = $moduleManager().$executors;\n        address executor = $executors.getNext(SENTINEL);\n        while (executor != SENTINEL) {\n            try IExecutor(executor).onUninstall(\"\") { }\n            catch {\n                emit ExecutorUninstallFailed(executor, \"\");\n            }\n            executor = $executors.getNext(executor);\n        }\n        $executors.popAll();\n    }\n\n    function _isExecutorInstalled(address executor) internal view virtual returns (bool) {\n        SentinelListLib.SentinelList storage $executors = $moduleManager().$executors;\n        return $executors.contains(executor);\n    }\n\n    /**\n     * THIS IS NOT PART OF THE STANDARD\n     * Helper Function to access linked list\n     */\n    function getExecutorsPaginated(\n        address cursor,\n        uint256 size\n    )\n        external\n        view\n        virtual\n        returns (address[] memory array, address next)\n    {\n        SentinelListLib.SentinelList storage $executors = $moduleManager().$executors;\n        return $executors.getEntriesPaginated(cursor, size);\n    }\n\n    /////////////////////////////////////////////////////\n    //  Manage Fallback\n    ////////////////////////////////////////////////////\n\n    function _installFallbackHandler(address handler, bytes calldata params) internal virtual {\n        bytes4 selector = bytes4(params[0:4]);\n        CallType calltype = CallType.wrap(bytes1(params[4]));\n        bytes memory initData = params[5:];\n\n        if (_isFallbackHandlerInstalled(selector)) {\n            revert(\"Function selector already used\");\n        }\n        $moduleManager().$fallbacks[selector] = FallbackHandler(handler, calltype);\n        IFallback(handler).onInstall(initData);\n    }\n\n    function _uninstallFallbackHandler(\n        address handler,\n        bytes calldata deInitData\n    )\n        internal\n        virtual\n    {\n        bytes4 selector = bytes4(deInitData[0:4]);\n        bytes memory _deInitData = deInitData[4:];\n\n        if (!_isFallbackHandlerInstalled(selector)) {\n            revert(\"Function selector not used\");\n        }\n\n        FallbackHandler memory activeFallback = $moduleManager().$fallbacks[selector];\n\n        if (activeFallback.handler != handler) {\n            revert(\"Function selector not used by this handler\");\n        }\n\n        $moduleManager().$fallbacks[selector] = FallbackHandler(address(0), CallType.wrap(0x00));\n\n        IFallback(handler).onUninstall(_deInitData);\n    }\n\n    function _isFallbackHandlerInstalled(bytes4 functionSig) internal view virtual returns (bool) {\n        FallbackHandler storage $fallback = $moduleManager().$fallbacks[functionSig];\n        return $fallback.handler != address(0);\n    }\n\n    function _isFallbackHandlerInstalled(\n        bytes4 functionSig,\n        address _handler\n    )\n        internal\n        view\n        virtual\n        returns (bool)\n    {\n        FallbackHandler storage $fallback = $moduleManager().$fallbacks[functionSig];\n        return $fallback.handler == _handler;\n    }\n\n    function getActiveFallbackHandler(bytes4 functionSig)\n        external\n        view\n        virtual\n        returns (FallbackHandler memory)\n    {\n        return $moduleManager().$fallbacks[functionSig];\n    }\n\n    // FALLBACK\n    fallback() external payable override(Receiver) receiverFallback {\n        FallbackHandler storage $fallbackHandler = $moduleManager().$fallbacks[msg.sig];\n        address handler = $fallbackHandler.handler;\n        CallType calltype = $fallbackHandler.calltype;\n        if (handler == address(0)) revert NoFallbackHandler(msg.sig);\n\n        if (calltype == CALLTYPE_STATIC) {\n            assembly {\n                function allocate(length) -> pos {\n                    pos := mload(0x40)\n                    mstore(0x40, add(pos, length))\n                }\n\n                let calldataPtr := allocate(calldatasize())\n                calldatacopy(calldataPtr, 0, calldatasize())\n\n                // The msg.sender address is shifted to the left by 12 bytes to remove the padding\n                // Then the address without padding is stored right after the calldata\n                let senderPtr := allocate(20)\n                mstore(senderPtr, shl(96, caller()))\n\n                // Add 20 bytes for the address appended add the end\n                let success :=\n                    staticcall(gas(), handler, calldataPtr, add(calldatasize(), 20), 0, 0)\n\n                let returnDataPtr := allocate(returndatasize())\n                returndatacopy(returnDataPtr, 0, returndatasize())\n                if iszero(success) { revert(returnDataPtr, returndatasize()) }\n                return(returnDataPtr, returndatasize())\n            }\n        }\n        if (calltype == CALLTYPE_SINGLE) {\n            assembly {\n                function allocate(length) -> pos {\n                    pos := mload(0x40)\n                    mstore(0x40, add(pos, length))\n                }\n\n                let calldataPtr := allocate(calldatasize())\n                calldatacopy(calldataPtr, 0, calldatasize())\n\n                // The msg.sender address is shifted to the left by 12 bytes to remove the padding\n                // Then the address without padding is stored right after the calldata\n                let senderPtr := allocate(20)\n                mstore(senderPtr, shl(96, caller()))\n\n                // Add 20 bytes for the address appended add the end\n                let success := call(gas(), handler, 0, calldataPtr, add(calldatasize(), 20), 0, 0)\n\n                let returnDataPtr := allocate(returndatasize())\n                returndatacopy(returnDataPtr, 0, returndatasize())\n                if iszero(success) { revert(returnDataPtr, returndatasize()) }\n                return(returnDataPtr, returndatasize())\n            }\n        }\n    }\n}\n"},"node_modules/@erc7579/implementation/src/core/HookManager.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.21;\n\nimport \"./ModuleManager.sol\";\nimport \"../interfaces/IERC7579Account.sol\";\nimport \"../interfaces/IERC7579Module.sol\";\n\n/**\n * @title reference implementation of HookManager\n * @author zeroknots.eth | rhinestone.wtf\n */\nabstract contract HookManager {\n    event HookUninstallFailed(address hook, bytes data);\n\n    /// @custom:storage-location erc7201:hookmanager.storage.msa\n    struct HookManagerStorage {\n        IHook _hook;\n    }\n\n    // forgefmt: disable-next-line\n    // keccak256(abi.encode(uint256(keccak256(\"hookmanager.storage.msa\")) - 1)) & ~bytes32(uint256(0xff));\n    bytes32 constant HOOKMANAGER_STORAGE_LOCATION =\n        0xcd97a6611018468306afd07ac8b14141bc76df8b844b3bcba1768d81e4598200;\n\n    error HookPostCheckFailed();\n    error HookAlreadyInstalled(address currentHook);\n\n    modifier withHook() {\n        address hook = _getHook();\n        if (hook == address(0)) {\n            _;\n        } else {\n            bytes memory hookData = IHook(hook).preCheck(msg.sender, msg.value, msg.data);\n            _;\n            IHook(hook).postCheck(hookData);\n        }\n    }\n\n    function _setHook(address hook) internal virtual {\n        bytes32 slot = HOOKMANAGER_STORAGE_LOCATION;\n        assembly {\n            sstore(slot, hook)\n        }\n    }\n\n    function _installHook(address hook, bytes calldata data) internal virtual {\n        address currentHook = _getHook();\n        if (currentHook != address(0)) {\n            revert HookAlreadyInstalled(currentHook);\n        }\n        _setHook(hook);\n        IHook(hook).onInstall(data);\n    }\n\n    function _uninstallHook(address hook, bytes calldata data) internal virtual {\n        _setHook(address(0));\n        IHook(hook).onUninstall(data);\n    }\n\n    function _tryUninstallHook(address hook) internal virtual {\n        if (hook != address(0)) {\n            try IHook(hook).onUninstall(\"\") { }\n            catch {\n                emit HookUninstallFailed(hook, \"\");\n            }\n            _setHook(address(0));\n        }\n    }\n\n    function _getHook() internal view returns (address _hook) {\n        bytes32 slot = HOOKMANAGER_STORAGE_LOCATION;\n        assembly {\n            _hook := sload(slot)\n        }\n    }\n\n    function _isHookInstalled(address module) internal view returns (bool) {\n        return _getHook() == module;\n    }\n\n    function getActiveHook() external view returns (address hook) {\n        return _getHook();\n    }\n}\n"},"node_modules/@erc7579/implementation/src/core/RegistryAdapter.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\nimport { IERC7484 } from \"../interfaces/IERC7484.sol\";\nimport { AccountBase } from \"./AccountBase.sol\";\n\n/**\n * @title RegistryAdapter\n * @author kopy-kat | rhinestone.wtf\n * @dev This contract uses ERC-7484 to check if a module is attested to and exposes a modifier to\n * use it.\n */\nabstract contract RegistryAdapter is AccountBase {\n    event ERC7484RegistryConfigured(address indexed smartAccount, address indexed registry);\n\n    IERC7484 internal $registry;\n\n    modifier withRegistry(address module, uint256 moduleTypeId) {\n        IERC7484 registry = $registry;\n        if (address(registry) != address(0)) {\n            registry.check(module, moduleTypeId);\n        }\n        _;\n    }\n\n    function setRegistry(\n        IERC7484 registry,\n        address[] calldata attesters,\n        uint8 threshold\n    )\n        external\n        onlyEntryPointOrSelf\n    {\n        $registry = registry;\n        if (attesters.length > 0) {\n            registry.trustAttesters(threshold, attesters);\n        }\n    }\n}\n"},"node_modules/@erc7579/implementation/src/lib/HashLib.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\nstring constant INIT_NOTATION = \"SignedInit(address bootstrap,bytes bootstrapInit)\";\nbytes32 constant INIT_TYPEHASH = keccak256(abi.encodePacked(INIT_NOTATION));\n\nlibrary HashLib {\n    function hash(address bootstrap, bytes memory bootstrapInit) internal pure returns (bytes32) {\n        return keccak256(abi.encode(INIT_TYPEHASH, bootstrap, keccak256(bootstrapInit)));\n    }\n}\n"},"node_modules/solady/src/utils/ECDSA.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Gas optimized ECDSA wrapper.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/ECDSA.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/ECDSA.sol)\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/ECDSA.sol)\n///\n/// @dev Note:\n/// - The recovery functions use the ecrecover precompile (0x1).\n/// - As of Solady version 0.0.68, the `recover` variants will revert upon recovery failure.\n///   This is for more safety by default.\n///   Use the `tryRecover` variants if you need to get the zero address back\n///   upon recovery failure instead.\n/// - As of Solady version 0.0.134, all `bytes signature` variants accept both\n///   regular 65-byte `(r, s, v)` and EIP-2098 `(r, vs)` short form signatures.\n///   See: https://eips.ethereum.org/EIPS/eip-2098\n///   This is for calldata efficiency on smart accounts prevalent on L2s.\n///\n/// WARNING! Do NOT directly use signatures as unique identifiers:\n/// - The recovery operations do NOT check if a signature is non-malleable.\n/// - Use a nonce in the digest to prevent replay attacks on the same contract.\n/// - Use EIP-712 for the digest to prevent replay attacks across different chains and contracts.\n///   EIP-712 also enables readable signing of typed data for better user safety.\n/// - If you need a unique hash from a signature, please use the `canonicalHash` functions.\nlibrary ECDSA {\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                         CONSTANTS                          */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev The order of the secp256k1 elliptic curve.\n    uint256 internal constant N =\n        0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141;\n\n    /// @dev `N/2 + 1`. Used for checking the malleability of the signature.\n    uint256 private constant _HALF_N_PLUS_1 =\n        0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a1;\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                        CUSTOM ERRORS                       */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev The signature is invalid.\n    error InvalidSignature();\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                    RECOVERY OPERATIONS                     */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev Recovers the signer's address from a message digest `hash`, and the `signature`.\n    function recover(bytes32 hash, bytes memory signature) internal view returns (address result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for { let m := mload(0x40) } 1 {\n                mstore(0x00, 0x8baa579f) // `InvalidSignature()`.\n                revert(0x1c, 0x04)\n            } {\n                switch mload(signature)\n                case 64 {\n                    let vs := mload(add(signature, 0x40))\n                    mstore(0x20, add(shr(255, vs), 27)) // `v`.\n                    mstore(0x60, shr(1, shl(1, vs))) // `s`.\n                }\n                case 65 {\n                    mstore(0x20, byte(0, mload(add(signature, 0x60)))) // `v`.\n                    mstore(0x60, mload(add(signature, 0x40))) // `s`.\n                }\n                default { continue }\n                mstore(0x00, hash)\n                mstore(0x40, mload(add(signature, 0x20))) // `r`.\n                result := mload(staticcall(gas(), 1, 0x00, 0x80, 0x01, 0x20))\n                mstore(0x60, 0) // Restore the zero slot.\n                mstore(0x40, m) // Restore the free memory pointer.\n                // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\n                if returndatasize() { break }\n            }\n        }\n    }\n\n    /// @dev Recovers the signer's address from a message digest `hash`, and the `signature`.\n    function recoverCalldata(bytes32 hash, bytes calldata signature)\n        internal\n        view\n        returns (address result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for { let m := mload(0x40) } 1 {\n                mstore(0x00, 0x8baa579f) // `InvalidSignature()`.\n                revert(0x1c, 0x04)\n            } {\n                switch signature.length\n                case 64 {\n                    let vs := calldataload(add(signature.offset, 0x20))\n                    mstore(0x20, add(shr(255, vs), 27)) // `v`.\n                    mstore(0x40, calldataload(signature.offset)) // `r`.\n                    mstore(0x60, shr(1, shl(1, vs))) // `s`.\n                }\n                case 65 {\n                    mstore(0x20, byte(0, calldataload(add(signature.offset, 0x40)))) // `v`.\n                    calldatacopy(0x40, signature.offset, 0x40) // Copy `r` and `s`.\n                }\n                default { continue }\n                mstore(0x00, hash)\n                result := mload(staticcall(gas(), 1, 0x00, 0x80, 0x01, 0x20))\n                mstore(0x60, 0) // Restore the zero slot.\n                mstore(0x40, m) // Restore the free memory pointer.\n                // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\n                if returndatasize() { break }\n            }\n        }\n    }\n\n    /// @dev Recovers the signer's address from a message digest `hash`,\n    /// and the EIP-2098 short form signature defined by `r` and `vs`.\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal view returns (address result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x00, hash)\n            mstore(0x20, add(shr(255, vs), 27)) // `v`.\n            mstore(0x40, r)\n            mstore(0x60, shr(1, shl(1, vs))) // `s`.\n            result := mload(staticcall(gas(), 1, 0x00, 0x80, 0x01, 0x20))\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\n            if iszero(returndatasize()) {\n                mstore(0x00, 0x8baa579f) // `InvalidSignature()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x60, 0) // Restore the zero slot.\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }\n\n    /// @dev Recovers the signer's address from a message digest `hash`,\n    /// and the signature defined by `v`, `r`, `s`.\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s)\n        internal\n        view\n        returns (address result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x00, hash)\n            mstore(0x20, and(v, 0xff))\n            mstore(0x40, r)\n            mstore(0x60, s)\n            result := mload(staticcall(gas(), 1, 0x00, 0x80, 0x01, 0x20))\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\n            if iszero(returndatasize()) {\n                mstore(0x00, 0x8baa579f) // `InvalidSignature()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x60, 0) // Restore the zero slot.\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                   TRY-RECOVER OPERATIONS                   */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    // WARNING!\n    // These functions will NOT revert upon recovery failure.\n    // Instead, they will return the zero address upon recovery failure.\n    // It is critical that the returned address is NEVER compared against\n    // a zero address (e.g. an uninitialized address variable).\n\n    /// @dev Recovers the signer's address from a message digest `hash`, and the `signature`.\n    function tryRecover(bytes32 hash, bytes memory signature)\n        internal\n        view\n        returns (address result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for { let m := mload(0x40) } 1 {} {\n                switch mload(signature)\n                case 64 {\n                    let vs := mload(add(signature, 0x40))\n                    mstore(0x20, add(shr(255, vs), 27)) // `v`.\n                    mstore(0x60, shr(1, shl(1, vs))) // `s`.\n                }\n                case 65 {\n                    mstore(0x20, byte(0, mload(add(signature, 0x60)))) // `v`.\n                    mstore(0x60, mload(add(signature, 0x40))) // `s`.\n                }\n                default { break }\n                mstore(0x00, hash)\n                mstore(0x40, mload(add(signature, 0x20))) // `r`.\n                pop(staticcall(gas(), 1, 0x00, 0x80, 0x40, 0x20))\n                mstore(0x60, 0) // Restore the zero slot.\n                // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\n                result := mload(xor(0x60, returndatasize()))\n                mstore(0x40, m) // Restore the free memory pointer.\n                break\n            }\n        }\n    }\n\n    /// @dev Recovers the signer's address from a message digest `hash`, and the `signature`.\n    function tryRecoverCalldata(bytes32 hash, bytes calldata signature)\n        internal\n        view\n        returns (address result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for { let m := mload(0x40) } 1 {} {\n                switch signature.length\n                case 64 {\n                    let vs := calldataload(add(signature.offset, 0x20))\n                    mstore(0x20, add(shr(255, vs), 27)) // `v`.\n                    mstore(0x40, calldataload(signature.offset)) // `r`.\n                    mstore(0x60, shr(1, shl(1, vs))) // `s`.\n                }\n                case 65 {\n                    mstore(0x20, byte(0, calldataload(add(signature.offset, 0x40)))) // `v`.\n                    calldatacopy(0x40, signature.offset, 0x40) // Copy `r` and `s`.\n                }\n                default { break }\n                mstore(0x00, hash)\n                pop(staticcall(gas(), 1, 0x00, 0x80, 0x40, 0x20))\n                mstore(0x60, 0) // Restore the zero slot.\n                // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\n                result := mload(xor(0x60, returndatasize()))\n                mstore(0x40, m) // Restore the free memory pointer.\n                break\n            }\n        }\n    }\n\n    /// @dev Recovers the signer's address from a message digest `hash`,\n    /// and the EIP-2098 short form signature defined by `r` and `vs`.\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs)\n        internal\n        view\n        returns (address result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x00, hash)\n            mstore(0x20, add(shr(255, vs), 27)) // `v`.\n            mstore(0x40, r)\n            mstore(0x60, shr(1, shl(1, vs))) // `s`.\n            pop(staticcall(gas(), 1, 0x00, 0x80, 0x40, 0x20))\n            mstore(0x60, 0) // Restore the zero slot.\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\n            result := mload(xor(0x60, returndatasize()))\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }\n\n    /// @dev Recovers the signer's address from a message digest `hash`,\n    /// and the signature defined by `v`, `r`, `s`.\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s)\n        internal\n        view\n        returns (address result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x00, hash)\n            mstore(0x20, and(v, 0xff))\n            mstore(0x40, r)\n            mstore(0x60, s)\n            pop(staticcall(gas(), 1, 0x00, 0x80, 0x40, 0x20))\n            mstore(0x60, 0) // Restore the zero slot.\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\n            result := mload(xor(0x60, returndatasize()))\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                     HASHING OPERATIONS                     */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev Returns an Ethereum Signed Message, created from a `hash`.\n    /// This produces a hash corresponding to the one signed with the\n    /// [`eth_sign`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_sign)\n    /// JSON-RPC method as part of EIP-191.\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x20, hash) // Store into scratch space for keccak256.\n            mstore(0x00, \"\\x00\\x00\\x00\\x00\\x19Ethereum Signed Message:\\n32\") // 28 bytes.\n            result := keccak256(0x04, 0x3c) // `32 * 2 - (32 - 28) = 60 = 0x3c`.\n        }\n    }\n\n    /// @dev Returns an Ethereum Signed Message, created from `s`.\n    /// This produces a hash corresponding to the one signed with the\n    /// [`eth_sign`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_sign)\n    /// JSON-RPC method as part of EIP-191.\n    /// Note: Supports lengths of `s` up to 999999 bytes.\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let sLength := mload(s)\n            let o := 0x20\n            mstore(o, \"\\x19Ethereum Signed Message:\\n\") // 26 bytes, zero-right-padded.\n            mstore(0x00, 0x00)\n            // Convert the `s.length` to ASCII decimal representation: `base10(s.length)`.\n            for { let temp := sLength } 1 {} {\n                o := sub(o, 1)\n                mstore8(o, add(48, mod(temp, 10)))\n                temp := div(temp, 10)\n                if iszero(temp) { break }\n            }\n            let n := sub(0x3a, o) // Header length: `26 + 32 - o`.\n            // Throw an out-of-offset error (consumes all gas) if the header exceeds 32 bytes.\n            returndatacopy(returndatasize(), returndatasize(), gt(n, 0x20))\n            mstore(s, or(mload(0x00), mload(n))) // Temporarily store the header.\n            result := keccak256(add(s, sub(0x20, n)), add(n, sLength))\n            mstore(s, sLength) // Restore the length.\n        }\n    }\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                  CANONICAL HASH FUNCTIONS                  */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    // The following functions return the hash of the signature in its canonicalized format,\n    // which is the 65-byte `abi.encodePacked(r, s, uint8(v))`, where `v` is either 27 or 28.\n    // If `s` is greater than `N / 2` then it will be converted to `N - s`\n    // and the `v` value will be flipped.\n    // If the signature has an invalid length, or if `v` is invalid,\n    // a uniquely corrupt hash will be returned.\n    // These functions are useful for \"poor-mans-VRF\".\n\n    /// @dev Returns the canonical hash of `signature`.\n    function canonicalHash(bytes memory signature) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let l := mload(signature)\n            for {} 1 {} {\n                mstore(0x00, mload(add(signature, 0x20))) // `r`.\n                let s := mload(add(signature, 0x40))\n                let v := mload(add(signature, 0x41))\n                if eq(l, 64) {\n                    v := add(shr(255, s), 27)\n                    s := shr(1, shl(1, s))\n                }\n                if iszero(lt(s, _HALF_N_PLUS_1)) {\n                    v := xor(v, 7)\n                    s := sub(N, s)\n                }\n                mstore(0x21, v)\n                mstore(0x20, s)\n                result := keccak256(0x00, 0x41)\n                mstore(0x21, 0) // Restore the overwritten part of the free memory pointer.\n                break\n            }\n\n            // If the length is neither 64 nor 65, return a uniquely corrupted hash.\n            if iszero(lt(sub(l, 64), 2)) {\n                // `bytes4(keccak256(\"InvalidSignatureLength\"))`.\n                result := xor(keccak256(add(signature, 0x20), l), 0xd62f1ab2)\n            }\n        }\n    }\n\n    /// @dev Returns the canonical hash of `signature`.\n    function canonicalHashCalldata(bytes calldata signature)\n        internal\n        pure\n        returns (bytes32 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for {} 1 {} {\n                mstore(0x00, calldataload(signature.offset)) // `r`.\n                let s := calldataload(add(signature.offset, 0x20))\n                let v := calldataload(add(signature.offset, 0x21))\n                if eq(signature.length, 64) {\n                    v := add(shr(255, s), 27)\n                    s := shr(1, shl(1, s))\n                }\n                if iszero(lt(s, _HALF_N_PLUS_1)) {\n                    v := xor(v, 7)\n                    s := sub(N, s)\n                }\n                mstore(0x21, v)\n                mstore(0x20, s)\n                result := keccak256(0x00, 0x41)\n                mstore(0x21, 0) // Restore the overwritten part of the free memory pointer.\n                break\n            }\n            // If the length is neither 64 nor 65, return a uniquely corrupted hash.\n            if iszero(lt(sub(signature.length, 64), 2)) {\n                calldatacopy(mload(0x40), signature.offset, signature.length)\n                // `bytes4(keccak256(\"InvalidSignatureLength\"))`.\n                result := xor(keccak256(mload(0x40), signature.length), 0xd62f1ab2)\n            }\n        }\n    }\n\n    /// @dev Returns the canonical hash of `signature`.\n    function canonicalHash(bytes32 r, bytes32 vs) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, r) // `r`.\n            let v := add(shr(255, vs), 27)\n            let s := shr(1, shl(1, vs))\n            mstore(0x21, v)\n            mstore(0x20, s)\n            result := keccak256(0x00, 0x41)\n            mstore(0x21, 0) // Restore the overwritten part of the free memory pointer.\n        }\n    }\n\n    /// @dev Returns the canonical hash of `signature`.\n    function canonicalHash(uint8 v, bytes32 r, bytes32 s) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, r) // `r`.\n            if iszero(lt(s, _HALF_N_PLUS_1)) {\n                v := xor(v, 7)\n                s := sub(N, s)\n            }\n            mstore(0x21, v)\n            mstore(0x20, s)\n            result := keccak256(0x00, 0x41)\n            mstore(0x21, 0) // Restore the overwritten part of the free memory pointer.\n        }\n    }\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*                   EMPTY CALLDATA HELPERS                   */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    /// @dev Returns an empty calldata bytes.\n    function emptySignature() internal pure returns (bytes calldata signature) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            signature.length := 0\n        }\n    }\n}\n"},"node_modules/@erc7579/implementation/src/lib/Initializable.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\nbytes32 constant INIT_SLOT = keccak256(\n    abi.encode(uint256(keccak256(\"initializable.transient.msa\")) - 1)\n) & ~bytes32(uint256(0xff));\n\nlibrary Initializable {\n    error NotInitializable();\n\n    function checkInitializable() internal view {\n        bytes32 slot = INIT_SLOT;\n        // Load the current value from the slot, revert if 0\n        assembly {\n            let isInitializable := tload(slot)\n            if iszero(isInitializable) {\n                mstore(0x0, 0xaed59595) // NotInitializable()\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    function setInitializable() internal {\n        bytes32 slot = INIT_SLOT;\n        assembly {\n            tstore(slot, 0x01)\n        }\n    }\n}\n"},"node_modules/@erc7579/implementation/src/core/ERC7779Adapter.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\nimport { IERC7779 } from \"../interfaces/IERC7779.sol\";\n\nabstract contract ERC7779Adapter is IERC7779 {\n    error NonAuthorizedOnRedelegationCaller();\n\n    // keccak256(abi.encode(uint256(keccak256(bytes(\"InteroperableDelegatedAccount.ERC.Storage\"))) -\n    // 1)) & ~bytes32(uint256(0xff));\n    bytes32 internal constant ERC7779_STORAGE_BASE =\n        0xc473de86d0138e06e4d4918a106463a7cc005258d2e21915272bcb4594c18900;\n\n    struct ERC7779Storage {\n        bytes32[] storageBases;\n    }\n    /*\n    * @dev    Externally shares the storage bases that has been used throughout the account.\n    *         Majority of 7702 accounts will have their distinctive storage base to reduce the\n    chance of storage collision.\n    *         This allows the external entities to know what the storage base is of the account.\n    *         Wallets willing to redelegate already-delegated accounts should call\n    accountStorageBase() to check if it confirms with the account it plans to redelegate.\n    *\n    *         The bytes32 array should be stored at the storage slot:\n    keccak(keccak('InteroperableDelegatedAccount.ERC.Storage')-1) & ~0xff\n    *         This is an append-only array so newly redelegated accounts should not overwrite the\n    storage at this slot, but just append their base to the array.\n    *         This append operation should be done during the initialization of the account.\n    */\n\n    function accountStorageBases() external view returns (bytes32[] memory) {\n        ERC7779Storage storage $;\n        assembly {\n            $.slot := ERC7779_STORAGE_BASE\n        }\n        return $.storageBases;\n    }\n\n    function _addStorageBase(bytes32 storageBase) internal {\n        ERC7779Storage storage $;\n        assembly {\n            $.slot := ERC7779_STORAGE_BASE\n        }\n        $.storageBases.push(storageBase);\n    }\n\n    /*\n    * @dev    Function called before redelegation.\n    *         This function should prepare the account for a delegation to a different\n    implementation.\n    *         This function could be triggered by the new wallet that wants to redelegate an already\n    delegated EOA.\n    *         It should uninitialize storages if needed and execute wallet-specific logic to prepare\n    for redelegation.\n    *         msg.sender should be the owner of the account.\n    */\n    function onRedelegation() external returns (bool) {\n        require(msg.sender == address(this), NonAuthorizedOnRedelegationCaller());\n        _onRedelegation();\n        return true;\n    }\n\n    /// @dev This function is called before redelegation.\n    /// @dev Account should override this function to implement the specific logic.\n    function _onRedelegation() internal virtual;\n}\n"},"node_modules/@rhinestone/sentinellist/src/SentinelList.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// Sentinel address\naddress constant SENTINEL = address(0x1);\n// Zero address\naddress constant ZERO_ADDRESS = address(0x0);\n\n/**\n * @title SentinelListLib\n * @dev Library for managing a linked list of addresses\n * @author Rhinestone\n */\nlibrary SentinelListLib {\n    // Struct to hold the linked list\n    struct SentinelList {\n        mapping(address => address) entries;\n    }\n\n    error LinkedList_AlreadyInitialized();\n    error LinkedList_InvalidPage();\n    error LinkedList_InvalidEntry(address entry);\n    error LinkedList_EntryAlreadyInList(address entry);\n\n    /**\n     * Initialize the linked list\n     *\n     * @param self The linked list\n     */\n    function init(SentinelList storage self) internal {\n        if (alreadyInitialized(self)) revert LinkedList_AlreadyInitialized();\n        self.entries[SENTINEL] = SENTINEL;\n    }\n\n    /**\n     * Check if the linked list is already initialized\n     *\n     * @param self The linked list\n     *\n     * @return bool True if the linked list is already initialized\n     */\n    function alreadyInitialized(SentinelList storage self) internal view returns (bool) {\n        return self.entries[SENTINEL] != ZERO_ADDRESS;\n    }\n\n    /**\n     * Get the next entry in the linked list\n     *\n     * @param self The linked list\n     * @param entry The current entry\n     *\n     * @return address The next entry\n     */\n    function getNext(SentinelList storage self, address entry) internal view returns (address) {\n        if (entry == ZERO_ADDRESS) {\n            revert LinkedList_InvalidEntry(entry);\n        }\n        return self.entries[entry];\n    }\n\n    /**\n     * Push a new entry to the linked list\n     *\n     * @param self The linked list\n     * @param newEntry The new entry\n     */\n    function push(SentinelList storage self, address newEntry) internal {\n        if (newEntry == ZERO_ADDRESS || newEntry == SENTINEL) {\n            revert LinkedList_InvalidEntry(newEntry);\n        }\n        if (self.entries[newEntry] != ZERO_ADDRESS) revert LinkedList_EntryAlreadyInList(newEntry);\n        self.entries[newEntry] = self.entries[SENTINEL];\n        self.entries[SENTINEL] = newEntry;\n    }\n\n    /**\n     * Safe push a new entry to the linked list\n     * @dev This ensures that the linked list is initialized and initializes it if it is not\n     *\n     * @param self The linked list\n     * @param newEntry The new entry\n     */\n    function safePush(SentinelList storage self, address newEntry) internal {\n        if (!alreadyInitialized({ self: self })) {\n            init({ self: self });\n        }\n        push({ self: self, newEntry: newEntry });\n    }\n\n    /**\n     * Pop an entry from the linked list\n     *\n     * @param self The linked list\n     * @param prevEntry The entry before the entry to pop\n     * @param popEntry The entry to pop\n     */\n    function pop(SentinelList storage self, address prevEntry, address popEntry) internal {\n        if (popEntry == ZERO_ADDRESS || popEntry == SENTINEL) {\n            revert LinkedList_InvalidEntry(prevEntry);\n        }\n        if (self.entries[prevEntry] != popEntry) revert LinkedList_InvalidEntry(popEntry);\n        self.entries[prevEntry] = self.entries[popEntry];\n        self.entries[popEntry] = ZERO_ADDRESS;\n    }\n\n    /**\n     * Pop all entries from the linked list\n     *\n     * @param self The linked list\n     */\n    function popAll(SentinelList storage self) internal {\n        address next = self.entries[SENTINEL];\n        while (next != ZERO_ADDRESS) {\n            address current = next;\n            next = self.entries[next];\n            self.entries[current] = ZERO_ADDRESS;\n        }\n    }\n\n    /**\n     * Check if the linked list contains an entry\n     *\n     * @param self The linked list\n     * @param entry The entry to check\n     *\n     * @return bool True if the linked list contains the entry\n     */\n    function contains(SentinelList storage self, address entry) internal view returns (bool) {\n        return SENTINEL != entry && self.entries[entry] != ZERO_ADDRESS;\n    }\n\n    /**\n     * Get all entries in the linked list\n     *\n     * @param self The linked list\n     * @param start The start entry\n     * @param pageSize The page size\n     *\n     * @return array All entries in the linked list\n     * @return next The next entry\n     */\n    function getEntriesPaginated(\n        SentinelList storage self,\n        address start,\n        uint256 pageSize\n    )\n        internal\n        view\n        returns (address[] memory array, address next)\n    {\n        if (start != SENTINEL && !contains(self, start)) revert LinkedList_InvalidEntry(start);\n        if (pageSize == 0) revert LinkedList_InvalidPage();\n        // Init array with max page size\n        array = new address[](pageSize);\n\n        // Populate return array\n        uint256 entryCount = 0;\n        next = self.entries[start];\n        while (next != ZERO_ADDRESS && next != SENTINEL && entryCount < pageSize) {\n            array[entryCount] = next;\n            next = self.entries[next];\n            entryCount++;\n        }\n\n        /**\n         * Because of the argument validation, we can assume that the loop will always iterate over\n         * the valid entry list values\n         *       and the `next` variable will either be an enabled entry or a sentinel address\n         * (signalling the end).\n         *\n         *       If we haven't reached the end inside the loop, we need to set the next pointer to\n         * the last element of the entry array\n         *       because the `next` variable (which is a entry by itself) acting as a pointer to the\n         * start of the next page is neither\n         *       incSENTINELrent page, nor will it be included in the next one if you pass it as a\n         * start.\n         */\n        if (next != SENTINEL && entryCount > 0) {\n            next = array[entryCount - 1];\n        }\n        // Set correct size of returned array\n        // solhint-disable-next-line no-inline-assembly\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(array, entryCount)\n        }\n    }\n}\n"},"node_modules/@erc7579/implementation/src/core/PreValidationHookManager.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.21;\n\nimport \"./ModuleManager.sol\";\nimport \"../interfaces/IERC7579Account.sol\";\nimport \"../interfaces/IERC7579Module.sol\";\n\n/**\n * @title reference implementation of PreValidationHookManager\n * @author highskore | rhinestone.wtf\n */\nabstract contract PreValidationHookManager {\n    event PreValidationHookUninstallFailed(address hook, bytes data);\n\n    error InvalidHookType();\n\n    /// @custom:storage-location erc7201:prevalidationhookmanager.storage.msa\n    struct PreValidationHookManagerStorage {\n        IPreValidationHookERC1271 hook1271;\n        IPreValidationHookERC4337 hook4337;\n    }\n\n    // forgefmt: disable-next-line\n    // keccak256(abi.encode(uint256(keccak256(\"prevalidationhookmanager.storage.msa\")) - 1)) & ~bytes32(uint256(0xff));\n    bytes32 constant PREVALIDATION_HOOKMANAGER_STORAGE_LOCATION =\n        0x088e45215d3756b04bd240e41d75700a696139d5b53082481ffc3914e4840000;\n\n    error PreValidationHookAlreadyInstalled(address currentHook);\n\n    function _getStorage()\n        internal\n        pure\n        returns (PreValidationHookManagerStorage storage storage_)\n    {\n        bytes32 slot = PREVALIDATION_HOOKMANAGER_STORAGE_LOCATION;\n        assembly {\n            storage_.slot := slot\n        }\n    }\n\n    function _setPreValidationHook(address hook, uint256 hookType) internal virtual {\n        PreValidationHookManagerStorage storage $ = _getStorage();\n        if (hookType == MODULE_TYPE_PREVALIDATION_HOOK_ERC1271) {\n            $.hook1271 = IPreValidationHookERC1271(hook);\n        } else if (hookType == MODULE_TYPE_PREVALIDATION_HOOK_ERC4337) {\n            $.hook4337 = IPreValidationHookERC4337(hook);\n        } else {\n            revert InvalidHookType();\n        }\n    }\n\n    function _installPreValidationHook(\n        address hook,\n        uint256 hookType,\n        bytes calldata data\n    )\n        internal\n        virtual\n    {\n        PreValidationHookManagerStorage storage $ = _getStorage();\n        address currentHook = _getPreValidationHook(hookType);\n        if (currentHook != address(0)) {\n            revert PreValidationHookAlreadyInstalled(currentHook);\n        }\n        _setPreValidationHook(hook, hookType);\n        if (hookType == MODULE_TYPE_PREVALIDATION_HOOK_ERC1271) {\n            $.hook1271.onInstall(data);\n        } else if (hookType == MODULE_TYPE_PREVALIDATION_HOOK_ERC4337) {\n            $.hook4337.onInstall(data);\n        }\n    }\n\n    function _uninstallPreValidationHook(\n        address hook,\n        uint256 hookType,\n        bytes calldata data\n    )\n        internal\n        virtual\n    {\n        PreValidationHookManagerStorage storage $ = _getStorage();\n        if (hookType == MODULE_TYPE_PREVALIDATION_HOOK_ERC1271 && address($.hook1271) == hook) {\n            $.hook1271.onUninstall(data);\n        } else if (\n            hookType == MODULE_TYPE_PREVALIDATION_HOOK_ERC4337 && address($.hook4337) == hook\n        ) {\n            $.hook4337.onUninstall(data);\n        } else {\n            revert InvalidHookType();\n        }\n        _setPreValidationHook(address(0), hookType);\n    }\n\n    function _tryUninstallPreValidationHook(address hook, uint256 hookType) internal virtual {\n        PreValidationHookManagerStorage storage $ = _getStorage();\n        if (hookType == MODULE_TYPE_PREVALIDATION_HOOK_ERC1271) {\n            try $.hook1271.onUninstall(\"\") { }\n            catch {\n                emit PreValidationHookUninstallFailed(hook, \"\");\n            }\n            $.hook1271 = IPreValidationHookERC1271(address(0));\n        } else if (hookType == MODULE_TYPE_PREVALIDATION_HOOK_ERC4337) {\n            try $.hook4337.onUninstall(\"\") { }\n            catch {\n                emit PreValidationHookUninstallFailed(hook, \"\");\n            }\n            $.hook4337 = IPreValidationHookERC4337(address(0));\n        } else {\n            revert InvalidHookType();\n        }\n    }\n\n    function _getPreValidationHook(uint256 hookType) internal view returns (address _hook) {\n        PreValidationHookManagerStorage storage $ = _getStorage();\n        if (hookType == MODULE_TYPE_PREVALIDATION_HOOK_ERC1271) {\n            return address($.hook1271);\n        } else if (hookType == MODULE_TYPE_PREVALIDATION_HOOK_ERC4337) {\n            return address($.hook4337);\n        } else {\n            revert InvalidHookType();\n        }\n    }\n\n    function _isPreValidationHookInstalled(\n        address module,\n        uint256 hookType\n    )\n        internal\n        view\n        returns (bool)\n    {\n        return _getPreValidationHook(hookType) == module;\n    }\n\n    function getActiveHook(uint256 hookType) external view returns (address hook) {\n        return _getPreValidationHook(hookType);\n    }\n\n    function _withPreValidationHook(\n        bytes32 hash,\n        bytes calldata signature\n    )\n        internal\n        view\n        virtual\n        returns (bytes32 postHash, bytes memory postSig)\n    {\n        address preValidationHook = _getPreValidationHook(MODULE_TYPE_PREVALIDATION_HOOK_ERC1271);\n        if (preValidationHook == address(0)) {\n            return (hash, signature);\n        } else {\n            return IPreValidationHookERC1271(preValidationHook).preValidationHookERC1271(\n                msg.sender, hash, signature\n            );\n        }\n    }\n\n    function _withPreValidationHook(\n        bytes32 hash,\n        PackedUserOperation memory userOp,\n        uint256 missingAccountFunds\n    )\n        internal\n        virtual\n        returns (bytes32 postHash, bytes memory postSig)\n    {\n        address preValidationHook = _getPreValidationHook(MODULE_TYPE_PREVALIDATION_HOOK_ERC4337);\n        if (preValidationHook == address(0)) {\n            return (hash, userOp.signature);\n        } else {\n            return IPreValidationHookERC4337(preValidationHook).preValidationHookERC4337(\n                userOp, missingAccountFunds, hash\n            );\n        }\n    }\n}\n"},"node_modules/@erc7579/implementation/src/interfaces/IERC4337Account.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\nimport { PackedUserOperation } from \"account-abstraction/interfaces/PackedUserOperation.sol\";\n\ninterface IERC4337Account {\n    /**\n     * Validate user's signature and nonce\n     * the entryPoint will make the call to the recipient only if this validation call returns\n     * successfully.\n     * signature failure should be reported by returning SIG_VALIDATION_FAILED (1).\n     * This allows making a \"simulation call\" without a valid signature\n     * Other failures (e.g. nonce mismatch, or invalid signature format) should still revert to\n     * signal failure.\n     *\n     * @dev Must validate caller is the entryPoint.\n     *      Must validate the signature and nonce\n     * @param userOp              - The operation that is about to be executed.\n     * @param userOpHash          - Hash of the user's request data. can be used as the basis for\n     * signature.\n     * @param missingAccountFunds - Missing funds on the account's deposit in the entrypoint.\n     *                              This is the minimum amount to transfer to the sender(entryPoint)\n     * to be\n     *                              able to make the call. The excess is left as a deposit in the\n     * entrypoint\n     *                              for future calls. Can be withdrawn anytime using\n     * \"entryPoint.withdrawTo()\".\n     *                              In case there is a paymaster in the request (or the current\n     * deposit is high\n     *                              enough), this value will be zero.\n     * @return validationData       - Packaged ValidationData structure. use `_packValidationData`\n     * and\n     *                              `_unpackValidationData` to encode and decode.\n     *                              <20-byte> sigAuthorizer - 0 for valid signature, 1 to mark\n     * signature failure,\n     *                                 otherwise, an address of an \"authorizer\" contract.\n     *                              <6-byte> validUntil - Last timestamp this operation is valid. 0\n     * for \"indefinite\"\n     *                              <6-byte> validAfter - First timestamp this operation is valid\n     *                                                    If an account doesn't use time-range, it\n     * is enough to\n     *                                                    return SIG_VALIDATION_FAILED value (1) for\n     * signature failure.\n     *                              Note that the validation code cannot use block.timestamp (or\n     * block.number) directly.\n     */\n    function validateUserOp(\n        PackedUserOperation calldata userOp,\n        bytes32 userOpHash,\n        uint256 missingAccountFunds\n    )\n        external\n        payable\n        returns (uint256 validationData);\n\n    /**\n     * Account may implement this execute method.\n     * passing this methodSig at the beginning of callData will cause the entryPoint to pass the\n     * full UserOp (and hash)\n     * to the account.\n     * The account should skip the methodSig, and use the callData (and optionally, other UserOp\n     * fields)\n     *\n     * @param userOp              - The operation that was just validated.\n     * @param userOpHash          - Hash of the user's request data.\n     */\n    function executeUserOp(\n        PackedUserOperation calldata userOp,\n        bytes32 userOpHash\n    )\n        external\n        payable;\n}\n"},"node_modules/@erc7579/implementation/src/interfaces/IERC7779.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\ninterface IERC7779 {\n    /*\n    * @dev    Externally shares the storage bases that has been used throughout the account.\n    *         Majority of 7702 accounts will have their distinctive storage base to reduce the\n    chance of storage collision.\n    *         This allows the external entities to know what the storage base is of the account.\n    *         Wallets willing to redelegate already-delegated accounts should call\n    accountStorageBase() to check if it confirms with the account it plans to redelegate.\n    *\n    *         The bytes32 array should be stored at the storage slot:\n    keccak(keccak('InteroperableDelegatedAccount.ERC.Storage')-1) & ~0xff\n    *         This is an append-only array so newly redelegated accounts should not overwrite the\n    storage at this slot, but just append their base to the array.\n    *         This append operation should be done during the initialization of the account.\n    */\n    function accountStorageBases() external view returns (bytes32[] memory);\n\n    /*\n    * @dev    Function called before redelegation.\n    *         This function should prepare the account for a delegation to a different\n    implementation.\n    *         This function could be triggered by the new wallet that wants to redelegate an already\n    delegated EOA.\n    *         It should uninitialize storages if needed and execute wallet-specific logic to prepare\n    for redelegation.\n    *         msg.sender should be the owner of the account.\n    */\n    function onRedelegation() external returns (bool);\n}\n"},"node_modules/@openzeppelin/contracts/proxy/Proxy.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/Proxy.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback\n     * function and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable virtual {\n        _fallback();\n    }\n}\n"},"node_modules/@openzeppelin/contracts/proxy/ERC1967/ERC1967Utils.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/ERC1967/ERC1967Utils.sol)\n\npragma solidity ^0.8.20;\n\nimport {IBeacon} from \"../beacon/IBeacon.sol\";\nimport {Address} from \"../../utils/Address.sol\";\nimport {StorageSlot} from \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n */\nlibrary ERC1967Utils {\n    // We re-declare ERC-1967 events here because they can't be used directly from IERC1967.\n    // This will be fixed in Solidity 0.8.21. At that point we should remove these events.\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Emitted when the beacon is changed.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev The `implementation` of the proxy is invalid.\n     */\n    error ERC1967InvalidImplementation(address implementation);\n\n    /**\n     * @dev The `admin` of the proxy is invalid.\n     */\n    error ERC1967InvalidAdmin(address admin);\n\n    /**\n     * @dev The `beacon` of the proxy is invalid.\n     */\n    error ERC1967InvalidBeacon(address beacon);\n\n    /**\n     * @dev An upgrade function sees `msg.value > 0` that may be lost.\n     */\n    error ERC1967NonPayable();\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        if (newImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(newImplementation);\n        }\n        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Performs implementation upgrade with additional setup call if data is nonempty.\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\n     * to avoid stuck value in the contract.\n     *\n     * Emits an {IERC1967-Upgraded} event.\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n\n        if (data.length > 0) {\n            Address.functionDelegateCall(newImplementation, data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using\n     * the https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        if (newAdmin == address(0)) {\n            revert ERC1967InvalidAdmin(address(0));\n        }\n        StorageSlot.getAddressSlot(ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {IERC1967-AdminChanged} event.\n     */\n    function changeAdmin(address newAdmin) internal {\n        emit AdminChanged(getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is the keccak-256 hash of \"eip1967.proxy.beacon\" subtracted by 1.\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    bytes32 internal constant BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        if (newBeacon.code.length == 0) {\n            revert ERC1967InvalidBeacon(newBeacon);\n        }\n\n        StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;\n\n        address beaconImplementation = IBeacon(newBeacon).implementation();\n        if (beaconImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(beaconImplementation);\n        }\n    }\n\n    /**\n     * @dev Change the beacon and trigger a setup call if data is nonempty.\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\n     * to avoid stuck value in the contract.\n     *\n     * Emits an {IERC1967-BeaconUpgraded} event.\n     *\n     * CAUTION: Invoking this function has no effect on an instance of {BeaconProxy} since v5, since\n     * it uses an immutable beacon without looking at the value of the ERC-1967 beacon slot for\n     * efficiency.\n     */\n    function upgradeBeaconToAndCall(address newBeacon, bytes memory data) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n\n        if (data.length > 0) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n\n    /**\n     * @dev Reverts if `msg.value` is not zero. It can be used to avoid `msg.value` stuck in the contract\n     * if an upgrade doesn't perform an initialization call.\n     */\n    function _checkNonPayable() private {\n        if (msg.value > 0) {\n            revert ERC1967NonPayable();\n        }\n    }\n}\n"},"node_modules/@erc7579/implementation/src/core/AccountBase.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.21;\n\n/**\n * @title reference implementation of the minimal modular smart account with Hook Extension\n * @author zeroknots.eth | rhinestone.wtf\n */\ncontract AccountBase {\n    error AccountAccessUnauthorized();\n\n    /////////////////////////////////////////////////////\n    // Access Control\n    ////////////////////////////////////////////////////\n\n    modifier onlyEntryPointOrSelf() virtual {\n        if (!(msg.sender == entryPoint() || msg.sender == address(this))) {\n            revert AccountAccessUnauthorized();\n        }\n        _;\n    }\n\n    modifier onlyEntryPoint() virtual {\n        if (msg.sender != entryPoint()) {\n            revert AccountAccessUnauthorized();\n        }\n        _;\n    }\n\n    function entryPoint() public view virtual returns (address) {\n        return 0x0000000071727De22E5E9d8BAf0edAc6f37da032;\n    }\n\n    /// @dev Sends to the EntryPoint (i.e. `msg.sender`) the missing funds for this transaction.\n    /// Subclass MAY override this modifier for better funds management.\n    /// (e.g. send to the EntryPoint more than the minimum required, so that in future transactions\n    /// it will not be required to send again)\n    ///\n    /// `missingAccountFunds` is the minimum value this modifier should send the EntryPoint,\n    /// which MAY be zero, in case there is enough deposit, or the userOp has a paymaster.\n    modifier payPrefund(uint256 missingAccountFunds) virtual {\n        _;\n        /// @solidity memory-safe-assembly\n        assembly {\n            if missingAccountFunds {\n                // Ignore failure (it's EntryPoint's job to verify, not the account's).\n                pop(call(gas(), caller(), missingAccountFunds, codesize(), 0x00, codesize(), 0x00))\n            }\n        }\n    }\n}\n"},"node_modules/forge-std/src/interfaces/IERC165.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2;\n\ninterface IERC165 {\n    /// @notice Query if a contract implements an interface\n    /// @param interfaceID The interface identifier, as specified in ERC-165\n    /// @dev Interface identification is specified in ERC-165. This function\n    /// uses less than 30,000 gas.\n    /// @return `true` if the contract implements `interfaceID` and\n    /// `interfaceID` is not 0xffffffff, `false` otherwise\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\n}\n"},"node_modules/@erc7579/implementation/src/core/Receiver.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\n/**\n * @title Receiver\n * @dev This contract receives safe-transferred ERC721 and ERC1155 tokens.\n * @author Modified from Solady\n * (https://github.com/Vectorized/solady/blob/main/src/accounts/Receiver.sol)\n */\nabstract contract Receiver {\n    /// @dev For receiving ETH.\n    receive() external payable virtual { }\n\n    /// @dev Fallback function with the `receiverFallback` modifier.\n    fallback() external payable virtual receiverFallback { }\n\n    /// @dev Modifier for the fallback function to handle token callbacks.\n    modifier receiverFallback() virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let s := shr(224, calldataload(0))\n            // 0x150b7a02: `onERC721Received(address,address,uint256,bytes)`.\n            // 0xf23a6e61: `onERC1155Received(address,address,uint256,uint256,bytes)`.\n            // 0xbc197c81: `onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)`.\n            if or(eq(s, 0x150b7a02), or(eq(s, 0xf23a6e61), eq(s, 0xbc197c81))) {\n                mstore(0x20, s) // Store `msg.sig`.\n                return(0x3c, 0x20) // Return `msg.sig`.\n            }\n        }\n        _;\n    }\n}\n"},"node_modules/@erc7579/implementation/src/interfaces/IERC7484.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC7484 {\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*          Check with Registry internal attesters            */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n    function check(address module) external view;\n\n    function checkForAccount(address smartAccount, address module) external view;\n\n    function check(address module, uint256 moduleType) external view;\n\n    function checkForAccount(\n        address smartAccount,\n        address module,\n        uint256 moduleType\n    )\n        external\n        view;\n\n    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/\n    /*              Check with external attester(s)               */\n    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/\n\n    function check(address module, address attester) external view;\n\n    function check(address module, uint256 moduleType, address attester) external view;\n\n    function checkN(\n        address module,\n        address[] calldata attesters,\n        uint256 threshold\n    )\n        external\n        view;\n\n    function checkN(\n        address module,\n        uint256 moduleType,\n        address[] calldata attesters,\n        uint256 threshold\n    )\n        external\n        view;\n\n    function trustAttesters(uint8 threshold, address[] calldata attesters) external;\n}\n"},"node_modules/@openzeppelin/contracts/proxy/beacon/IBeacon.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {UpgradeableBeacon} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"},"node_modules/@openzeppelin/contracts/utils/Address.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n"},"node_modules/@openzeppelin/contracts/utils/StorageSlot.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/StorageSlot.sol)\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```solidity\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(newImplementation.code.length > 0);\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}\n"}},"settings":{"remappings":["forge-std/=node_modules/forge-std/src/","account-abstraction/=node_modules/account-abstraction/contracts/","solady/=node_modules/solady/src/","sentinellist/=node_modules/@rhinestone/sentinellist/src/","module-bases/=node_modules/@rhinestone/module-bases/src/","erc7739Validator/=node_modules/@erc7579/erc7739-validator-base/src/","EnumerableSet4337/=node_modules/@erc7579/enumerablemap4337/src/","erc7579/=node_modules/@erc7579/implementation/src/","byteslib/=node_modules/solidity-bytes-utils/contracts/","rlp-reader/=node_modules/solidity-rlp/contracts/","murky-trees/=node_modules/murky/src/","solarray/=node_modules/solarray/src/","excessively-safe-call/=node_modules/excessively-safe-call/src/","@ERC4337/=node_modules/@ERC4337/","@erc7579/=node_modules/@erc7579/","@gnosis.pm/=node_modules/@gnosis.pm/","@openzeppelin/=node_modules/@openzeppelin/","@prb/=node_modules/@prb/","@rhinestone/=node_modules/@rhinestone/","@safe-global/=node_modules/@safe-global/","@zerodev/=node_modules/@zerodev/","account-abstraction-v0.6/=node_modules/account-abstraction-v0.6/","ds-test/=node_modules/ds-test/","hardhat-deploy/=node_modules/hardhat-deploy/","hardhat/=node_modules/hardhat/","solidity-bytes-utils/=node_modules/solidity-bytes-utils/","solidity-rlp/=node_modules/solidity-rlp/"],"optimizer":{"enabled":true,"runs":999},"metadata":{"useLiteralContent":false,"bytecodeHash":"none","appendCBOR":true},"outputSelection":{"*":{"*":["abi","evm.bytecode.object","evm.bytecode.sourceMap","evm.bytecode.linkReferences","evm.deployedBytecode.object","evm.deployedBytecode.sourceMap","evm.deployedBytecode.linkReferences","evm.deployedBytecode.immutableReferences","evm.methodIdentifiers","metadata"]}},"evmVersion":"cancun","viaIR":true,"libraries":{}}}
