{"language":"Solidity","sources":{"contracts/node-pm/NodePaymasterFactory.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\nimport { NodePaymaster } from \"./NodePaymaster.sol\";\nimport { IEntryPoint } from \"account-abstraction/interfaces/IEntryPoint.sol\";\n\n/// @title NodePaymasterFactory\n/// @notice A factory for deploying and funding NodePaymasters\n/// @dev The NodePaymaster is deployed using create2 with a deterministic address\n/// @dev The NodePaymaster is funded with the msg.value\n/// @author Biconomy\ncontract NodePaymasterFactory {\n    /// @notice The error thrown when the NodePaymaster deployment fails\n    error NodePMDeployFailed();\n\n    /// @notice Deploy and fund a new NodePaymaster\n    /// @param entryPoint The 4337 EntryPoint address expected to call the NodePaymaster\n    /// @param owner The owner of the NodePaymaster\n    /// @param workerEoas The worker EOAs of a given node. Only those will be allowed\n    /// to call handleOps\n    /// @param index The deployment index of the NodePaymaster\n    /// @return nodePaymaster The address of the deployed NodePaymaster\n    /// @dev The NodePaymaster is deployed using create2 with a deterministic address\n    /// @dev The NodePaymaster is funded with the msg.value\n    function deployAndFundNodePaymaster(\n        address entryPoint,\n        address owner,\n        address[] calldata workerEoas,\n        uint256 index\n    )\n        public\n        payable\n        returns (address nodePaymaster)\n    {\n        address expectedPm = _predictNodePaymasterAddress(entryPoint, owner, workerEoas, index);\n\n        bytes memory deploymentData =\n            abi.encodePacked(type(NodePaymaster).creationCode, abi.encode(entryPoint, owner, workerEoas));\n\n        assembly {\n            nodePaymaster := create2(0x0, add(0x20, deploymentData), mload(deploymentData), index)\n        }\n\n        if (address(nodePaymaster) == address(0) || address(nodePaymaster) != expectedPm) {\n            revert NodePMDeployFailed();\n        }\n\n        // deposit the msg.value to the EP at the node paymaster's name\n        IEntryPoint(entryPoint).depositTo{ value: msg.value }(nodePaymaster);\n    }\n\n    /// @notice Get the counterfactual address of a NodePaymaster\n    /// @param entryPoint The 4337 EntryPoint address expected to call the NodePaymaster\n    /// @param owner The owner of the NodePaymaster\n    /// @param workerEoas The worker EOAs of a given node. Only those will be allowed\n    /// to call handleOps\n    /// @param index The deployment index of the NodePaymaster\n    /// @return nodePmAddress The counterfactual address of the NodePaymaster\n    function getNodePaymasterAddress(\n        address entryPoint,\n        address owner,\n        address[] calldata workerEoas,\n        uint256 index\n    )\n        public\n        view\n        returns (address nodePmAddress)\n    {\n        nodePmAddress = _predictNodePaymasterAddress(entryPoint, owner, workerEoas, index);\n    }\n\n    /// @notice Function to check if some EOA got PmContract deployed\n    /// @param entryPoint The 4337 EntryPoint address expected to call the NodePaymaster\n    /// @param owner The owner of the NodePaymaster\n    /// @param workerEoas The worker EOAs of a given node. Only those will be allowed\n    /// to call handleOps\n    /// @param index The deployment index of the NodePaymaster\n    /// @return nodePmAddress The predicted address of the NodePaymaster\n    function _predictNodePaymasterAddress(\n        address entryPoint,\n        address owner,\n        address[] calldata workerEoas,\n        uint256 index\n    )\n        internal\n        view\n        returns (address nodePmAddress)\n    {\n        /// forge-lint:disable-start(asm-keccak256)\n        bytes32 initCodeHash =\n            keccak256(abi.encodePacked(type(NodePaymaster).creationCode, abi.encode(entryPoint, owner, workerEoas)));\n        /// forge-lint:disable-end(asm-keccak256)\n\n        // Return the predicted address\n        uint256 predictedAddress;\n        // keccak256(abi.encodePacked(bytes1(0xff), address(this), index, initCodeHash))\n        assembly {\n            let ptr := mload(0x40)\n            mstore8(ptr, 0xff)\n            mstore(add(ptr, 0x01), shl(96, address()))\n            mstore(add(ptr, 0x15), index)\n            mstore(add(ptr, 0x35), initCodeHash)\n            predictedAddress := keccak256(ptr, 0x55)\n        }\n        return payable(address(uint160(predictedAddress)));\n    }\n\n    /// @notice Returns the version of the NodePaymasterFactory\n    /// @return _version version of the NodePaymasterFactory\n    /// @dev adds versioning to the NodePaymasterFactory\n    function version() external pure returns (string memory _version) {\n        _version = \"1.0.1\";\n    }\n}\n"},"contracts/node-pm/NodePaymaster.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\nimport { IEntryPoint } from \"account-abstraction/interfaces/IEntryPoint.sol\";\nimport { PackedUserOperation } from \"account-abstraction/core/UserOperationLib.sol\";\nimport { BaseNodePaymaster } from \"./BaseNodePaymaster.sol\";\n\n/**\n * @title Node Paymaster\n * @notice A paymaster every MEE Node should deploy.\n * @dev Allows handleOps calls by any address allowed by owner().\n * It is used to sponsor userOps. Introduced for gas efficient MEE flow.\n */\ncontract NodePaymaster is BaseNodePaymaster {\n    mapping(address workerEOA => bool isWhitelisted) private _workerEOAs;\n\n    constructor(\n        IEntryPoint _entryPoint,\n        address _meeNodeMasterEOA,\n        address[] memory workerEOAs\n    )\n        payable\n        BaseNodePaymaster(_entryPoint, _meeNodeMasterEOA)\n    {\n        uint256 length = workerEOAs.length;\n        for (uint256 i; i < length; ++i) {\n            _workerEOAs[workerEOAs[i]] = true;\n        }\n    }\n\n    /**\n     * @dev Accepts all userOps\n     * Verifies that the handleOps is called by the MEE Node, so it sponsors only for superTxns by owner MEE Node\n     * @dev The use of tx.origin makes the NodePaymaster incompatible with the general ERC4337 mempool.\n     * This is intentional, and the NodePaymaster is restricted to the MEE node owner anyway.\n     *\n     * PaymasterAndData is encoded as follows:\n     * 20 bytes: Paymaster address\n     * 32 bytes: pm gas values\n     * 4 bytes: mode\n     * 4 bytes: premium mode\n     * 24 bytes: financial data:: premiumPercentage or fixedPremium\n     * 20 bytes: refundReceiver (only for DAPP mode)\n     *\n     * @param userOp the userOp to validate\n     * @param userOpHash the hash of the userOp\n     * @param maxCost the max cost of the userOp\n     * @return context the context to be used in the postOp\n     * @return validationData the validationData to be used in the postOp\n     */\n    function _validatePaymasterUserOp(\n        PackedUserOperation calldata userOp,\n        bytes32 userOpHash,\n        uint256 maxCost\n    )\n        internal\n        virtual\n        override\n        returns (bytes memory context, uint256 validationData)\n    {\n        // solhint-disable-next-line avoid-tx-origin\n        if (tx.origin == owner() || _workerEOAs[tx.origin]) {\n            (context, validationData) = _validate(userOp, userOpHash, maxCost);\n        } else {\n            validationData = 1;\n        }\n    }\n\n    // ====== Manage worker EOAs ======\n\n    /**\n     * @notice Whitelist a worker EOA\n     * @param workerEOA The worker EOA to whitelist\n     */\n    function whitelistWorkerEOA(address workerEOA) external onlyOwner {\n        _workerEOAs[workerEOA] = true;\n    }\n\n    /**\n     * @notice Whitelist a list of worker EOAs\n     * @param workerEOAs The list of worker EOAs to whitelist\n     */\n    function whitelistWorkerEOAs(address[] calldata workerEOAs) external onlyOwner {\n        uint256 length = workerEOAs.length;\n        for (uint256 i; i < length; ++i) {\n            _workerEOAs[workerEOAs[i]] = true;\n        }\n    }\n\n    /**\n     * @notice Remove a worker EOA from the whitelist\n     * @param workerEOA The worker EOA to remove from the whitelist\n     */\n    function removeWorkerEOAFromWhitelist(address workerEOA) external onlyOwner {\n        _workerEOAs[workerEOA] = false;\n    }\n\n    /**\n     * @notice Remove a list of worker EOAs from the whitelist\n     * @param workerEOAs The list of worker EOAs to remove from the whitelist\n     */\n    function removeWorkerEOAsFromWhitelist(address[] calldata workerEOAs) external onlyOwner {\n        uint256 length = workerEOAs.length;\n        for (uint256 i; i < length; ++i) {\n            _workerEOAs[workerEOAs[i]] = false;\n        }\n    }\n\n    /**\n     * @notice Check if a worker EOA is whitelisted\n     * @param workerEOA The worker EOA to check\n     * @return _isWhitelisted True if the worker EOA is whitelisted, false otherwise\n     */\n    function isWorkerEOAWhitelisted(address workerEOA) external view returns (bool _isWhitelisted) {\n        _isWhitelisted = _workerEOAs[workerEOA];\n    }\n\n    /**\n     * @notice Check if a list of worker EOAs are whitelisted\n     * @param workerEOAs The list of worker EOAs to check\n     * @return An array of booleans, where each element corresponds to the whitelist status of the corresponding worker\n     * EOA\n     */\n    /* solhint-disable-next-line gas-named-return-values */\n    function areWorkerEOAsWhitelisted(address[] calldata workerEOAs) external view returns (bool[] memory) {\n        bool[] memory whitelisted = new bool[](workerEOAs.length);\n        uint256 length = workerEOAs.length;\n        for (uint256 i; i < length; ++i) {\n            whitelisted[i] = _workerEOAs[workerEOAs[i]];\n        }\n        return whitelisted;\n    }\n\n    /// @notice Returns the version of the NodePaymaster\n    /// @return _version version of the NodePaymaster\n    /// @dev adds versioning to the NodePaymaster\n    function version() external pure returns (string memory _version) {\n        _version = \"1.0.1\";\n    }\n}\n"},"node_modules/account-abstraction/contracts/interfaces/IEntryPoint.sol":{"content":"/**\n ** Account-Abstraction (EIP-4337) singleton EntryPoint implementation.\n ** Only one instance required on each chain.\n **/\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.5;\n\n/* solhint-disable avoid-low-level-calls */\n/* solhint-disable no-inline-assembly */\n/* solhint-disable reason-string */\n\nimport \"./PackedUserOperation.sol\";\nimport \"./IStakeManager.sol\";\nimport \"./IAggregator.sol\";\nimport \"./INonceManager.sol\";\n\ninterface IEntryPoint is IStakeManager, INonceManager {\n    /***\n     * An event emitted after each successful request.\n     * @param userOpHash    - Unique identifier for the request (hash its entire content, except signature).\n     * @param sender        - The account that generates this request.\n     * @param paymaster     - If non-null, the paymaster that pays for this request.\n     * @param nonce         - The nonce value from the request.\n     * @param success       - True if the sender transaction succeeded, false if reverted.\n     * @param actualGasCost - Actual amount paid (by account or paymaster) for this UserOperation.\n     * @param actualGasUsed - Total gas used by this UserOperation (including preVerification, creation,\n     *                        validation and execution).\n     */\n    event UserOperationEvent(\n        bytes32 indexed userOpHash,\n        address indexed sender,\n        address indexed paymaster,\n        uint256 nonce,\n        bool success,\n        uint256 actualGasCost,\n        uint256 actualGasUsed\n    );\n\n    /**\n     * Account \"sender\" was deployed.\n     * @param userOpHash - The userOp that deployed this account. UserOperationEvent will follow.\n     * @param sender     - The account that is deployed\n     * @param factory    - The factory used to deploy this account (in the initCode)\n     * @param paymaster  - The paymaster used by this UserOp\n     */\n    event AccountDeployed(\n        bytes32 indexed userOpHash,\n        address indexed sender,\n        address factory,\n        address paymaster\n    );\n\n    /**\n     * An event emitted if the UserOperation \"callData\" reverted with non-zero length.\n     * @param userOpHash   - The request unique identifier.\n     * @param sender       - The sender of this request.\n     * @param nonce        - The nonce used in the request.\n     * @param revertReason - The return bytes from the (reverted) call to \"callData\".\n     */\n    event UserOperationRevertReason(\n        bytes32 indexed userOpHash,\n        address indexed sender,\n        uint256 nonce,\n        bytes revertReason\n    );\n\n    /**\n     * An event emitted if the UserOperation Paymaster's \"postOp\" call reverted with non-zero length.\n     * @param userOpHash   - The request unique identifier.\n     * @param sender       - The sender of this request.\n     * @param nonce        - The nonce used in the request.\n     * @param revertReason - The return bytes from the (reverted) call to \"callData\".\n     */\n    event PostOpRevertReason(\n        bytes32 indexed userOpHash,\n        address indexed sender,\n        uint256 nonce,\n        bytes revertReason\n    );\n\n    /**\n     * UserOp consumed more than prefund. The UserOperation is reverted, and no refund is made.\n     * @param userOpHash   - The request unique identifier.\n     * @param sender       - The sender of this request.\n     * @param nonce        - The nonce used in the request.\n     */\n    event UserOperationPrefundTooLow(\n        bytes32 indexed userOpHash,\n        address indexed sender,\n        uint256 nonce\n    );\n\n    /**\n     * An event emitted by handleOps(), before starting the execution loop.\n     * Any event emitted before this event, is part of the validation.\n     */\n    event BeforeExecution();\n\n    /**\n     * Signature aggregator used by the following UserOperationEvents within this bundle.\n     * @param aggregator - The aggregator used for the following UserOperationEvents.\n     */\n    event SignatureAggregatorChanged(address indexed aggregator);\n\n    /**\n     * A custom revert error of handleOps, to identify the offending op.\n     * Should be caught in off-chain handleOps simulation and not happen on-chain.\n     * Useful for mitigating DoS attempts against batchers or for troubleshooting of factory/account/paymaster reverts.\n     * NOTE: If simulateValidation passes successfully, there should be no reason for handleOps to fail on it.\n     * @param opIndex - Index into the array of ops to the failed one (in simulateValidation, this is always zero).\n     * @param reason  - Revert reason. The string starts with a unique code \"AAmn\",\n     *                  where \"m\" is \"1\" for factory, \"2\" for account and \"3\" for paymaster issues,\n     *                  so a failure can be attributed to the correct entity.\n     */\n    error FailedOp(uint256 opIndex, string reason);\n\n    /**\n     * A custom revert error of handleOps, to report a revert by account or paymaster.\n     * @param opIndex - Index into the array of ops to the failed one (in simulateValidation, this is always zero).\n     * @param reason  - Revert reason. see FailedOp(uint256,string), above\n     * @param inner   - data from inner cought revert reason\n     * @dev note that inner is truncated to 2048 bytes\n     */\n    error FailedOpWithRevert(uint256 opIndex, string reason, bytes inner);\n\n    error PostOpReverted(bytes returnData);\n\n    /**\n     * Error case when a signature aggregator fails to verify the aggregated signature it had created.\n     * @param aggregator The aggregator that failed to verify the signature\n     */\n    error SignatureValidationFailed(address aggregator);\n\n    // Return value of getSenderAddress.\n    error SenderAddressResult(address sender);\n\n    // UserOps handled, per aggregator.\n    struct UserOpsPerAggregator {\n        PackedUserOperation[] userOps;\n        // Aggregator address\n        IAggregator aggregator;\n        // Aggregated signature\n        bytes signature;\n    }\n\n    /**\n     * Execute a batch of UserOperations.\n     * No signature aggregator is used.\n     * If any account requires an aggregator (that is, it returned an aggregator when\n     * performing simulateValidation), then handleAggregatedOps() must be used instead.\n     * @param ops         - The operations to execute.\n     * @param beneficiary - The address to receive the fees.\n     */\n    function handleOps(\n        PackedUserOperation[] calldata ops,\n        address payable beneficiary\n    ) external;\n\n    /**\n     * Execute a batch of UserOperation with Aggregators\n     * @param opsPerAggregator - The operations to execute, grouped by aggregator (or address(0) for no-aggregator accounts).\n     * @param beneficiary      - The address to receive the fees.\n     */\n    function handleAggregatedOps(\n        UserOpsPerAggregator[] calldata opsPerAggregator,\n        address payable beneficiary\n    ) external;\n\n    /**\n     * Generate a request Id - unique identifier for this request.\n     * The request ID is a hash over the content of the userOp (except the signature), the entrypoint and the chainid.\n     * @param userOp - The user operation to generate the request ID for.\n     * @return hash the hash of this UserOperation\n     */\n    function getUserOpHash(\n        PackedUserOperation calldata userOp\n    ) external view returns (bytes32);\n\n    /**\n     * Gas and return values during simulation.\n     * @param preOpGas         - The gas used for validation (including preValidationGas)\n     * @param prefund          - The required prefund for this operation\n     * @param accountValidationData   - returned validationData from account.\n     * @param paymasterValidationData - return validationData from paymaster.\n     * @param paymasterContext - Returned by validatePaymasterUserOp (to be passed into postOp)\n     */\n    struct ReturnInfo {\n        uint256 preOpGas;\n        uint256 prefund;\n        uint256 accountValidationData;\n        uint256 paymasterValidationData;\n        bytes paymasterContext;\n    }\n\n    /**\n     * Returned aggregated signature info:\n     * The aggregator returned by the account, and its current stake.\n     */\n    struct AggregatorStakeInfo {\n        address aggregator;\n        StakeInfo stakeInfo;\n    }\n\n    /**\n     * Get counterfactual sender address.\n     * Calculate the sender contract address that will be generated by the initCode and salt in the UserOperation.\n     * This method always revert, and returns the address in SenderAddressResult error\n     * @param initCode - The constructor code to be passed into the UserOperation.\n     */\n    function getSenderAddress(bytes memory initCode) external;\n\n    error DelegateAndRevert(bool success, bytes ret);\n\n    /**\n     * Helper method for dry-run testing.\n     * @dev calling this method, the EntryPoint will make a delegatecall to the given data, and report (via revert) the result.\n     *  The method always revert, so is only useful off-chain for dry run calls, in cases where state-override to replace\n     *  actual EntryPoint code is less convenient.\n     * @param target a target contract to make a delegatecall from entrypoint\n     * @param data data to pass to target in a delegatecall\n     */\n    function delegateAndRevert(address target, bytes calldata data) external;\n}\n"},"node_modules/account-abstraction/contracts/core/UserOperationLib.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.23;\n\n/* solhint-disable no-inline-assembly */\n\nimport \"../interfaces/PackedUserOperation.sol\";\nimport {calldataKeccak, min} from \"./Helpers.sol\";\n\n/**\n * Utility functions helpful when working with UserOperation structs.\n */\nlibrary UserOperationLib {\n\n    uint256 public constant PAYMASTER_VALIDATION_GAS_OFFSET = 20;\n    uint256 public constant PAYMASTER_POSTOP_GAS_OFFSET = 36;\n    uint256 public constant PAYMASTER_DATA_OFFSET = 52;\n    /**\n     * Get sender from user operation data.\n     * @param userOp - The user operation data.\n     */\n    function getSender(\n        PackedUserOperation calldata userOp\n    ) internal pure returns (address) {\n        address data;\n        //read sender from userOp, which is first userOp member (saves 800 gas...)\n        assembly {\n            data := calldataload(userOp)\n        }\n        return address(uint160(data));\n    }\n\n    /**\n     * Relayer/block builder might submit the TX with higher priorityFee,\n     * but the user should not pay above what he signed for.\n     * @param userOp - The user operation data.\n     */\n    function gasPrice(\n        PackedUserOperation calldata userOp\n    ) internal view returns (uint256) {\n        unchecked {\n            (uint256 maxPriorityFeePerGas, uint256 maxFeePerGas) = unpackUints(userOp.gasFees);\n            if (maxFeePerGas == maxPriorityFeePerGas) {\n                //legacy mode (for networks that don't support basefee opcode)\n                return maxFeePerGas;\n            }\n            return min(maxFeePerGas, maxPriorityFeePerGas + block.basefee);\n        }\n    }\n\n    /**\n     * Pack the user operation data into bytes for hashing.\n     * @param userOp - The user operation data.\n     */\n    function encode(\n        PackedUserOperation calldata userOp\n    ) internal pure returns (bytes memory ret) {\n        address sender = getSender(userOp);\n        uint256 nonce = userOp.nonce;\n        bytes32 hashInitCode = calldataKeccak(userOp.initCode);\n        bytes32 hashCallData = calldataKeccak(userOp.callData);\n        bytes32 accountGasLimits = userOp.accountGasLimits;\n        uint256 preVerificationGas = userOp.preVerificationGas;\n        bytes32 gasFees = userOp.gasFees;\n        bytes32 hashPaymasterAndData = calldataKeccak(userOp.paymasterAndData);\n\n        return abi.encode(\n            sender, nonce,\n            hashInitCode, hashCallData,\n            accountGasLimits, preVerificationGas, gasFees,\n            hashPaymasterAndData\n        );\n    }\n\n    function unpackUints(\n        bytes32 packed\n    ) internal pure returns (uint256 high128, uint256 low128) {\n        return (uint128(bytes16(packed)), uint128(uint256(packed)));\n    }\n\n    //unpack just the high 128-bits from a packed value\n    function unpackHigh128(bytes32 packed) internal pure returns (uint256) {\n        return uint256(packed) >> 128;\n    }\n\n    // unpack just the low 128-bits from a packed value\n    function unpackLow128(bytes32 packed) internal pure returns (uint256) {\n        return uint128(uint256(packed));\n    }\n\n    function unpackMaxPriorityFeePerGas(PackedUserOperation calldata userOp)\n    internal pure returns (uint256) {\n        return unpackHigh128(userOp.gasFees);\n    }\n\n    function unpackMaxFeePerGas(PackedUserOperation calldata userOp)\n    internal pure returns (uint256) {\n        return unpackLow128(userOp.gasFees);\n    }\n\n    function unpackVerificationGasLimit(PackedUserOperation calldata userOp)\n    internal pure returns (uint256) {\n        return unpackHigh128(userOp.accountGasLimits);\n    }\n\n    function unpackCallGasLimit(PackedUserOperation calldata userOp)\n    internal pure returns (uint256) {\n        return unpackLow128(userOp.accountGasLimits);\n    }\n\n    function unpackPaymasterVerificationGasLimit(PackedUserOperation calldata userOp)\n    internal pure returns (uint256) {\n        return uint128(bytes16(userOp.paymasterAndData[PAYMASTER_VALIDATION_GAS_OFFSET : PAYMASTER_POSTOP_GAS_OFFSET]));\n    }\n\n    function unpackPostOpGasLimit(PackedUserOperation calldata userOp)\n    internal pure returns (uint256) {\n        return uint128(bytes16(userOp.paymasterAndData[PAYMASTER_POSTOP_GAS_OFFSET : PAYMASTER_DATA_OFFSET]));\n    }\n\n    function unpackPaymasterStaticFields(\n        bytes calldata paymasterAndData\n    ) internal pure returns (address paymaster, uint256 validationGasLimit, uint256 postOpGasLimit) {\n        return (\n            address(bytes20(paymasterAndData[: PAYMASTER_VALIDATION_GAS_OFFSET])),\n            uint128(bytes16(paymasterAndData[PAYMASTER_VALIDATION_GAS_OFFSET : PAYMASTER_POSTOP_GAS_OFFSET])),\n            uint128(bytes16(paymasterAndData[PAYMASTER_POSTOP_GAS_OFFSET : PAYMASTER_DATA_OFFSET]))\n        );\n    }\n\n    /**\n     * Hash the user operation data.\n     * @param userOp - The user operation data.\n     */\n    function hash(\n        PackedUserOperation calldata userOp\n    ) internal pure returns (bytes32) {\n        return keccak256(encode(userOp));\n    }\n}\n"},"contracts/node-pm/BaseNodePaymaster.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\nimport { BasePaymaster } from \"account-abstraction/core/BasePaymaster.sol\";\nimport { IEntryPoint } from \"account-abstraction/interfaces/IEntryPoint.sol\";\nimport { UserOperationLib } from \"account-abstraction/core/UserOperationLib.sol\";\nimport { PackedUserOperation } from \"account-abstraction/core/UserOperationLib.sol\";\nimport {\n    NODE_PM_MODE_USER,\n    NODE_PM_MODE_DAPP,\n    NODE_PM_MODE_KEEP,\n    NODE_PM_PREMIUM_PERCENT,\n    NODE_PM_PREMIUM_FIXED\n} from \"../types/Constants.sol\";\n\n/**\n * @title BaseNode Paymaster\n * @notice Base PM functionality for MEE Node PMs.\n * It is used to sponsor userOps. Introduced for gas efficient MEE flow.\n */\nabstract contract BaseNodePaymaster is BasePaymaster {\n    error InvalidNodePMRefundMode(bytes4 mode);\n    error InvalidNodePMPremiumMode(bytes4 mode);\n    error InvalidContext(uint256 length);\n\n    using UserOperationLib for PackedUserOperation;\n    using UserOperationLib for bytes32;\n\n    // 100% with 5 decimals precision\n    uint256 private constant _PREMIUM_CALCULATION_BASE = 10_000_000;\n\n    error EmptyMessageValue();\n    error InsufficientBalance();\n    error PaymasterVerificationGasLimitTooHigh();\n    error Disabled();\n    error PostOpGasLimitTooLow();\n\n    constructor(IEntryPoint _entryPoint, address _meeNodeMasterEOA) payable BasePaymaster(_entryPoint) {\n        _transferOwnership(_meeNodeMasterEOA);\n    }\n\n    /**\n     * @dev Accepts all userOps\n     * Verifies that the handleOps is called by the MEE Node, so it sponsors only for superTxns by owner MEE Node\n     * @dev The use of tx.origin makes the NodePaymaster incompatible with the general ERC4337 mempool.\n     * This is intentional, and the NodePaymaster is restricted to the MEE node owner anyway.\n     *\n     * PaymasterAndData is encoded as follows:\n     * 20 bytes: Paymaster address\n     * 32 bytes: pm gas values\n     * === PM_DATA_START ===\n     * 4 bytes: mode\n     * 4 bytes: premium mode\n     * 24 bytes: financial data:: premiumPercentage (only for according premium mode)\n     * 20 bytes: refundReceiver (only for DAPP refund mode)\n     *\n     * @param userOp the userOp to validate\n     * param userOpHash the hash of the userOp\n     * @param maxCost the max cost of the userOp\n     * @return context the context to be used in the postOp\n     * @return validationData the validationData to be used in the postOp\n     */\n    // solhint-disable-next-line gas-named-return-values\n    function _validate(\n        PackedUserOperation calldata userOp,\n        bytes32, /*userOpHash*/\n        uint256 maxCost\n    )\n        internal\n        virtual\n        returns (bytes memory, uint256)\n    {\n        bytes4 refundMode;\n        bytes4 premiumMode;\n        bytes calldata pmAndData = userOp.paymasterAndData;\n        assembly {\n            // 0x34 = 52 => PAYMASTER_DATA_OFFSET\n            refundMode := calldataload(add(pmAndData.offset, 0x34))\n        }\n\n        address refundReceiver;\n        // Handle refund mode\n        if (refundMode == NODE_PM_MODE_KEEP) {\n            // NO REFUND\n            return (\"\", 0);\n        } else {\n            assembly {\n                // 0x38 = 56 => PAYMASTER_DATA_OFFSET + 4\n                premiumMode := calldataload(add(pmAndData.offset, 0x38))\n            }\n            if (refundMode == NODE_PM_MODE_USER) {\n                refundReceiver = userOp.sender;\n            } else if (refundMode == NODE_PM_MODE_DAPP) {\n                // if fixed premium => no financial data => offset is 0x08\n                // if % premium => financial data => offset is 0x08 + 0x18 = 0x20\n                uint256 refundReceiverOffset = premiumMode == NODE_PM_PREMIUM_FIXED ? 0x08 : 0x20;\n                assembly {\n                    let o := add(0x34, refundReceiverOffset)\n                    refundReceiver := shr(96, calldataload(add(pmAndData.offset, o)))\n                }\n            } else {\n                revert InvalidNodePMRefundMode(refundMode);\n            }\n        }\n\n        bytes memory context = _prepareContext({\n            refundReceiver: refundReceiver,\n            premiumMode: premiumMode,\n            maxCost: maxCost,\n            postOpGasLimit: userOp.unpackPostOpGasLimit(),\n            paymasterAndData: userOp.paymasterAndData\n        });\n\n        return (context, 0);\n    }\n\n    /**\n     * Post-operation handler.\n     * Checks mode and refunds the userOp.sender if needed.\n     * param PostOpMode enum with the following options: // not used\n     *      opSucceeded - user operation succeeded.\n     *      opReverted  - user op reverted. still has to pay for gas.\n     *      postOpReverted - user op succeeded, but caused postOp (in mode=opSucceeded) to revert.\n     *                       Now this is the 2nd call, after user's op was deliberately reverted.\n     * @dev postOpGasLimit is very important parameter that Node SHOULD use to balance its economic interests\n     *         since penalty is not involved with refunds to sponsor here,\n     *         postOpGasLimit should account for gas that is spend by AA-EP after benchmarking actualGasSpent\n     *         if it is too low (still enough for _postOp), nodePM will be underpaid\n     *         if it is too high, nodePM will be overcharging the superTxn sponsor as refund is going to be lower\n     * @param context - the context value returned by validatePaymasterUserOp\n     * context is encoded as follows:\n     * if mode is KEEP:\n     * 0 bytes\n     * ==== if there is a refund, always add ===\n     * 20 bytes: refundReceiver\n     * >== if % premium mode also add ===\n     * 24 bytes: financial data:: premiumPercentage\n     * 32 bytes: maxGasCost\n     * 32 bytes: postOpGasLimit\n     *        (108 bytes total)\n     * >== if fixed premium ====\n     * 32 bytes: maxGasCost\n     * 32 bytes: postOpGasLimit\n     *        (84 bytes total)\n     * @param actualGasCost - actual gas used so far (without this postOp call).\n     * @param actualUserOpFeePerGas - actual userOp fee per gas\n     */\n    function _postOp(\n        PostOpMode,\n        bytes calldata context,\n        uint256 actualGasCost,\n        uint256 actualUserOpFeePerGas\n    )\n        internal\n        virtual\n        override\n    {\n        uint256 refund;\n        address refundReceiver;\n\n        // Prepare refund info if any\n        if (context.length == 0x00) {  // 0 bytes => KEEP mode => NO REFUND\n        // do nothing\n        } else if (context.length == 0x54) {\n            // 84 bytes => REFUND: fixed premium mode.\n            (refundReceiver, refund) = _handleFixedPremium(context, actualGasCost, actualUserOpFeePerGas);\n        } else if (context.length == 0x6c) {\n            // 108 bytes => REFUND: % premium mode.\n            (refundReceiver, refund) = _handlePercentagePremium(context, actualGasCost, actualUserOpFeePerGas);\n        } else {\n            revert InvalidContext(context.length);\n        }\n\n        // send refund to the superTxn sponsor\n        if (refund > 0) {\n            // Note: At this point the paymaster hasn't received the refund yet, so this withdrawTo() is\n            // using the paymaster's existing balance. The paymaster's deposit in the entrypoint will be\n            // incremented after postOp() concludes.\n            entryPoint.withdrawTo(payable(refundReceiver), refund);\n        }\n    }\n\n    // ==== Helper functions ====\n\n    function _prepareContext(\n        address refundReceiver,\n        bytes4 premiumMode,\n        uint256 maxCost,\n        uint256 postOpGasLimit,\n        bytes calldata paymasterAndData\n    )\n        internal\n        pure\n        returns (bytes memory context)\n    {\n        context = abi.encodePacked(refundReceiver);\n\n        if (premiumMode == NODE_PM_PREMIUM_PERCENT) {\n            uint192 premiumPercentage;\n            // 0x3c = 60 => PAYMASTER_DATA_OFFSET + 8\n            assembly {\n                premiumPercentage := shr(64, calldataload(add(paymasterAndData.offset, 0x3c)))\n            }\n            context = abi.encodePacked(context, premiumPercentage, maxCost, postOpGasLimit); // 108 bytes\n        } else if (premiumMode == NODE_PM_PREMIUM_FIXED) {\n            context = abi.encodePacked(context, maxCost, postOpGasLimit); // 84 bytes\n        } else {\n            revert InvalidNodePMPremiumMode(premiumMode);\n        }\n    }\n\n    function _handleFixedPremium(\n        bytes calldata context,\n        uint256 actualGasCost,\n        uint256 actualUserOpFeePerGas\n    )\n        internal\n        pure\n        returns (address refundReceiver, uint256 refund)\n    {\n        uint256 maxGasCost;\n        uint256 postOpGasLimit;\n\n        assembly {\n            refundReceiver := shr(96, calldataload(context.offset))\n            maxGasCost := calldataload(add(context.offset, 0x14))\n            postOpGasLimit := calldataload(add(context.offset, 0x34))\n        }\n\n        // account for postOpGas\n        actualGasCost += postOpGasLimit * actualUserOpFeePerGas;\n\n        // when premium is fixed, payment by superTxn sponsor is maxGasCost + fixedPremium\n        // so we refund just the gas difference, while fixedPremium is going to the MEE Node\n        if (actualGasCost < maxGasCost) {\n            refund = maxGasCost - actualGasCost;\n        }\n    }\n\n    function _handlePercentagePremium(\n        bytes calldata context,\n        uint256 actualGasCost,\n        uint256 actualUserOpFeePerGas\n    )\n        internal\n        pure\n        returns (address refundReceiver, uint256 refund)\n    {\n        uint192 premiumPercentage;\n        uint256 maxGasCost;\n        uint256 postOpGasLimit;\n\n        assembly {\n            refundReceiver := shr(96, calldataload(context.offset))\n            premiumPercentage := shr(64, calldataload(add(context.offset, 0x14)))\n            maxGasCost := calldataload(add(context.offset, 0x2c))\n            postOpGasLimit := calldataload(add(context.offset, 0x4c))\n        }\n\n        // account for postOpGas\n        actualGasCost += postOpGasLimit * actualUserOpFeePerGas;\n\n        // we do not need to account for the penalty here because it goes to the beneficiary\n        // which is the MEE Node itself, so we do not have to charge user for the penalty\n\n        // account for MEE Node premium\n        uint256 costWithPremium = _applyPercentagePremium(actualGasCost, premiumPercentage);\n\n        // as MEE_NODE charges user with the premium\n        uint256 maxCostWithPremium = _applyPercentagePremium(maxGasCost, premiumPercentage);\n\n        // We do not check for the case, when costWithPremium > maxCost\n        // maxCost charged by the MEE Node should include the premium\n        // if this is done, costWithPremium can never be > maxCost\n        if (costWithPremium < maxCostWithPremium) {\n            refund = maxCostWithPremium - costWithPremium;\n        }\n    }\n\n    function _applyPercentagePremium(uint256 amount, uint256 premiumPercentage) internal pure returns (uint256 result) {\n        result = amount * (_PREMIUM_CALCULATION_BASE + premiumPercentage) / _PREMIUM_CALCULATION_BASE;\n    }\n\n    /// @dev This function is used to receive ETH from the user and immediately deposit it to the entryPoint\n    receive() external payable {\n        entryPoint.depositTo{ value: msg.value }(address(this));\n    }\n}\n"},"node_modules/account-abstraction/contracts/interfaces/PackedUserOperation.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.5;\n\n/**\n * User Operation struct\n * @param sender                - The sender account of this request.\n * @param nonce                 - Unique value the sender uses to verify it is not a replay.\n * @param initCode              - If set, the account contract will be created by this constructor/\n * @param callData              - The method call to execute on this account.\n * @param accountGasLimits      - Packed gas limits for validateUserOp and gas limit passed to the callData method call.\n * @param preVerificationGas    - Gas not calculated by the handleOps method, but added to the gas paid.\n *                                Covers batch overhead.\n * @param gasFees               - packed gas fields maxPriorityFeePerGas and maxFeePerGas - Same as EIP-1559 gas parameters.\n * @param paymasterAndData      - If set, this field holds the paymaster address, verification gas limit, postOp gas limit and paymaster-specific extra data\n *                                The paymaster will pay for the transaction instead of the sender.\n * @param signature             - Sender-verified signature over the entire request, the EntryPoint address and the chain ID.\n */\nstruct PackedUserOperation {\n    address sender;\n    uint256 nonce;\n    bytes initCode;\n    bytes callData;\n    bytes32 accountGasLimits;\n    uint256 preVerificationGas;\n    bytes32 gasFees;\n    bytes paymasterAndData;\n    bytes signature;\n}\n"},"node_modules/account-abstraction/contracts/interfaces/IStakeManager.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >=0.7.5;\n\n/**\n * Manage deposits and stakes.\n * Deposit is just a balance used to pay for UserOperations (either by a paymaster or an account).\n * Stake is value locked for at least \"unstakeDelay\" by the staked entity.\n */\ninterface IStakeManager {\n    event Deposited(address indexed account, uint256 totalDeposit);\n\n    event Withdrawn(\n        address indexed account,\n        address withdrawAddress,\n        uint256 amount\n    );\n\n    // Emitted when stake or unstake delay are modified.\n    event StakeLocked(\n        address indexed account,\n        uint256 totalStaked,\n        uint256 unstakeDelaySec\n    );\n\n    // Emitted once a stake is scheduled for withdrawal.\n    event StakeUnlocked(address indexed account, uint256 withdrawTime);\n\n    event StakeWithdrawn(\n        address indexed account,\n        address withdrawAddress,\n        uint256 amount\n    );\n\n    /**\n     * @param deposit         - The entity's deposit.\n     * @param staked          - True if this entity is staked.\n     * @param stake           - Actual amount of ether staked for this entity.\n     * @param unstakeDelaySec - Minimum delay to withdraw the stake.\n     * @param withdrawTime    - First block timestamp where 'withdrawStake' will be callable, or zero if already locked.\n     * @dev Sizes were chosen so that deposit fits into one cell (used during handleOp)\n     *      and the rest fit into a 2nd cell (used during stake/unstake)\n     *      - 112 bit allows for 10^15 eth\n     *      - 48 bit for full timestamp\n     *      - 32 bit allows 150 years for unstake delay\n     */\n    struct DepositInfo {\n        uint256 deposit;\n        bool staked;\n        uint112 stake;\n        uint32 unstakeDelaySec;\n        uint48 withdrawTime;\n    }\n\n    // API struct used by getStakeInfo and simulateValidation.\n    struct StakeInfo {\n        uint256 stake;\n        uint256 unstakeDelaySec;\n    }\n\n    /**\n     * Get deposit info.\n     * @param account - The account to query.\n     * @return info   - Full deposit information of given account.\n     */\n    function getDepositInfo(\n        address account\n    ) external view returns (DepositInfo memory info);\n\n    /**\n     * Get account balance.\n     * @param account - The account to query.\n     * @return        - The deposit (for gas payment) of the account.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * Add to the deposit of the given account.\n     * @param account - The account to add to.\n     */\n    function depositTo(address account) external payable;\n\n    /**\n     * Add to the account's stake - amount and delay\n     * any pending unstake is first cancelled.\n     * @param _unstakeDelaySec - The new lock duration before the deposit can be withdrawn.\n     */\n    function addStake(uint32 _unstakeDelaySec) external payable;\n\n    /**\n     * Attempt to unlock the stake.\n     * The value can be withdrawn (using withdrawStake) after the unstake delay.\n     */\n    function unlockStake() external;\n\n    /**\n     * Withdraw from the (unlocked) stake.\n     * Must first call unlockStake and wait for the unstakeDelay to pass.\n     * @param withdrawAddress - The address to send withdrawn value.\n     */\n    function withdrawStake(address payable withdrawAddress) external;\n\n    /**\n     * Withdraw from the deposit.\n     * @param withdrawAddress - The address to send withdrawn value.\n     * @param withdrawAmount  - The amount to withdraw.\n     */\n    function withdrawTo(\n        address payable withdrawAddress,\n        uint256 withdrawAmount\n    ) external;\n}\n"},"node_modules/account-abstraction/contracts/interfaces/IAggregator.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.5;\n\nimport \"./PackedUserOperation.sol\";\n\n/**\n * Aggregated Signatures validator.\n */\ninterface IAggregator {\n    /**\n     * Validate aggregated signature.\n     * Revert if the aggregated signature does not match the given list of operations.\n     * @param userOps   - Array of UserOperations to validate the signature for.\n     * @param signature - The aggregated signature.\n     */\n    function validateSignatures(\n        PackedUserOperation[] calldata userOps,\n        bytes calldata signature\n    ) external view;\n\n    /**\n     * Validate signature of a single userOp.\n     * This method should be called by bundler after EntryPointSimulation.simulateValidation() returns\n     * the aggregator this account uses.\n     * First it validates the signature over the userOp. Then it returns data to be used when creating the handleOps.\n     * @param userOp        - The userOperation received from the user.\n     * @return sigForUserOp - The value to put into the signature field of the userOp when calling handleOps.\n     *                        (usually empty, unless account and aggregator support some kind of \"multisig\".\n     */\n    function validateUserOpSignature(\n        PackedUserOperation calldata userOp\n    ) external view returns (bytes memory sigForUserOp);\n\n    /**\n     * Aggregate multiple signatures into a single value.\n     * This method is called off-chain to calculate the signature to pass with handleOps()\n     * bundler MAY use optimized custom code perform this aggregation.\n     * @param userOps              - Array of UserOperations to collect the signatures from.\n     * @return aggregatedSignature - The aggregated signature.\n     */\n    function aggregateSignatures(\n        PackedUserOperation[] calldata userOps\n    ) external view returns (bytes memory aggregatedSignature);\n}\n"},"node_modules/account-abstraction/contracts/interfaces/INonceManager.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.5;\n\ninterface INonceManager {\n\n    /**\n     * Return the next nonce for this sender.\n     * Within a given key, the nonce values are sequenced (starting with zero, and incremented by one on each userop)\n     * But UserOp with different keys can come with arbitrary order.\n     *\n     * @param sender the account address\n     * @param key the high 192 bit of the nonce\n     * @return nonce a full nonce to pass for next UserOp with this sender.\n     */\n    function getNonce(address sender, uint192 key)\n    external view returns (uint256 nonce);\n\n    /**\n     * Manually increment the nonce of the sender.\n     * This method is exposed just for completeness..\n     * Account does NOT need to call it, neither during validation, nor elsewhere,\n     * as the EntryPoint will update the nonce regardless.\n     * Possible use-case is call it with various keys to \"initialize\" their nonces to one, so that future\n     * UserOperations will not pay extra for the first transaction with a given key.\n     */\n    function incrementNonce(uint192 key) external;\n}\n"},"node_modules/account-abstraction/contracts/core/Helpers.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.23;\n\n/* solhint-disable no-inline-assembly */\n\n\n /*\n  * For simulation purposes, validateUserOp (and validatePaymasterUserOp)\n  * must return this value in case of signature failure, instead of revert.\n  */\nuint256 constant SIG_VALIDATION_FAILED = 1;\n\n\n/*\n * For simulation purposes, validateUserOp (and validatePaymasterUserOp)\n * return this value on success.\n */\nuint256 constant SIG_VALIDATION_SUCCESS = 0;\n\n\n/**\n * Returned data from validateUserOp.\n * validateUserOp returns a uint256, which is created by `_packedValidationData` and\n * parsed by `_parseValidationData`.\n * @param aggregator  - address(0) - The account validated the signature by itself.\n *                      address(1) - The account failed to validate the signature.\n *                      otherwise - This is an address of a signature aggregator that must\n *                                  be used to validate the signature.\n * @param validAfter  - This UserOp is valid only after this timestamp.\n * @param validaUntil - This UserOp is valid only up to this timestamp.\n */\nstruct ValidationData {\n    address aggregator;\n    uint48 validAfter;\n    uint48 validUntil;\n}\n\n/**\n * Extract sigFailed, validAfter, validUntil.\n * Also convert zero validUntil to type(uint48).max.\n * @param validationData - The packed validation data.\n */\nfunction _parseValidationData(\n    uint256 validationData\n) pure returns (ValidationData memory data) {\n    address aggregator = address(uint160(validationData));\n    uint48 validUntil = uint48(validationData >> 160);\n    if (validUntil == 0) {\n        validUntil = type(uint48).max;\n    }\n    uint48 validAfter = uint48(validationData >> (48 + 160));\n    return ValidationData(aggregator, validAfter, validUntil);\n}\n\n/**\n * Helper to pack the return value for validateUserOp.\n * @param data - The ValidationData to pack.\n */\nfunction _packValidationData(\n    ValidationData memory data\n) pure returns (uint256) {\n    return\n        uint160(data.aggregator) |\n        (uint256(data.validUntil) << 160) |\n        (uint256(data.validAfter) << (160 + 48));\n}\n\n/**\n * Helper to pack the return value for validateUserOp, when not using an aggregator.\n * @param sigFailed  - True for signature failure, false for success.\n * @param validUntil - Last timestamp this UserOperation is valid (or zero for infinite).\n * @param validAfter - First timestamp this UserOperation is valid.\n */\nfunction _packValidationData(\n    bool sigFailed,\n    uint48 validUntil,\n    uint48 validAfter\n) pure returns (uint256) {\n    return\n        (sigFailed ? 1 : 0) |\n        (uint256(validUntil) << 160) |\n        (uint256(validAfter) << (160 + 48));\n}\n\n/**\n * keccak function over calldata.\n * @dev copy calldata into memory, do keccak and drop allocated memory. Strangely, this is more efficient than letting solidity do it.\n */\n    function calldataKeccak(bytes calldata data) pure returns (bytes32 ret) {\n        assembly (\"memory-safe\") {\n            let mem := mload(0x40)\n            let len := data.length\n            calldatacopy(mem, data.offset, len)\n            ret := keccak256(mem, len)\n        }\n    }\n\n\n/**\n * The minimum of two numbers.\n * @param a - First number.\n * @param b - Second number.\n */\n    function min(uint256 a, uint256 b) pure returns (uint256) {\n        return a < b ? a : b;\n    }\n"},"node_modules/account-abstraction/contracts/core/BasePaymaster.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.23;\n\n/* solhint-disable reason-string */\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport \"../interfaces/IPaymaster.sol\";\nimport \"../interfaces/IEntryPoint.sol\";\nimport \"./UserOperationLib.sol\";\n/**\n * Helper class for creating a paymaster.\n * provides helper methods for staking.\n * Validates that the postOp is called only by the entryPoint.\n */\nabstract contract BasePaymaster is IPaymaster, Ownable {\n    IEntryPoint public immutable entryPoint;\n\n    uint256 internal constant PAYMASTER_VALIDATION_GAS_OFFSET = UserOperationLib.PAYMASTER_VALIDATION_GAS_OFFSET;\n    uint256 internal constant PAYMASTER_POSTOP_GAS_OFFSET = UserOperationLib.PAYMASTER_POSTOP_GAS_OFFSET;\n    uint256 internal constant PAYMASTER_DATA_OFFSET = UserOperationLib.PAYMASTER_DATA_OFFSET;\n\n    constructor(IEntryPoint _entryPoint) Ownable(msg.sender) {\n        _validateEntryPointInterface(_entryPoint);\n        entryPoint = _entryPoint;\n    }\n\n    //sanity check: make sure this EntryPoint was compiled against the same\n    // IEntryPoint of this paymaster\n    function _validateEntryPointInterface(IEntryPoint _entryPoint) internal virtual {\n        require(IERC165(address(_entryPoint)).supportsInterface(type(IEntryPoint).interfaceId), \"IEntryPoint interface mismatch\");\n    }\n\n    /// @inheritdoc IPaymaster\n    function validatePaymasterUserOp(\n        PackedUserOperation calldata userOp,\n        bytes32 userOpHash,\n        uint256 maxCost\n    ) external override returns (bytes memory context, uint256 validationData) {\n        _requireFromEntryPoint();\n        return _validatePaymasterUserOp(userOp, userOpHash, maxCost);\n    }\n\n    /**\n     * Validate a user operation.\n     * @param userOp     - The user operation.\n     * @param userOpHash - The hash of the user operation.\n     * @param maxCost    - The maximum cost of the user operation.\n     */\n    function _validatePaymasterUserOp(\n        PackedUserOperation calldata userOp,\n        bytes32 userOpHash,\n        uint256 maxCost\n    ) internal virtual returns (bytes memory context, uint256 validationData);\n\n    /// @inheritdoc IPaymaster\n    function postOp(\n        PostOpMode mode,\n        bytes calldata context,\n        uint256 actualGasCost,\n        uint256 actualUserOpFeePerGas\n    ) external override {\n        _requireFromEntryPoint();\n        _postOp(mode, context, actualGasCost, actualUserOpFeePerGas);\n    }\n\n    /**\n     * Post-operation handler.\n     * (verified to be called only through the entryPoint)\n     * @dev If subclass returns a non-empty context from validatePaymasterUserOp,\n     *      it must also implement this method.\n     * @param mode          - Enum with the following options:\n     *                        opSucceeded - User operation succeeded.\n     *                        opReverted  - User op reverted. The paymaster still has to pay for gas.\n     *                        postOpReverted - never passed in a call to postOp().\n     * @param context       - The context value returned by validatePaymasterUserOp\n     * @param actualGasCost - Actual gas used so far (without this postOp call).\n     * @param actualUserOpFeePerGas - the gas price this UserOp pays. This value is based on the UserOp's maxFeePerGas\n     *                        and maxPriorityFee (and basefee)\n     *                        It is not the same as tx.gasprice, which is what the bundler pays.\n     */\n    function _postOp(\n        PostOpMode mode,\n        bytes calldata context,\n        uint256 actualGasCost,\n        uint256 actualUserOpFeePerGas\n    ) internal virtual {\n        (mode, context, actualGasCost, actualUserOpFeePerGas); // unused params\n        // subclass must override this method if validatePaymasterUserOp returns a context\n        revert(\"must override\");\n    }\n\n    /**\n     * Add a deposit for this paymaster, used for paying for transaction fees.\n     */\n    function deposit() public payable {\n        entryPoint.depositTo{value: msg.value}(address(this));\n    }\n\n    /**\n     * Withdraw value from the deposit.\n     * @param withdrawAddress - Target to send to.\n     * @param amount          - Amount to withdraw.\n     */\n    function withdrawTo(\n        address payable withdrawAddress,\n        uint256 amount\n    ) public onlyOwner {\n        entryPoint.withdrawTo(withdrawAddress, amount);\n    }\n\n    /**\n     * Add stake for this paymaster.\n     * This method can also carry eth value to add to the current stake.\n     * @param unstakeDelaySec - The unstake delay for this paymaster. Can only be increased.\n     */\n    function addStake(uint32 unstakeDelaySec) external payable onlyOwner {\n        entryPoint.addStake{value: msg.value}(unstakeDelaySec);\n    }\n\n    /**\n     * Return current paymaster's deposit on the entryPoint.\n     */\n    function getDeposit() public view returns (uint256) {\n        return entryPoint.balanceOf(address(this));\n    }\n\n    /**\n     * Unlock the stake, in order to withdraw it.\n     * The paymaster can't serve requests once unlocked, until it calls addStake again\n     */\n    function unlockStake() external onlyOwner {\n        entryPoint.unlockStake();\n    }\n\n    /**\n     * Withdraw the entire paymaster's stake.\n     * stake must be unlocked first (and then wait for the unstakeDelay to be over)\n     * @param withdrawAddress - The address to send withdrawn value.\n     */\n    function withdrawStake(address payable withdrawAddress) external onlyOwner {\n        entryPoint.withdrawStake(withdrawAddress);\n    }\n\n    /**\n     * Validate the call is made from a valid entrypoint\n     */\n    function _requireFromEntryPoint() internal virtual {\n        require(msg.sender == address(entryPoint), \"Sender not EntryPoint\");\n    }\n}\n"},"contracts/types/Constants.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\n// STX Sig types\nbytes3 constant SIG_TYPE_MEE_FLOW = 0x177eee;\n\nbytes4 constant SIG_TYPE_SIMPLE = 0x177eee00;\nbytes4 constant SIG_TYPE_ON_CHAIN = 0x177eee01;\nbytes4 constant SIG_TYPE_ERC20_PERMIT = 0x177eee02;\n// ...other sig types: ERC-7683, Permit2, etc\n\n// EIP-1271 constants\nbytes4 constant ERC1271_SUCCESS = 0x1626ba7e;\nbytes4 constant ERC1271_FAILED = 0xffffffff;\n\n// Node PM constants\nbytes4 constant NODE_PM_MODE_USER = 0x170de000; // refund goes to the user\nbytes4 constant NODE_PM_MODE_DAPP = 0x170de001; // refund goes to the dApp\nbytes4 constant NODE_PM_MODE_KEEP = 0x170de002; // no refund as node sponsored\n\nbytes4 constant NODE_PM_PREMIUM_PERCENT = 0x9ee4ce00; // premium percentage\nbytes4 constant NODE_PM_PREMIUM_FIXED = 0x9ee4ce01;\n\n// ERC-4337 validation constants\nuint256 constant VALIDATION_SUCCESS = 0;\nuint256 constant VALIDATION_FAILED = 1;\n\n// Module type identifiers\nuint256 constant MODULE_TYPE_MULTI = 0; // Module type identifier for Multitype install\nuint256 constant MODULE_TYPE_VALIDATOR = 1;\nuint256 constant MODULE_TYPE_EXECUTOR = 2;\nuint256 constant MODULE_TYPE_FALLBACK = 3;\nuint256 constant MODULE_TYPE_HOOK = 4;\nuint256 constant MODULE_TYPE_STATELESS_VALIDATOR = 7;\nuint256 constant MODULE_TYPE_PREVALIDATION_HOOK_ERC1271 = 8;\nuint256 constant MODULE_TYPE_PREVALIDATION_HOOK_ERC4337 = 9;\n\n// Nexus Validation modes\nbytes1 constant MODE_VALIDATION = 0x00;\nbytes1 constant MODE_MODULE_ENABLE = 0x01;\nbytes1 constant MODE_PREP = 0x02;\n\n// ERC-7739 support constants\nbytes4 constant SUPPORTS_ERC7739 = 0x77390000;\nbytes4 constant SUPPORTS_ERC7739_V1 = 0x77390001;\n\n// Typehashes\n\n// keccak256(\"ModuleEnableMode(address module,uint256 moduleType,bytes32 userOpHash,bytes initData)\")\nbytes32 constant MODULE_ENABLE_MODE_TYPE_HASH = 0xf6c866c1cd985ce61f030431e576c0e82887de0643dfa8a2e6efc3463e638ed0;\n\n// keccak256(\"EmergencyUninstall(address hook,uint256 hookType,bytes deInitData,uint256 nonce)\")\nbytes32 constant EMERGENCY_UNINSTALL_TYPE_HASH = 0xd3ddfc12654178cc44d4a7b6b969cfdce7ffe6342326ba37825314cffa0fba9c;\n"},"node_modules/@openzeppelin/contracts/access/Ownable.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"},"node_modules/@openzeppelin/contracts/utils/introspection/IERC165.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"},"node_modules/account-abstraction/contracts/interfaces/IPaymaster.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.5;\n\nimport \"./PackedUserOperation.sol\";\n\n/**\n * The interface exposed by a paymaster contract, who agrees to pay the gas for user's operations.\n * A paymaster must hold a stake to cover the required entrypoint stake and also the gas for the transaction.\n */\ninterface IPaymaster {\n    enum PostOpMode {\n        // User op succeeded.\n        opSucceeded,\n        // User op reverted. Still has to pay for gas.\n        opReverted,\n        // Only used internally in the EntryPoint (cleanup after postOp reverts). Never calling paymaster with this value\n        postOpReverted\n    }\n\n    /**\n     * Payment validation: check if paymaster agrees to pay.\n     * Must verify sender is the entryPoint.\n     * Revert to reject this request.\n     * Note that bundlers will reject this method if it changes the state, unless the paymaster is trusted (whitelisted).\n     * The paymaster pre-pays using its deposit, and receive back a refund after the postOp method returns.\n     * @param userOp          - The user operation.\n     * @param userOpHash      - Hash of the user's request data.\n     * @param maxCost         - The maximum cost of this transaction (based on maximum gas and gas price from userOp).\n     * @return context        - Value to send to a postOp. Zero length to signify postOp is not required.\n     * @return validationData - Signature and time-range of this operation, encoded the same as the return\n     *                          value of validateUserOperation.\n     *                          <20-byte> sigAuthorizer - 0 for valid signature, 1 to mark signature failure,\n     *                                                    other values are invalid for paymaster.\n     *                          <6-byte> validUntil - last timestamp this operation is valid. 0 for \"indefinite\"\n     *                          <6-byte> validAfter - first timestamp this operation is valid\n     *                          Note that the validation code cannot use block.timestamp (or block.number) directly.\n     */\n    function validatePaymasterUserOp(\n        PackedUserOperation calldata userOp,\n        bytes32 userOpHash,\n        uint256 maxCost\n    ) external returns (bytes memory context, uint256 validationData);\n\n    /**\n     * Post-operation handler.\n     * Must verify sender is the entryPoint.\n     * @param mode          - Enum with the following options:\n     *                        opSucceeded - User operation succeeded.\n     *                        opReverted  - User op reverted. The paymaster still has to pay for gas.\n     *                        postOpReverted - never passed in a call to postOp().\n     * @param context       - The context value returned by validatePaymasterUserOp\n     * @param actualGasCost - Actual gas used so far (without this postOp call).\n     * @param actualUserOpFeePerGas - the gas price this UserOp pays. This value is based on the UserOp's maxFeePerGas\n     *                        and maxPriorityFee (and basefee)\n     *                        It is not the same as tx.gasprice, which is what the bundler pays.\n     */\n    function postOp(\n        PostOpMode mode,\n        bytes calldata context,\n        uint256 actualGasCost,\n        uint256 actualUserOpFeePerGas\n    ) external;\n}\n"},"node_modules/@openzeppelin/contracts/utils/Context.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"}},"settings":{"remappings":["forge-std/=node_modules/forge-std/src/","account-abstraction/=node_modules/account-abstraction/contracts/","solady/=node_modules/solady/src/","sentinellist/=node_modules/@rhinestone/sentinellist/src/","module-bases/=node_modules/@rhinestone/module-bases/src/","erc7739Validator/=node_modules/@erc7579/erc7739-validator-base/src/","EnumerableSet4337/=node_modules/@erc7579/enumerablemap4337/src/","erc7579/=node_modules/@erc7579/implementation/src/","byteslib/=node_modules/solidity-bytes-utils/contracts/","rlp-reader/=node_modules/solidity-rlp/contracts/","murky-trees/=node_modules/murky/src/","solarray/=node_modules/solarray/src/","excessively-safe-call/=node_modules/excessively-safe-call/src/","@ERC4337/=node_modules/@ERC4337/","@erc7579/=node_modules/@erc7579/","@gnosis.pm/=node_modules/@gnosis.pm/","@openzeppelin/=node_modules/@openzeppelin/","@prb/=node_modules/@prb/","@rhinestone/=node_modules/@rhinestone/","@safe-global/=node_modules/@safe-global/","@zerodev/=node_modules/@zerodev/","account-abstraction-v0.6/=node_modules/account-abstraction-v0.6/","ds-test/=node_modules/ds-test/","hardhat-deploy/=node_modules/hardhat-deploy/","hardhat/=node_modules/hardhat/","solidity-bytes-utils/=node_modules/solidity-bytes-utils/","solidity-rlp/=node_modules/solidity-rlp/"],"optimizer":{"enabled":true,"runs":999},"metadata":{"useLiteralContent":false,"bytecodeHash":"none","appendCBOR":true},"outputSelection":{"*":{"*":["abi","evm.bytecode.object","evm.bytecode.sourceMap","evm.bytecode.linkReferences","evm.deployedBytecode.object","evm.deployedBytecode.sourceMap","evm.deployedBytecode.linkReferences","evm.deployedBytecode.immutableReferences","evm.methodIdentifiers","metadata"]}},"evmVersion":"cancun","viaIR":true,"libraries":{}}}
