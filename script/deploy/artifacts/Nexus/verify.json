{"language":"Solidity","sources":{"contracts/nexus/Nexus.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\n// ──────────────────────────────────────────────────────────────────────────────\n//     _   __    _  __\n//    / | / /__ | |/ /_  _______\n//   /  |/ / _ \\|   / / / / ___/\n//  / /|  /  __/   / /_/ (__  )\n// /_/ |_/\\___/_/|_\\__,_/____/\n//\n// ──────────────────────────────────────────────────────────────────────────────\n// Nexus: A suite of contracts for Modular Smart Accounts compliant with ERC-7579 and ERC-4337, developed by Biconomy.\n// Learn more at https://biconomy.io. To report security issues, please contact us at: security@biconomy.io\n\nimport { BaseAccount } from \"./base/BaseAccount.sol\";\nimport { ModuleManager } from \"./base/ModuleManager.sol\";\nimport { ExecutionHelper } from \"./base/ExecutionHelper.sol\";\nimport { ComposableExecutionBase, ComposableExecution } from \"../composability/ComposableExecutionBase.sol\";\nimport { Initializable } from \"../lib/nexus/Initializable.sol\";\nimport { UUPSUpgradeable } from \"solady/utils/UUPSUpgradeable.sol\";\nimport { INexus } from \"../interfaces/nexus/INexus.sol\";\nimport { ExecLib } from \"../lib/erc-7579/ExecLib.sol\";\nimport { NonceLib } from \"../lib/nexus/NonceLib.sol\";\nimport { SentinelListLib, SENTINEL, ZERO_ADDRESS } from \"sentinellist/SentinelList.sol\";\nimport { EmergencyUninstall } from \"../types/DataTypes.sol\";\nimport { LibPREP } from \"../lib/nexus/local/LibPREP.sol\";\nimport { ECDSA } from \"solady/utils/ECDSA.sol\";\nimport { IValidator } from \"erc7579/interfaces/IERC7579Module.sol\";\nimport {\n    MODULE_TYPE_VALIDATOR,\n    MODULE_TYPE_EXECUTOR,\n    MODULE_TYPE_FALLBACK,\n    MODULE_TYPE_HOOK,\n    SUPPORTS_ERC7739\n} from \"../types/Constants.sol\";\nimport {\n    ModeLib,\n    ExecutionMode,\n    ExecType,\n    CallType,\n    CALLTYPE_BATCH,\n    CALLTYPE_SINGLE,\n    CALLTYPE_DELEGATECALL,\n    EXECTYPE_DEFAULT,\n    EXECTYPE_TRY\n} from \"../lib/erc-7579/ModeLib.sol\";\nimport { PackedUserOperation } from \"account-abstraction/interfaces/PackedUserOperation.sol\";\n\n/// @title Nexus - Smart Account\n/// @notice This contract integrates various functionalities to handle modular smart accounts compliant with ERC-7579\n/// and\n/// ERC-4337 standards.\n/// @dev Comprehensive suite of methods for managing smart accounts, integrating module management, execution\n/// management,\n/// and upgradability via UUPS.\n/// @author @livingrockrises | Biconomy | chirag@biconomy.io\n/// @author @aboudjem | Biconomy | adam.boudjemaa@biconomy.io\n/// @author @filmakarov | Biconomy | filipp.makarov@biconomy.io\n/// @author @zeroknots | Rhinestone.wtf | zeroknots.eth\n/// Special thanks to the Solady team for foundational contributions: https://github.com/Vectorized/solady\ncontract Nexus is INexus, BaseAccount, ExecutionHelper, ModuleManager, UUPSUpgradeable, ComposableExecutionBase {\n    using ModeLib for ExecutionMode;\n    using ExecLib for bytes;\n    using NonceLib for uint256;\n    using SentinelListLib for SentinelListLib.SentinelList;\n\n    /// @dev The timelock period for emergency hook uninstallation.\n    uint256 internal constant _EMERGENCY_TIMELOCK = 1 days;\n\n    /// @dev The event emitted when an emergency hook uninstallation is initiated.\n    event EmergencyHookUninstallRequest(address hook, uint256 timestamp);\n\n    /// @dev The event emitted when an emergency hook uninstallation request is reset.\n    event EmergencyHookUninstallRequestReset(address hook, uint256 timestamp);\n\n    /// @notice Initializes the smart account with the specified entry point.\n    constructor(\n        address anEntryPoint,\n        address defaultValidator,\n        bytes memory initData\n    )\n        ModuleManager(defaultValidator, initData)\n    {\n        require(address(anEntryPoint) != address(0), EntryPointCanNotBeZero());\n        _ENTRYPOINT = anEntryPoint;\n    }\n\n    /// @notice Validates a user operation against a specified validator, extracted from the operation's nonce.\n    /// @param op The user operation to validate, encapsulating all transaction details.\n    /// @param userOpHash Hash of the user operation data, used for signature validation.\n    /// @param missingAccountFunds Funds missing from the account's deposit necessary for transaction execution.\n    /// This can be zero if covered by a paymaster or if sufficient deposit exists.\n    /// @return validationData Encoded validation result or failure, propagated from the validator module.\n    /// - Encoded format in validationData:\n    ///     - First 20 bytes: Address of the Validator module, to which the validation task is forwarded.\n    ///       The validator module returns:\n    ///         - `SIG_VALIDATION_SUCCESS` (0) indicates successful validation.\n    ///         - `SIG_VALIDATION_FAILED` (1) indicates signature validation failure.\n    /// @dev Expects the validator's address to be encoded in the upper 96 bits of the user operation's nonce.\n    /// This method forwards the validation task to the extracted validator module address.\n    /// @dev The entryPoint calls this function. If validation fails, it returns `VALIDATION_FAILED` (1) otherwise `0`.\n    /// @dev Features Module Enable Mode.\n    /// This Module Enable Mode flow is intended for the module acting as the validator\n    /// for the user operation that triggers the Module Enable Flow. Otherwise, a call to\n    /// `Nexus.installModule` should be included in `userOp.callData`.\n    function validateUserOp(\n        PackedUserOperation calldata op,\n        bytes32 userOpHash,\n        uint256 missingAccountFunds\n    )\n        external\n        virtual\n        payPrefund(missingAccountFunds)\n        onlyEntryPoint\n        returns (uint256 validationData)\n    {\n        address validator;\n        PackedUserOperation memory userOp = op;\n\n        if (op.nonce.isValidateMode()) {\n            // do nothing special. This is introduced\n            // to quickly identify the most commonly used\n            // mode which is validate mode\n            // and avoid checking two above conditions\n        } else if (op.nonce.isModuleEnableMode()) {\n            // if it is module enable mode, we need to enable the module first\n            // and get the cleaned signature\n            userOp.signature = _enableMode(userOpHash, op.signature);\n        } else if (op.nonce.isPrepMode()) {\n            // PREP Mode. Authorize prep signature\n            // and initialize the account\n            // PREP mode is only used for the uninited PREPs\n            require(!isInitialized(), AccountAlreadyInitialized());\n            bytes calldata initData;\n            (userOp.signature, initData) = _handlePREP(op.signature);\n            _initializeAccount(initData);\n        }\n        validator = _handleValidator(op.nonce.getValidator());\n        (userOpHash, userOp.signature) = _withPreValidationHook(userOpHash, userOp, missingAccountFunds);\n        validationData = IValidator(validator).validateUserOp(userOp, userOpHash);\n    }\n\n    /// @notice Executes transactions in single or batch modes as specified by the execution mode.\n    /// @param mode The execution mode detailing how transactions should be handled (single, batch, default, try/catch).\n    /// @param executionCalldata The encoded transaction data to execute.\n    /// @dev This function handles transaction execution flexibility and is protected by the `onlyEntryPoint` modifier.\n    /// @dev This function also goes through hook checks via withHook modifier.\n    function execute(ExecutionMode mode, bytes calldata executionCalldata) external payable onlyEntryPoint withHook {\n        (CallType callType, ExecType execType) = mode.decodeBasic();\n        if (callType == CALLTYPE_SINGLE) {\n            _handleSingleExecution(executionCalldata, execType);\n        } else if (callType == CALLTYPE_BATCH) {\n            _handleBatchExecution(executionCalldata, execType);\n        } else if (callType == CALLTYPE_DELEGATECALL) {\n            _handleDelegateCallExecution(executionCalldata, execType);\n        } else {\n            revert UnsupportedCallType(callType);\n        }\n    }\n\n    /// @notice Executes transactions from an executor module, supporting both single and batch transactions.\n    /// @param mode The execution mode (single or batch, default or try).\n    /// @param executionCalldata The transaction data to execute.\n    /// @return returnData The results of the transaction executions, which may include errors in try mode.\n    /// @dev This function is callable only by an executor module and goes through hook checks.\n    function executeFromExecutor(\n        ExecutionMode mode,\n        bytes calldata executionCalldata\n    )\n        external\n        payable\n        onlyExecutorModule\n        withHook\n        returns (bytes[] memory returnData)\n    {\n        (CallType callType, ExecType execType) = mode.decodeBasic();\n        // check if calltype is batch or single or delegate call\n        if (callType == CALLTYPE_SINGLE) {\n            returnData = _handleSingleExecutionAndReturnData(executionCalldata, execType);\n        } else if (callType == CALLTYPE_BATCH) {\n            returnData = _handleBatchExecutionAndReturnData(executionCalldata, execType);\n        } else if (callType == CALLTYPE_DELEGATECALL) {\n            returnData = _handleDelegateCallExecutionAndReturnData(executionCalldata, execType);\n        } else {\n            revert UnsupportedCallType(callType);\n        }\n    }\n\n    /// @notice Executes a user operation via a call using the contract's context.\n    /// @param userOp The user operation to execute, containing transaction details.\n    /// @param - Hash of the user operation.\n    /// @dev Only callable by the EntryPoint. Decodes the user operation calldata, skipping the first four bytes, and\n    /// executes the inner call.\n    function executeUserOp(\n        PackedUserOperation calldata userOp,\n        bytes32\n    )\n        external\n        payable\n        virtual\n        onlyEntryPoint\n        withHook\n    {\n        bytes calldata callData = userOp.callData[4:];\n        (bool success,) = address(this).delegatecall(callData);\n        assembly {\n            if iszero(success) {\n                // revert ExecutionFailed()\n                mstore(0x00, 0xacfdb444)\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @notice Executes a composable execution\n    /// See more about composability here: https://docs.biconomy.io/composability\n    /// @param executions The composable executions to execute\n    function executeComposable(ComposableExecution[] calldata executions)\n        external\n        payable\n        override\n        onlyEntryPoint\n        withHook\n    {\n        _executeComposable(executions);\n    }\n\n    /// @notice Executes a call to a target address with specified value and data.\n    /// @param to The address to execute the action on\n    /// @param value The value to send with the action\n    /// @param data The data to send with the action\n    /// @return result The result of the execution\n    function _executeAction(address to, uint256 value, bytes memory data) internal override returns (bytes memory) {\n        return _executeMemory(to, value, data);\n    }\n\n    /// @notice Installs a new module to the smart account.\n    /// @param moduleTypeId The type identifier of the module being installed, which determines its role:\n    /// - 1 for Validator\n    /// - 2 for Executor\n    /// - 3 for Fallback\n    /// - 4 for Hook\n    /// - 8 for 1271 Prevalidation Hook\n    /// - 9 for 4337 Prevalidation Hook\n    /// @param module The address of the module to install.\n    /// @param initData Initialization data for the module.\n    /// @dev This function can only be called by the EntryPoint or the account itself for security reasons.\n    /// @dev This function goes through hook checks via withHook modifier through internal function _installModule.\n    function installModule(\n        uint256 moduleTypeId,\n        address module,\n        bytes calldata initData\n    )\n        external\n        payable\n        virtual\n        override\n        onlyEntryPointOrSelf\n    {\n        _installModule(moduleTypeId, module, initData);\n        assembly {\n            // emit ModuleInstalled(moduleTypeId, module)\n            mstore(0x00, moduleTypeId)\n            mstore(0x20, module)\n            log1(0x00, 0x40, 0xd21d0b289f126c4b473ea641963e766833c2f13866e4ff480abd787c100ef123)\n        }\n    }\n\n    /// @notice Uninstalls a module from the smart account.\n    /// @param moduleTypeId The type ID of the module to be uninstalled, matching the installation type:\n    /// - 1 for Validator\n    /// - 2 for Executor\n    /// - 3 for Fallback\n    /// - 4 for Hook\n    /// - 8 for 1271 Prevalidation Hook\n    /// - 9 for 4337 Prevalidation Hook\n    /// @dev Attention: All the underlying functions _uninstall[ModuleType] are calling module.onInstall() method.\n    /// If the module is malicious (which is not likely because such a module won't be attested), it can prevent\n    /// itself from being uninstalled by spending all gas in the onUninstall() method. Then 1/64 gas left can\n    /// be not enough to finish the uninstallation, assuming there may be hook postCheck() call.\n    /// In this highly unlikely scenario, user will have to uninstall the hook, then uninstall the malicious\n    /// module => in this case 1/64 gas left should be enough to finish the uninstallation.\n    /// @param module The address of the module to uninstall.\n    /// @param deInitData De-initialization data for the module.\n    /// @dev Ensures that the operation is authorized and valid before proceeding with the uninstallation.\n    function uninstallModule(\n        uint256 moduleTypeId,\n        address module,\n        bytes calldata deInitData\n    )\n        external\n        payable\n        onlyEntryPointOrSelf\n        withHook\n    {\n        require(_isModuleInstalled(moduleTypeId, module, deInitData), ModuleNotInstalled(moduleTypeId, module));\n\n        if (moduleTypeId == MODULE_TYPE_VALIDATOR) {\n            _uninstallValidator(module, deInitData);\n            _checkInitializedValidators();\n        } else if (moduleTypeId == MODULE_TYPE_EXECUTOR) {\n            _uninstallExecutor(module, deInitData);\n        } else if (moduleTypeId == MODULE_TYPE_FALLBACK) {\n            _uninstallFallbackHandler(module, deInitData);\n        } else if (moduleTypeId == MODULE_TYPE_HOOK || _isPrevalidationHookType(moduleTypeId)) {\n            _uninstallHook(module, moduleTypeId, deInitData);\n        }\n        emit ModuleUninstalled(moduleTypeId, module);\n    }\n\n    function emergencyUninstallHook(EmergencyUninstall calldata data, bytes calldata signature) external payable {\n        // Validate the signature\n        _checkEmergencyUninstallSignature(data, signature);\n        // Parse uninstall data\n        (uint256 hookType, address hook, bytes calldata deInitData) = (data.hookType, data.hook, data.deInitData);\n\n        // Validate the hook is of a supported type and is installed\n        require(hookType == MODULE_TYPE_HOOK || _isPrevalidationHookType(hookType), UnsupportedModuleType(hookType));\n        require(_isModuleInstalled(hookType, hook, deInitData), ModuleNotInstalled(hookType, hook));\n\n        // Get the account storage\n        AccountStorage storage accountStorage = _getAccountStorage();\n        uint256 hookTimelock = accountStorage.emergencyUninstallTimelock[hook];\n\n        if (hookTimelock == 0) {\n            // if the timelock hasnt been initiated, initiate it\n            accountStorage.emergencyUninstallTimelock[hook] = block.timestamp;\n            emit EmergencyHookUninstallRequest(hook, block.timestamp);\n        } else if (block.timestamp >= hookTimelock + 3 * _EMERGENCY_TIMELOCK) {\n            // if the timelock has been left for too long, reset it\n            accountStorage.emergencyUninstallTimelock[hook] = block.timestamp;\n            emit EmergencyHookUninstallRequestReset(hook, block.timestamp);\n        } else if (block.timestamp >= hookTimelock + _EMERGENCY_TIMELOCK) {\n            // if the timelock expired, clear it and uninstall the hook\n            accountStorage.emergencyUninstallTimelock[hook] = 0;\n            _uninstallHook(hook, hookType, deInitData);\n            emit ModuleUninstalled(hookType, hook);\n        } else {\n            // if the timelock is initiated but not expired, revert\n            revert EmergencyTimeLockNotExpired();\n        }\n    }\n\n    /// @notice Initializes the smart account with the specified initialization data.\n    /// @param initData The initialization data for the smart account.\n    /// @dev This function can only be called by the account itself or the proxy factory.\n    /// When a 7702 account is created, the first userOp should contain self-call to initialize the account.\n    function initializeAccount(bytes calldata initData) external payable virtual {\n        // Protect this function to only be callable when used with the proxy factory or when\n        // account calls itself\n        if (msg.sender != address(this)) {\n            if (_amIERC7702()) {\n                // If this is a 7702 account, we allow passing a user signature with the initData\n                // to initialize the account. This allows 7702 accounts to be initialized\n                // by a relayer.\n                bytes calldata signature = initData[0:65];\n                AccountStorage storage $accountStorage = _getAccountStorage();\n                // Remove the signature  from the initData\n                initData = initData[65:];\n                // Calculate the hash of the initData\n                bytes32 initDataHash = keccak256(initData);\n                // Make sure the account has not been already initialized\n                // Means relay can not re-initialize the account\n                require(!isInitialized(), AccountAlreadyInitialized());\n                // Make sure the initHash is not already used\n                require(!$accountStorage.erc7702InitHashes[initDataHash], AccountAlreadyInitialized());\n                // Check if the signature is valid\n                require(ECDSA.recover(initDataHash, signature) == address(this), InvalidSignature());\n                // Mark the initDataHash as used\n                $accountStorage.erc7702InitHashes[initDataHash] = true;\n            } else {\n                Initializable.requireInitializable();\n            }\n        }\n        _initializeAccount(initData);\n    }\n\n    function _initializeAccount(bytes calldata initData) internal {\n        require(initData.length >= 24, InvalidInitData());\n\n        address bootstrap;\n        bytes calldata bootstrapCall;\n\n        assembly {\n            bootstrap := calldataload(initData.offset)\n            let s := calldataload(add(initData.offset, 0x20))\n            let u := add(initData.offset, s)\n            bootstrapCall.offset := add(u, 0x20)\n            bootstrapCall.length := calldataload(u)\n        }\n\n        (bool success,) = bootstrap.delegatecall(bootstrapCall);\n\n        assembly {\n            if iszero(success) {\n                mstore(0x00, 0x315927c5) // NexusInitializationFailed()\n                revert(0x1c, 0x04)\n            }\n        }\n        if (!_amIERC7702()) {\n            require(isInitialized(), AccountNotInitialized());\n        }\n    }\n\n    /// @notice Validates a signature according to ERC-1271 standards.\n    /// @param hash The hash of the data being validated.\n    /// @param signature Signature data that needs to be validated.\n    /// @return The status code of the signature validation (`0x1626ba7e` if valid).\n    /// bytes4(keccak256(\"isValidSignature(bytes32,bytes)\") = 0x1626ba7e\n    /// @dev Delegates the validation to a validator module specified within the signature data.\n    function isValidSignature(bytes32 hash, bytes calldata signature) external view virtual override returns (bytes4) {\n        // Handle potential ERC7739 support detection request\n        if (signature.length == 0) {\n            // Forces the compiler to optimize for smaller bytecode size.\n            if (uint256(hash) == (~signature.length / 0xffff) * 0x7739) {\n                return _checkERC7739Support(hash, signature);\n            }\n        }\n        // else proceed with normal signature verification\n        // First 20 bytes of data will be validator address and rest of the bytes is complete signature.\n        address validator = _handleValidator(address(bytes20(signature[0:20])));\n        bytes memory signature_;\n        (hash, signature_) = _withPreValidationHook(hash, signature[20:]);\n        try IValidator(validator).isValidSignatureWithSender(msg.sender, hash, signature_) returns (bytes4 res) {\n            return res;\n        } catch {\n            return bytes4(0xffffffff);\n        }\n    }\n\n    /// @notice Retrieves the address of the current implementation from the EIP-1967 slot.\n    /// @notice Checks the 1967 implementation slot, if not found then checks the slot defined by address (Biconomy V2\n    /// smart account)\n    /// @return implementation The address of the current contract implementation.\n    function getImplementation() external view returns (address implementation) {\n        assembly {\n            implementation := sload(_ERC1967_IMPLEMENTATION_SLOT)\n        }\n        if (implementation == address(0)) {\n            assembly {\n                implementation := sload(address())\n            }\n        }\n    }\n\n    /// @notice Checks if a specific module type is supported by this smart account.\n    /// @param moduleTypeId The identifier of the module type to check.\n    /// @return True if the module type is supported, false otherwise.\n    function supportsModule(uint256 moduleTypeId) external view virtual returns (bool) {\n        /* MODULE_TYPE_VALIDATOR || MODULE_TYPE_EXECUTOR\n        || MODULE_TYPE_FALLBACK || MODULE_TYPE_HOOK\n        || MODULE_TYPE_PREVALIDATION_HOOK_ERC1271\n        || MODULE_TYPE_PREVALIDATION_HOOK_ERC4337 || MODULE_TYPE_MULTI */\n        // Bitmap: 0x31F represents supported module types: 0,1,2,3,4,8,9\n        // 0x31F = 0b1100011111 = (1<<0)|(1<<1)|(1<<2)|(1<<3)|(1<<4)|(1<<8)|(1<<9)\n        return ((1 << moduleTypeId) & 0x31F) != 0;\n    }\n\n    /// @notice Determines if a specific execution mode is supported.\n    /// @param mode The execution mode to evaluate.\n    /// @return isSupported True if the execution mode is supported, false otherwise.\n    function supportsExecutionMode(ExecutionMode mode) external view virtual returns (bool isSupported) {\n        (CallType callType, ExecType execType) = mode.decodeBasic();\n\n        // Return true if both the call type and execution type are supported.\n        return (callType == CALLTYPE_SINGLE || callType == CALLTYPE_BATCH || callType == CALLTYPE_DELEGATECALL)\n            && (execType == EXECTYPE_DEFAULT || execType == EXECTYPE_TRY);\n    }\n\n    /// @notice Determines whether a module is installed on the smart account.\n    /// @param moduleTypeId The ID corresponding to the type of module (Validator, Executor, Fallback, Hook).\n    /// @param module The address of the module to check.\n    /// @param additionalContext Optional context that may be needed for certain checks.\n    /// @return True if the module is installed, false otherwise.\n    function isModuleInstalled(\n        uint256 moduleTypeId,\n        address module,\n        bytes calldata additionalContext\n    )\n        external\n        view\n        returns (bool)\n    {\n        return _isModuleInstalled(moduleTypeId, module, additionalContext);\n    }\n\n    /// @notice Checks if the smart account is initialized.\n    /// @return True if the smart account is initialized, false otherwise.\n    /// @dev In case default validator is initialized, two other SLOADS from _areSentinelListsInitialized() are not\n    /// checked,\n    /// this method should not introduce huge gas overhead.\n    function isInitialized() public view returns (bool) {\n        return (IValidator(_DEFAULT_VALIDATOR).isInitialized(address(this)) || _areSentinelListsInitialized());\n    }\n\n    /// Returns the account's implementation ID.\n    /// @return The unique identifier for this account implementation.\n    function accountId() external pure virtual returns (string memory) {\n        return \"biconomy.nexus.1.3.0\";\n    }\n\n    /// Upgrades the contract to a new implementation and calls a function on the new contract.\n    /// @notice Updates two slots 1. ERC1967 slot and\n    /// 2. address() slot in case if it's potentially upgraded earlier from Biconomy V2 account,\n    /// as Biconomy v2 Account (proxy) reads implementation from the slot that is defined by its address\n    /// @param newImplementation The address of the new contract implementation.\n    /// @param data The calldata to be sent to the new implementation.\n    function upgradeToAndCall(address newImplementation, bytes calldata data) public payable virtual override withHook {\n        require(newImplementation != address(0), InvalidImplementationAddress());\n        bool res;\n        assembly {\n            res := gt(extcodesize(newImplementation), 0)\n        }\n        require(res, InvalidImplementationAddress());\n        // update the address() storage slot as well\n        // This is needed in case the og proxy is Nexus v2 proxy which\n        // reads the implementation from the slot defined by its address\n        assembly {\n            sstore(address(), newImplementation)\n        }\n        UUPSUpgradeable.upgradeToAndCall(newImplementation, data);\n    }\n\n    /// @dev For automatic detection that the smart account supports the ERC7739 workflow\n    /// Iterates over all the validators but only if this is a detection request\n    /// ERC-7739 spec assumes that if the account doesn't support ERC-7739\n    /// it will try to handle the detection request as it was normal sig verification\n    /// request and will return 0xffffffff since it won't be able to verify the 0x signature\n    /// against 0x7739...7739 hash.\n    /// So this approach is consistent with the ERC-7739 spec.\n    /// If no validator supports ERC-7739, this function returns false\n    /// thus the account will proceed with normal signature verification\n    /// and return 0xffffffff as a result.\n    function _checkERC7739Support(bytes32 hash, bytes calldata signature) internal view virtual returns (bytes4) {\n        bytes4 result;\n        unchecked {\n            SentinelListLib.SentinelList storage validators = _getAccountStorage().validators;\n            address next = validators.entries[SENTINEL];\n            while (next != ZERO_ADDRESS && next != SENTINEL) {\n                result = _get7739Version(next, result, hash, signature);\n                next = validators.getNext(next);\n            }\n        }\n        result = _get7739Version(_DEFAULT_VALIDATOR, result, hash, signature); // check default validator\n        return result == bytes4(0) ? bytes4(0xffffffff) : result;\n    }\n\n    function _get7739Version(\n        address validator,\n        bytes4 prevResult,\n        bytes32 hash,\n        bytes calldata signature\n    )\n        internal\n        view\n        returns (bytes4)\n    {\n        bytes4 support = IValidator(validator).isValidSignatureWithSender(msg.sender, hash, signature);\n        if (bytes2(support) == bytes2(SUPPORTS_ERC7739) && support > prevResult) {\n            return support;\n        }\n        return prevResult;\n    }\n\n    /// @dev Ensures that only authorized callers can upgrade the smart contract implementation.\n    /// This is part of the UUPS (Universal Upgradeable Proxy Standard) pattern.\n    /// param newImplementation The address of the new implementation to upgrade to.\n    function _authorizeUpgrade(\n        address /* newImplementation */\n    )\n        internal\n        virtual\n        override(UUPSUpgradeable)\n        onlyEntryPointOrSelf\n    {\n        if (_amIERC7702()) {\n            revert ERC7702AccountCannotBeUpgradedThisWay();\n        }\n    }\n\n    /// @dev Handles the PREP initialization.\n    /// @param data The packed data to be handled.\n    /// @return cleanedSignature The cleaned signature for Nexus 4337 (validateUserOp) flow.\n    /// @return initData The data to initialize the account with.\n    function _handlePREP(bytes calldata data)\n        internal\n        returns (bytes calldata cleanedSignature, bytes calldata initData)\n    {\n        bytes32 saltAndDelegation;\n        // unpack the data\n        assembly {\n            if lt(data.length, 0xf9) {\n                mstore(0x0, 0xaed59595) // NotInitializable()\n                revert(0x1c, 0x04)\n            }\n\n            saltAndDelegation := calldataload(data.offset)\n\n            // initData\n            let p := calldataload(add(data.offset, 0x20))\n            let u := add(data.offset, p)\n            initData.offset := add(u, 0x20)\n            initData.length := calldataload(u)\n\n            // cleanedSignature\n            p := calldataload(add(data.offset, 0x40))\n            u := add(data.offset, p)\n            cleanedSignature.offset := add(u, 0x20)\n            cleanedSignature.length := calldataload(u)\n        }\n\n        // check r is valid\n        bytes32 r = LibPREP.rPREP(address(this), keccak256(initData), saltAndDelegation);\n        assembly {\n            if iszero(r) {\n                mstore(0x00, 0xe483bbcb) // revert InvalidPREP()\n                revert(0x1c, 0x04)\n            }\n            // emit PREPInitialized(r)\n            mstore(0x00, r)\n            log1(0x00, 0x20, 0x4f058962bce244bca6c9be42f256083afc66f1f63a1f9a04e31a3042311af38d)\n        }\n    }\n\n    // checks if there's at least one validator initialized\n    function _checkInitializedValidators() internal view {\n        if (!_amIERC7702() && !IValidator(_DEFAULT_VALIDATOR).isInitialized(address(this))) {\n            unchecked {\n                SentinelListLib.SentinelList storage validators = _getAccountStorage().validators;\n                address next = validators.entries[SENTINEL];\n                while (next != ZERO_ADDRESS && next != SENTINEL) {\n                    if (IValidator(next).isInitialized(address(this))) {\n                        break;\n                    }\n                    next = validators.getNext(next);\n                }\n                if (next == SENTINEL) {\n                    //went through all validators and none was initialized\n                    assembly {\n                        // revert CanNotRemoveLastValidator()\n                        mstore(0x00, 0xcc319d84)\n                        revert(0x1c, 0x04)\n                    }\n                }\n            }\n        }\n    }\n\n    /// @dev EIP712 domain name and version.\n    function _domainNameAndVersion() internal pure override returns (string memory name, string memory version) {\n        name = \"Nexus\";\n        version = \"1.3.0\";\n    }\n}\n"},"contracts/nexus/base/BaseAccount.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\n// ──────────────────────────────────────────────────────────────────────────────\n//     _   __    _  __\n//    / | / /__ | |/ /_  _______\n//   /  |/ / _ \\|   / / / / ___/\n//  / /|  /  __/   / /_/ (__  )\n// /_/ |_/\\___/_/|_\\__,_/____/\n//\n// ──────────────────────────────────────────────────────────────────────────────\n// Nexus: A suite of contracts for Modular Smart Accounts compliant with ERC-7579 and ERC-4337, developed by Biconomy.\n// Learn more at https://biconomy.io. To report security issues, please contact us at: security@biconomy.io\n\nimport { IBaseAccount } from \"../../interfaces/nexus/base/IBaseAccount.sol\";\n\n/// @title Nexus - BaseAccount\n/// @notice Implements ERC-4337 and ERC-7579 standards for account management and access control within the Nexus suite.\n/// @dev Manages entry points and configurations as specified in the ERC-4337 and ERC-7579 documentation.\n/// @author @livingrockrises | Biconomy | chirag@biconomy.io\n/// @author @aboudjem | Biconomy | adam.boudjemaa@biconomy.io\n/// @author @filmakarov | Biconomy | filipp.makarov@biconomy.io\n/// @author @zeroknots | Rhinestone.wtf | zeroknots.eth\n/// Special thanks to the Solady team for foundational contributions: https://github.com/Vectorized/solady\ncontract BaseAccount is IBaseAccount {\n    /// @notice The canonical address for the ERC4337 EntryPoint contract, version 0.7.\n    /// This address is consistent across all supported networks.\n    address internal immutable _ENTRYPOINT;\n\n    /// @dev Ensures the caller is either the EntryPoint or this account itself.\n    /// Reverts with AccountAccessUnauthorized if the check fails.\n    modifier onlyEntryPointOrSelf() {\n        require(msg.sender == _ENTRYPOINT || msg.sender == address(this), AccountAccessUnauthorized());\n        _;\n    }\n\n    /// @dev Ensures the caller is the EntryPoint.\n    /// Reverts with AccountAccessUnauthorized if the check fails.\n    modifier onlyEntryPoint() {\n        require(msg.sender == _ENTRYPOINT, AccountAccessUnauthorized());\n        _;\n    }\n\n    /// @dev Sends to the EntryPoint (i.e. `msg.sender`) the missing funds for this transaction.\n    /// Subclass MAY override this modifier for better funds management.\n    /// (e.g. send to the EntryPoint more than the minimum required, so that in future transactions\n    /// it will not be required to send again)\n    ///\n    /// `missingAccountFunds` is the minimum value this modifier should send the EntryPoint,\n    /// which MAY be zero, in case there is enough deposit, or the userOp has a paymaster.\n    modifier payPrefund(uint256 missingAccountFunds) virtual {\n        _;\n        /// @solidity memory-safe-assembly\n        assembly {\n            if missingAccountFunds {\n                // Ignore failure (it's EntryPoint's job to verify, not the account's).\n                pop(call(gas(), caller(), missingAccountFunds, codesize(), 0x00, codesize(), 0x00))\n            }\n        }\n    }\n\n    /// @notice Adds deposit to the EntryPoint to fund transactions.\n    function addDeposit() external payable virtual {\n        address entryPointAddress = _ENTRYPOINT;\n        /// @solidity memory-safe-assembly\n        assembly {\n            // The EntryPoint has balance accounting logic in the `receive()` function.\n            if iszero(call(gas(), entryPointAddress, callvalue(), codesize(), 0x00, codesize(), 0x00)) {\n                revert(codesize(), 0x00)\n            } // For gas estimation.\n        }\n    }\n\n    /// @notice Withdraws ETH from the EntryPoint to a specified address.\n    /// @param to The address to receive the withdrawn funds.\n    /// @param amount The amount to withdraw.\n    function withdrawDepositTo(address to, uint256 amount) external payable virtual onlyEntryPointOrSelf {\n        address entryPointAddress = _ENTRYPOINT;\n        assembly {\n            let freeMemPtr := mload(0x40) // Store the free memory pointer.\n            mstore(0x14, to) // Store the `to` argument.\n            mstore(0x34, amount) // Store the `amount` argument.\n            mstore(0x00, 0x205c2878000000000000000000000000) // `withdrawTo(address,uint256)`.\n            if iszero(call(gas(), entryPointAddress, 0, 0x10, 0x44, codesize(), 0x00)) {\n                returndatacopy(freeMemPtr, 0x00, returndatasize())\n                revert(freeMemPtr, returndatasize())\n            }\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\n        }\n    }\n\n    /// @notice Returns the current deposit balance of this account on the EntryPoint.\n    /// @return result The current balance held at the EntryPoint.\n    function getDeposit() external view virtual returns (uint256 result) {\n        address entryPointAddress = _ENTRYPOINT;\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x20, address()) // Store the `account` argument.\n            mstore(0x00, 0x70a08231) // `balanceOf(address)`.\n            result := mul(\n                // Returns 0 if the EntryPoint does not exist.\n                mload(0x20),\n                and(\n                    // The arguments of `and` are evaluated from right to left.\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\n                    staticcall(gas(), entryPointAddress, 0x1c, 0x24, 0x20, 0x20)\n                )\n            )\n        }\n    }\n\n    /// @notice Retrieves the address of the EntryPoint contract, currently using version 0.7.\n    /// @dev This function returns the address of the canonical ERC4337 EntryPoint contract.\n    /// It can be overridden to return a different EntryPoint address if needed.\n    /// @return The address of the EntryPoint contract.\n    function entryPoint() external view returns (address) {\n        return _ENTRYPOINT;\n    }\n}\n"},"contracts/nexus/base/ModuleManager.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\n// ──────────────────────────────────────────────────────────────────────────────\n//     _   __    _  __\n//    / | / /__ | |/ /_  _______\n//   /  |/ / _ \\|   / / / / ___/\n//  / /|  /  __/   / /_/ (__  )\n// /_/ |_/\\___/_/|_\\__,_/____/\n//\n// ──────────────────────────────────────────────────────────────────────────────\n// Nexus: A suite of contracts for Modular Smart Accounts compliant with ERC-7579 and ERC-4337, developed by Biconomy.\n// Learn more at https://biconomy.io. To report security issues, please contact us at: security@biconomy.io\n\nimport { SentinelListLib } from \"sentinellist/SentinelList.sol\";\nimport { Storage } from \"./Storage.sol\";\nimport {\n    IModule,\n    IValidator,\n    IExecutor,\n    IHook,\n    IPreValidationHookERC1271,\n    IPreValidationHookERC4337,\n    IFallback\n} from \"erc7579/interfaces/IERC7579Module.sol\";\nimport { CallType, CALLTYPE_SINGLE, CALLTYPE_STATIC } from \"../../lib/erc-7579/ModeLib.sol\";\nimport { ExecLib } from \"../../lib/erc-7579/ExecLib.sol\";\nimport { LocalCallDataParserLib } from \"../../lib/nexus/local/LocalCallDataParserLib.sol\";\nimport { IModuleManager } from \"../../interfaces/nexus/base/IModuleManager.sol\";\nimport {\n    MODULE_TYPE_VALIDATOR,\n    MODULE_TYPE_EXECUTOR,\n    MODULE_TYPE_FALLBACK,\n    MODULE_TYPE_HOOK,\n    MODULE_TYPE_PREVALIDATION_HOOK_ERC1271,\n    MODULE_TYPE_PREVALIDATION_HOOK_ERC4337,\n    MODULE_TYPE_MULTI,\n    MODULE_ENABLE_MODE_TYPE_HASH,\n    EMERGENCY_UNINSTALL_TYPE_HASH,\n    ERC1271_SUCCESS\n} from \"../../types/Constants.sol\";\nimport { EIP712 } from \"solady/utils/EIP712.sol\";\nimport { ExcessivelySafeCall } from \"excessively-safe-call/ExcessivelySafeCall.sol\";\nimport { PackedUserOperation } from \"account-abstraction/interfaces/PackedUserOperation.sol\";\nimport { EmergencyUninstall } from \"../../types/DataTypes.sol\";\n\n/// @title Nexus - ModuleManager\n/// @notice Manages Validator, Executor, Hook, and Fallback modules within the Nexus suite, supporting\n/// @dev Implements SentinelList for managing modules via a linked list structure, adhering to ERC-7579.\n/// @author @livingrockrises | Biconomy | chirag@biconomy.io\n/// @author @aboudjem | Biconomy | adam.boudjemaa@biconomy.io\n/// @author @filmakarov | Biconomy | filipp.makarov@biconomy.io\n/// @author @zeroknots | Rhinestone.wtf | zeroknots.eth\n/// Special thanks to the Solady team for foundational contributions: https://github.com/Vectorized/solady\nabstract contract ModuleManager is Storage, EIP712, IModuleManager {\n    using SentinelListLib for SentinelListLib.SentinelList;\n    using LocalCallDataParserLib for bytes;\n    using ExecLib for address;\n    using ExcessivelySafeCall for address;\n\n    /// @dev The default validator address.\n    /// @notice To explicitly initialize the default validator, Nexus.execute(_DEFAULT_VALIDATOR.onInstall(...)) should\n    /// be\n    /// called.\n    address internal immutable _DEFAULT_VALIDATOR;\n\n    /// @notice Ensures the message sender is a registered executor module.\n    modifier onlyExecutorModule() virtual {\n        require(_getAccountStorage().executors.contains(msg.sender), InvalidModule(msg.sender));\n        _;\n    }\n\n    /// @notice Does pre-checks and post-checks using an installed hook on the account.\n    /// @dev sender, msg.data and msg.value is passed to the hook to implement custom flows.\n    modifier withHook() {\n        address hook = _getHook();\n        if (hook == address(0)) {\n            _;\n        } else {\n            bytes memory hookData = IHook(hook).preCheck(msg.sender, msg.value, msg.data);\n            _;\n            IHook(hook).postCheck(hookData);\n        }\n    }\n\n    /// @dev initData should block the implementation from being used as a Smart Account\n    constructor(address defaultValidator_, bytes memory initData_) {\n        if (!IValidator(defaultValidator_).isModuleType(MODULE_TYPE_VALIDATOR)) {\n            revert MismatchModuleTypeId();\n        }\n        IValidator(defaultValidator_).onInstall(initData_);\n        _DEFAULT_VALIDATOR = defaultValidator_;\n    }\n\n    // receive function\n    receive() external payable { }\n\n    /// @dev Fallback function to manage incoming calls using designated handlers based on the call type.\n    /// Hooked manually in the _fallback function\n    fallback() external payable {\n        _fallback(msg.data);\n    }\n\n    /// @dev Retrieves the default validator address.\n    /// @return The address of the default validator.\n    function getDefaultValidator() external view returns (address) {\n        return _DEFAULT_VALIDATOR;\n    }\n\n    /// @dev Retrieves a paginated list of validator addresses from the linked list.\n    /// This utility function is not defined by the ERC-7579 standard and is implemented to facilitate\n    /// easier management and retrieval of large sets of validator modules.\n    /// @param cursor The address to start pagination from, or zero to start from the first entry.\n    /// @param size The number of validator addresses to return.\n    /// @return array An array of validator addresses.\n    /// @return next The address to use as a cursor for the next page of results.\n    function getValidatorsPaginated(\n        address cursor,\n        uint256 size\n    )\n        external\n        view\n        returns (address[] memory array, address next)\n    {\n        (array, next) = _paginate(_getAccountStorage().validators, cursor, size);\n    }\n\n    /// @dev Retrieves a paginated list of executor addresses from the linked list.\n    /// This utility function is not defined by the ERC-7579 standard and is implemented to facilitate\n    /// easier management and retrieval of large sets of executor modules.\n    /// @param cursor The address to start pagination from, or zero to start from the first entry.\n    /// @param size The number of executor addresses to return.\n    /// @return array An array of executor addresses.\n    /// @return next The address to use as a cursor for the next page of results.\n    function getExecutorsPaginated(\n        address cursor,\n        uint256 size\n    )\n        external\n        view\n        returns (address[] memory array, address next)\n    {\n        (array, next) = _paginate(_getAccountStorage().executors, cursor, size);\n    }\n\n    /// @notice Retrieves the currently active hook address.\n    /// @return hook The address of the active hook module.\n    function getActiveHook() external view returns (address hook) {\n        return _getHook();\n    }\n\n    /// @notice Fetches the fallback handler for a specific selector.\n    /// @param selector The function selector to query.\n    /// @return calltype The type of call that the handler manages.\n    /// @return handler The address of the fallback handler.\n    function getFallbackHandlerBySelector(bytes4 selector) external view returns (CallType, address) {\n        FallbackHandler memory handler = _getAccountStorage().fallbacks[selector];\n        return (handler.calltype, handler.handler);\n    }\n\n    /// @dev Initializes the module manager by setting up default states for validators and executors.\n    function _initSentinelLists() internal virtual {\n        // account module storage\n        AccountStorage storage ams = _getAccountStorage();\n        ams.executors.init();\n        ams.validators.init();\n    }\n\n    /// @dev Implements Module Enable Mode flow.\n    /// @param packedData Data source to parse data required to perform Module Enable mode from.\n    /// @return userOpSignature the clean signature which can be further used for userOp validation\n    function _enableMode(\n        bytes32 userOpHash,\n        bytes calldata packedData\n    )\n        internal\n        returns (bytes calldata userOpSignature)\n    {\n        address module;\n        uint256 moduleType;\n        bytes calldata moduleInitData;\n        bytes calldata enableModeSignature;\n\n        (module, moduleType, moduleInitData, enableModeSignature, userOpSignature) = packedData.parseEnableModeData();\n\n        address enableModeSigValidator = _handleValidator(address(bytes20(enableModeSignature[0:20])));\n\n        enableModeSignature = enableModeSignature[20:];\n\n        bytes32 structHash = _getEnableModeDataHash(module, moduleType, userOpHash, moduleInitData);\n        bool isValid = _checkEnableModeSignature(structHash, enableModeSignature, enableModeSigValidator);\n\n        assembly {\n            if iszero(isValid) {\n                // revert EnableModeSigError()\n                mstore(0x00, 0x46fdc333)\n                revert(0x1c, 0x04)\n            }\n        }\n\n        this.installModule(moduleType, module, moduleInitData);\n    }\n\n    /// @notice Installs a new module to the smart account.\n    /// @param moduleTypeId The type identifier of the module being installed, which determines its role:\n    /// - 0 for MultiType\n    /// - 1 for Validator\n    /// - 2 for Executor\n    /// - 3 for Fallback\n    /// - 4 for Hook\n    /// - 8 for PreValidationHookERC1271\n    /// - 9 for PreValidationHookERC4337\n    /// @param module The address of the module to install.\n    /// @param initData Initialization data for the module.\n    /// @dev This function goes through hook checks via withHook modifier.\n    /// @dev No need to check that the module is already installed, as this check is done\n    /// when trying to sstore the module in an appropriate SentinelList\n    function _installModule(uint256 moduleTypeId, address module, bytes calldata initData) internal {\n        if (!_areSentinelListsInitialized()) {\n            _initSentinelLists();\n        }\n        if (module == address(0)) revert ModuleAddressCanNotBeZero();\n        if (moduleTypeId == MODULE_TYPE_VALIDATOR) {\n            _installValidator(module, initData);\n        } else if (moduleTypeId == MODULE_TYPE_EXECUTOR) {\n            _installExecutor(module, initData);\n        } else if (moduleTypeId == MODULE_TYPE_FALLBACK) {\n            _installFallbackHandler(module, initData);\n        } else if (moduleTypeId == MODULE_TYPE_HOOK) {\n            _installHook(module, initData);\n        } else if (_isPrevalidationHookType(moduleTypeId)) {\n            _installPreValidationHook(moduleTypeId, module, initData);\n        } else if (moduleTypeId == MODULE_TYPE_MULTI) {\n            _multiTypeInstall(module, initData);\n        } else {\n            revert InvalidModuleTypeId(moduleTypeId);\n        }\n    }\n\n    /// @dev Installs a new validator module after checking if it matches the required module type.\n    /// @param validator The address of the validator module to be installed.\n    /// @param data Initialization data to configure the validator upon installation.\n    function _installValidator(address validator, bytes calldata data) internal virtual withHook {\n        if (!IValidator(validator).isModuleType(MODULE_TYPE_VALIDATOR)) revert MismatchModuleTypeId();\n        if (validator == _DEFAULT_VALIDATOR) {\n            revert DefaultValidatorAlreadyInstalled();\n        }\n        _getAccountStorage().validators.push(validator);\n        IValidator(validator).onInstall(data);\n    }\n\n    /// @dev Uninstalls a validator module.\n    /// @param validator The address of the validator to be uninstalled.\n    /// @param data De-initialization data to configure the validator upon uninstallation.\n    function _uninstallValidator(address validator, bytes calldata data) internal virtual {\n        SentinelListLib.SentinelList storage validators = _getAccountStorage().validators;\n\n        (address prev, bytes memory disableModuleData) = abi.decode(data, (address, bytes));\n\n        // Perform the removal first\n        validators.pop(prev, validator);\n\n        validator.excessivelySafeCall(\n            gasleft(), 0, 0, abi.encodeWithSelector(IModule.onUninstall.selector, disableModuleData)\n        );\n    }\n\n    /// @dev Installs a new executor module after checking if it matches the required module type.\n    /// @param executor The address of the executor module to be installed.\n    /// @param data Initialization data to configure the executor upon installation.\n    function _installExecutor(address executor, bytes calldata data) internal virtual withHook {\n        if (!IExecutor(executor).isModuleType(MODULE_TYPE_EXECUTOR)) revert MismatchModuleTypeId();\n        _getAccountStorage().executors.push(executor);\n        IExecutor(executor).onInstall(data);\n    }\n\n    /// @dev Uninstalls an executor module by removing it from the executors list.\n    /// @param executor The address of the executor to be uninstalled.\n    /// @param data De-initialization data to configure the executor upon uninstallation.\n    function _uninstallExecutor(address executor, bytes calldata data) internal virtual {\n        (address prev, bytes memory disableModuleData) = abi.decode(data, (address, bytes));\n        _getAccountStorage().executors.pop(prev, executor);\n        executor.excessivelySafeCall(\n            gasleft(), 0, 0, abi.encodeWithSelector(IModule.onUninstall.selector, disableModuleData)\n        );\n    }\n\n    /// @dev Installs a hook module, ensuring no other hooks are installed before proceeding.\n    /// @param hook The address of the hook to be installed.\n    /// @param data Initialization data to configure the hook upon installation.\n    function _installHook(address hook, bytes calldata data) internal virtual withHook {\n        if (!IHook(hook).isModuleType(MODULE_TYPE_HOOK)) revert MismatchModuleTypeId();\n        address currentHook = _getHook();\n        require(currentHook == address(0), HookAlreadyInstalled(currentHook));\n        _setHook(hook);\n        IHook(hook).onInstall(data);\n    }\n\n    /// @dev Uninstalls a hook module, ensuring the current hook matches the one intended for uninstallation.\n    /// @param hook The address of the hook to be uninstalled.\n    /// @param hookType The type of the hook to be uninstalled.\n    /// @param data De-initialization data to configure the hook upon uninstallation.\n    function _uninstallHook(address hook, uint256 hookType, bytes calldata data) internal virtual {\n        if (hookType == MODULE_TYPE_HOOK) {\n            _setHook(address(0));\n        } else if (_isPrevalidationHookType(hookType)) {\n            _uninstallPreValidationHook(hookType);\n        }\n        hook.excessivelySafeCall(gasleft(), 0, 0, abi.encodeWithSelector(IModule.onUninstall.selector, data));\n    }\n\n    /// @dev Sets the current hook in the storage to the specified address.\n    /// @param hook The new hook address.\n    function _setHook(address hook) internal virtual {\n        _getAccountStorage().hook = IHook(hook);\n    }\n\n    /// @dev Installs a fallback handler for a given selector with initialization data.\n    /// @param handler The address of the fallback handler to install.\n    /// @param params The initialization parameters including the selector and call type.\n    function _installFallbackHandler(address handler, bytes calldata params) internal virtual withHook {\n        if (!IFallback(handler).isModuleType(MODULE_TYPE_FALLBACK)) revert MismatchModuleTypeId();\n        // Extract the function selector from the provided parameters.\n        bytes4 selector = bytes4(params[0:4]);\n\n        // Extract the call type from the provided parameters.\n        CallType calltype = CallType.wrap(bytes1(params[4]));\n\n        require(calltype == CALLTYPE_SINGLE || calltype == CALLTYPE_STATIC, FallbackCallTypeInvalid());\n\n        // Extract the initialization data from the provided parameters.\n        bytes memory initData = params[5:];\n\n        // Revert if the selector is either `onInstall(bytes)` (0x6d61fe70) or `onUninstall(bytes)` (0x8a91b0e3) or\n        // explicit bytes(0).\n        // These selectors are explicitly forbidden to prevent security vulnerabilities.\n        // Allowing these selectors would enable unauthorized users to uninstall and reinstall critical modules.\n        // If a validator module is uninstalled and reinstalled without proper authorization, it can compromise\n        // the account's security and integrity. By restricting these selectors, we ensure that the fallback handler\n        // cannot be manipulated to disrupt the expected behavior and security of the account.\n        require(\n            !(selector == bytes4(0x6d61fe70) || selector == bytes4(0x8a91b0e3) || selector == bytes4(0)),\n            FallbackSelectorForbidden()\n        );\n\n        // Revert if a fallback handler is already installed for the given selector.\n        // This check ensures that we do not overwrite an existing fallback handler, which could lead to unexpected\n        // behavior.\n        require(!_isFallbackHandlerInstalled(selector), FallbackAlreadyInstalledForSelector(selector));\n\n        // Store the fallback handler and its call type in the account storage.\n        // This maps the function selector to the specified fallback handler and call type.\n        _getAccountStorage().fallbacks[selector] = FallbackHandler(handler, calltype);\n\n        // Invoke the `onInstall` function of the fallback handler with the provided initialization data.\n        // This step allows the fallback handler to perform any necessary setup or initialization.\n        IFallback(handler).onInstall(initData);\n    }\n\n    /// @dev Uninstalls a fallback handler for a given selector.\n    /// @param fallbackHandler The address of the fallback handler to uninstall.\n    /// @param data The de-initialization data containing the selector.\n    function _uninstallFallbackHandler(address fallbackHandler, bytes calldata data) internal virtual {\n        _getAccountStorage().fallbacks[bytes4(data[0:4])] = FallbackHandler(address(0), CallType.wrap(0x00));\n        fallbackHandler.excessivelySafeCall(\n            gasleft(), 0, 0, abi.encodeWithSelector(IModule.onUninstall.selector, data[4:])\n        );\n    }\n\n    /// @dev Installs a pre-validation hook module, ensuring no other pre-validation hooks are installed before\n    /// proceeding.\n    /// @param preValidationHookType The type of the pre-validation hook.\n    /// @param preValidationHook The address of the pre-validation hook to be installed.\n    /// @param data Initialization data to configure the hook upon installation.\n    function _installPreValidationHook(\n        uint256 preValidationHookType,\n        address preValidationHook,\n        bytes calldata data\n    )\n        internal\n        virtual\n        withHook\n    {\n        if (!IModule(preValidationHook).isModuleType(preValidationHookType)) revert MismatchModuleTypeId();\n        address currentPreValidationHook = _getPreValidationHook(preValidationHookType);\n        require(currentPreValidationHook == address(0), PrevalidationHookAlreadyInstalled(currentPreValidationHook));\n        _setPreValidationHook(preValidationHookType, preValidationHook);\n        IModule(preValidationHook).onInstall(data);\n    }\n\n    /// @dev Uninstalls a pre-validation hook module\n    /// @param hookType The type of the pre-validation hook.\n    function _uninstallPreValidationHook(uint256 hookType) internal virtual {\n        _setPreValidationHook(hookType, address(0));\n    }\n\n    /// @dev Sets the current pre-validation hook in the storage to the specified address, based on the hook type.\n    /// @param hookType The type of the pre-validation hook.\n    /// @param hook The new hook address.\n    function _setPreValidationHook(uint256 hookType, address hook) internal virtual {\n        if (hookType == MODULE_TYPE_PREVALIDATION_HOOK_ERC1271) {\n            _getAccountStorage().preValidationHookERC1271 = IPreValidationHookERC1271(hook);\n        } else if (hookType == MODULE_TYPE_PREVALIDATION_HOOK_ERC4337) {\n            _getAccountStorage().preValidationHookERC4337 = IPreValidationHookERC4337(hook);\n        }\n    }\n\n    /// @notice Installs a module with multiple types in a single operation.\n    /// @dev This function handles installing a multi-type module by iterating through each type and initializing it.\n    /// The initData should include an ABI-encoded tuple of (uint[] types, bytes[] initDatas).\n    /// @param module The address of the multi-type module.\n    /// @param initData Initialization data for each type within the module.\n    function _multiTypeInstall(address module, bytes calldata initData) internal virtual {\n        (uint256[] calldata types, bytes[] calldata initDatas) = initData.parseMultiTypeInitData();\n\n        uint256 length = types.length;\n        if (initDatas.length != length) revert InvalidInput();\n\n        // iterate over all module types and install the module as a type accordingly\n        for (uint256 i; i < length; i++) {\n            uint256 theType = types[i];\n\n            /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n            /*                      INSTALL VALIDATORS                    */\n            /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n            if (theType == MODULE_TYPE_VALIDATOR) {\n                _installValidator(module, initDatas[i]);\n            }\n            /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n            /*                       INSTALL EXECUTORS                    */\n            /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n            else if (theType == MODULE_TYPE_EXECUTOR) {\n                _installExecutor(module, initDatas[i]);\n            }\n            /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n            /*                       INSTALL FALLBACK                     */\n            /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n            else if (theType == MODULE_TYPE_FALLBACK) {\n                _installFallbackHandler(module, initDatas[i]);\n            }\n            /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n            /*          INSTALL HOOK (global only, not sig-specific)      */\n            /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n            else if (theType == MODULE_TYPE_HOOK) {\n                _installHook(module, initDatas[i]);\n            }\n            /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n            /*          INSTALL PRE-VALIDATION HOOK                       */\n            /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n            else if (_isPrevalidationHookType(theType)) {\n                _installPreValidationHook(theType, module, initDatas[i]);\n            }\n        }\n    }\n\n    /// @notice Checks if an emergency uninstall signature is valid.\n    /// @param data The emergency uninstall data.\n    /// @param signature The signature to validate.\n    function _checkEmergencyUninstallSignature(EmergencyUninstall calldata data, bytes calldata signature) internal {\n        address validator = _handleValidator(address(bytes20(signature[0:20])));\n        // Hash the data\n        bytes32 hash = _hashTypedData(\n            keccak256(\n                abi.encode(\n                    EMERGENCY_UNINSTALL_TYPE_HASH, data.hook, data.hookType, keccak256(data.deInitData), data.nonce\n                )\n            )\n        );\n        // Check if nonce is valid\n        require(!_getAccountStorage().nonces[data.nonce], InvalidNonce());\n        // Mark nonce as used\n        _getAccountStorage().nonces[data.nonce] = true;\n        // Check if the signature is valid\n        require(\n            (IValidator(validator).isValidSignatureWithSender(address(this), hash, signature[20:]) == ERC1271_SUCCESS),\n            EmergencyUninstallSigError()\n        );\n    }\n\n    /// @dev Calls the pre-validation hook for ERC-4337.\n    /// @param hash The hash of the user operation.\n    /// @param userOp The user operation data.\n    /// @param missingAccountFunds The amount of missing account funds.\n    /// @return postHash The updated hash after the pre-validation hook.\n    /// @return postSig The updated signature after the pre-validation hook.\n    function _withPreValidationHook(\n        bytes32 hash,\n        PackedUserOperation memory userOp,\n        uint256 missingAccountFunds\n    )\n        internal\n        virtual\n        returns (bytes32 postHash, bytes memory postSig)\n    {\n        // Get the pre-validation hook for ERC-4337\n        address preValidationHook = _getPreValidationHook(MODULE_TYPE_PREVALIDATION_HOOK_ERC4337);\n        // If no pre-validation hook is installed, return the original hash and signature\n        if (preValidationHook == address(0)) {\n            return (hash, userOp.signature);\n        }\n        // Otherwise, call the pre-validation hook and return the updated hash and signature\n        else {\n            return\n                IPreValidationHookERC4337(preValidationHook).preValidationHookERC4337(userOp, missingAccountFunds, hash);\n        }\n    }\n\n    /// @dev Retrieves the pre-validation hook from the storage based on the hook type.\n    /// @param preValidationHookType The type of the pre-validation hook.\n    /// @return preValidationHook The address of the pre-validation hook.\n    function _getPreValidationHook(uint256 preValidationHookType) internal view returns (address preValidationHook) {\n        preValidationHook = preValidationHookType == MODULE_TYPE_PREVALIDATION_HOOK_ERC1271\n            ? address(_getAccountStorage().preValidationHookERC1271)\n            : address(_getAccountStorage().preValidationHookERC4337);\n    }\n\n    /// @dev Calls the pre-validation hook for ERC-1271.\n    /// @param hash The hash of the user operation.\n    /// @param signature The signature to validate.\n    /// @return postHash The updated hash after the pre-validation hook.\n    /// @return postSig The updated signature after the pre-validation hook.\n    function _withPreValidationHook(\n        bytes32 hash,\n        bytes calldata signature\n    )\n        internal\n        view\n        virtual\n        returns (bytes32 postHash, bytes memory postSig)\n    {\n        // Get the pre-validation hook for ERC-1271\n        address preValidationHook = _getPreValidationHook(MODULE_TYPE_PREVALIDATION_HOOK_ERC1271);\n        // If no pre-validation hook is installed, return the original hash and signature\n        if (preValidationHook == address(0)) {\n            return (hash, signature);\n        }\n        // Otherwise, call the pre-validation hook and return the updated hash and signature\n        else {\n            return IPreValidationHookERC1271(preValidationHook).preValidationHookERC1271(msg.sender, hash, signature);\n        }\n    }\n\n    /// @notice Checks if an enable mode signature is valid.\n    /// @param structHash data hash.\n    /// @param sig Signature.\n    /// @param validator Validator address.\n    function _checkEnableModeSignature(\n        bytes32 structHash,\n        bytes calldata sig,\n        address validator\n    )\n        internal\n        view\n        returns (bool)\n    {\n        bytes32 eip712Digest = _hashTypedData(structHash);\n        // Use standard IERC-1271/ERC-7739 interface.\n        // Even if the validator doesn't support 7739 under the hood, it is still secure,\n        // as eip712digest is already built based on 712Domain of this Smart Account\n        // This interface should always be exposed by validators as per ERC-7579\n        try IValidator(validator).isValidSignatureWithSender(address(this), eip712Digest, sig) returns (bytes4 res) {\n            return res == ERC1271_SUCCESS;\n        } catch {\n            return false;\n        }\n    }\n\n    /// @notice Checks if a module is installed on the smart account.\n    /// @param moduleTypeId The module type ID.\n    /// @param module The module address.\n    /// @param additionalContext Additional context for checking installation.\n    /// @return True if the module is installed, false otherwise.\n    function _isModuleInstalled(\n        uint256 moduleTypeId,\n        address module,\n        bytes calldata additionalContext\n    )\n        internal\n        view\n        returns (bool)\n    {\n        additionalContext;\n        if (moduleTypeId == MODULE_TYPE_VALIDATOR) {\n            return _isValidatorInstalled(module);\n        } else if (moduleTypeId == MODULE_TYPE_EXECUTOR) {\n            return _isExecutorInstalled(module);\n        } else if (moduleTypeId == MODULE_TYPE_FALLBACK) {\n            bytes4 selector;\n            if (additionalContext.length >= 4) {\n                selector = bytes4(additionalContext[0:4]);\n            } else {\n                selector = bytes4(0x00000000);\n            }\n            return _isFallbackHandlerInstalled(selector, module);\n        } else if (moduleTypeId == MODULE_TYPE_HOOK) {\n            return _isHookInstalled(module);\n        } else if (_isPrevalidationHookType(moduleTypeId)) {\n            return _getPreValidationHook(moduleTypeId) == module;\n        } else {\n            return false;\n        }\n    }\n\n    /// @dev Does bytecode optimized check of the module type id being a pre-validation hook type.\n    /// @param moduleTypeId The module type id to check.\n    /// return True if the module type id is a pre-validation hook type, otherwise false.\n    /// If theType == 8: 8 - 8 = 0, and 0 < 2 ✓\n    /// If theType == 9: 9 - 8 = 1, and 1 < 2 ✓\n    /// If theType < 8 (e.g., 7): 7 - 8 = type(uint256).max (wraps), and type(uint256).max < 2 is false ✓\n    /// If theType >= 10: result is >= 2, and fails the check ✓\n    function _isPrevalidationHookType(uint256 moduleTypeId) internal pure returns (bool res) {\n        assembly {\n            res := lt(sub(moduleTypeId, 8), 2)\n        }\n    }\n\n    /// @dev Checks if the validator list is already initialized.\n    ///      In theory it doesn't 100% mean there is a validator or executor installed.\n    ///      Use below functions to check for validators and executors.\n    function _areSentinelListsInitialized() internal view virtual returns (bool) {\n        // account module storage\n        AccountStorage storage ams = _getAccountStorage();\n        return ams.validators.alreadyInitialized() && ams.executors.alreadyInitialized();\n    }\n\n    /// @dev Checks if a fallback handler is set for a given selector.\n    /// @param selector The function selector to check.\n    /// @return True if a fallback handler is set, otherwise false.\n    function _isFallbackHandlerInstalled(bytes4 selector) internal view virtual returns (bool) {\n        FallbackHandler storage handler = _getAccountStorage().fallbacks[selector];\n        return handler.handler != address(0);\n    }\n\n    /// @dev Checks if the expected fallback handler is installed for a given selector.\n    /// @param selector The function selector to check.\n    /// @param expectedHandler The address of the handler expected to be installed.\n    /// @return True if the installed handler matches the expected handler, otherwise false.\n    function _isFallbackHandlerInstalled(bytes4 selector, address expectedHandler) internal view returns (bool) {\n        FallbackHandler storage handler = _getAccountStorage().fallbacks[selector];\n        return handler.handler == expectedHandler;\n    }\n\n    /// @dev Checks if a validator is currently installed.\n    /// @param validator The address of the validator to check.\n    /// @return True if the validator is installed, otherwise false.\n    function _isValidatorInstalled(address validator) internal view virtual returns (bool) {\n        return _getAccountStorage().validators.contains(validator);\n    }\n\n    /// @dev Checks if an executor is currently installed.\n    /// @param executor The address of the executor to check.\n    /// @return True if the executor is installed, otherwise false.\n    function _isExecutorInstalled(address executor) internal view virtual returns (bool) {\n        return _getAccountStorage().executors.contains(executor);\n    }\n\n    /// @dev Checks if a hook is currently installed.\n    /// @param hook The address of the hook to check.\n    /// @return True if the hook is installed, otherwise false.\n    function _isHookInstalled(address hook) internal view returns (bool) {\n        return _getHook() == hook;\n    }\n\n    /// @dev Retrieves the current hook from the storage.\n    /// @return hook The address of the current hook.\n    function _getHook() internal view returns (address hook) {\n        hook = address(_getAccountStorage().hook);\n    }\n\n    /// @dev Checks if the account is an ERC7702 account\n    function _amIERC7702() internal view returns (bool res) {\n        assembly {\n            // use extcodesize as the first cheapest check\n            if eq(extcodesize(address()), 23) {\n                // use extcodecopy to copy first 3 bytes of this contract and compare with 0xef0100\n                extcodecopy(address(), 0, 0, 3)\n                res := eq(0xef0100, shr(232, mload(0x00)))\n            }\n            // if it is not 23, we do not even check the first 3 bytes\n        }\n    }\n\n    /// @dev Returns the validator address to use\n    function _handleValidator(address _validator) internal view returns (address validator) {\n        if (_validator == address(0)) {\n            validator = _DEFAULT_VALIDATOR;\n        } else {\n            if (!_isValidatorInstalled(_validator)) {\n                assembly {\n                    // revert ValidatorNotInstalled(address)\n                    mstore(0x00, 0x6859e01e)\n                    mstore(0x20, _validator)\n                    revert(0x1c, 0x24)\n                }\n            }\n            validator = _validator;\n        }\n    }\n\n    /// @notice Builds the enable mode data hash as per eip712\n    /// @param module Module being enabled\n    /// @param moduleType Type of the module as per EIP-7579\n    /// @param userOpHash Hash of the User Operation\n    /// @param initData Module init data.\n    /// @return structHash data hash\n    function _getEnableModeDataHash(\n        address module,\n        uint256 moduleType,\n        bytes32 userOpHash,\n        bytes calldata initData\n    )\n        internal\n        pure\n        returns (bytes32)\n    {\n        return keccak256(abi.encode(MODULE_ENABLE_MODE_TYPE_HASH, module, moduleType, userOpHash, keccak256(initData)));\n    }\n\n    function _fallback(bytes calldata callData) private {\n        bool success;\n        bytes memory result;\n        FallbackHandler storage $fallbackHandler = _getAccountStorage().fallbacks[msg.sig];\n        address handler = $fallbackHandler.handler;\n        CallType calltype = $fallbackHandler.calltype;\n\n        if (handler != address(0)) {\n            // hook manually\n            address hook = _getHook();\n            bytes memory hookData;\n            if (hook != address(0)) {\n                hookData = IHook(hook).preCheck(msg.sender, msg.value, msg.data);\n            }\n            //if there's a fallback handler, call it\n            if (calltype == CALLTYPE_STATIC) {\n                (success, result) = handler.staticcall(ExecLib.get2771CallData(callData));\n            } else if (calltype == CALLTYPE_SINGLE) {\n                (success, result) = handler.call{ value: msg.value }(ExecLib.get2771CallData(callData));\n            } else {\n                revert UnsupportedCallType(calltype);\n            }\n\n            // Use revert message from fallback handler if the call was not successful\n            assembly {\n                if iszero(success) { revert(add(result, 0x20), mload(result)) }\n            }\n\n            // hook post check\n            if (hook != address(0)) {\n                IHook(hook).postCheck(hookData);\n            }\n\n            // return the result\n            assembly {\n                return(add(result, 0x20), mload(result))\n            }\n        }\n\n        // If there's no handler, the call can be one of onERCXXXReceived()\n        // No need to hook this as no execution is done here\n        bytes32 s;\n        /// @solidity memory-safe-assembly\n        assembly {\n            s := shr(224, calldataload(0))\n            // 0x150b7a02: `onERC721Received(address,address,uint256,bytes)`.\n            // 0xf23a6e61: `onERC1155Received(address,address,uint256,uint256,bytes)`.\n            // 0xbc197c81: `onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)`.\n            if or(eq(s, 0x150b7a02), or(eq(s, 0xf23a6e61), eq(s, 0xbc197c81))) {\n                mstore(0x20, s) // Store `msg.sig`.\n                return(0x3c, 0x20) // Return `msg.sig`.\n            }\n            mstore(0x00, 0x08c63e27)\n            mstore(0x20, shl(224, s)) // Left-align bytes4 for ABI encoding\n            revert(0x1c, 0x24) // revert MissingFallbackHandler(msg.sig)\n        }\n    }\n\n    /// @dev Helper function to paginate entries in a SentinelList.\n    /// @param list The SentinelList to paginate.\n    /// @param cursor The cursor to start paginating from.\n    /// @param size The number of entries to return.\n    /// @return array The array of addresses in the list.\n    /// @return nextCursor The cursor for the next page of entries.\n    function _paginate(\n        SentinelListLib.SentinelList storage list,\n        address cursor,\n        uint256 size\n    )\n        private\n        view\n        returns (address[] memory array, address nextCursor)\n    {\n        (array, nextCursor) = list.getEntriesPaginated(cursor, size);\n    }\n}\n"},"contracts/nexus/base/ExecutionHelper.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\n// ──────────────────────────────────────────────────────────────────────────────\n//     _   __    _  __\n//    / | / /__ | |/ /_  _______\n//   /  |/ / _ \\|   / / / / ___/\n//  / /|  /  __/   / /_/ (__  )\n// /_/ |_/\\___/_/|_\\__,_/____/\n//\n// ──────────────────────────────────────────────────────────────────────────────\n// Nexus: A suite of contracts for Modular Smart Accounts compliant with ERC-7579 and ERC-4337, developed by Biconomy.\n// Learn more at https://biconomy.io. To report security issues, please contact us at: security@biconomy.io\n\nimport { Execution } from \"erc7579/interfaces/IERC7579Account.sol\";\nimport { IExecutionHelperEventsAndErrors } from \"../../interfaces/nexus/base/IExecutionHelper.sol\";\nimport { ExecType, EXECTYPE_DEFAULT, EXECTYPE_TRY } from \"../../lib/erc-7579/ModeLib.sol\";\nimport { ExecLib } from \"../../lib/erc-7579/ExecLib.sol\";\n\n/// @title Nexus - ExecutionHelper\n/// @notice Implements execution management within the Nexus suite, facilitating transaction execution strategies and\n/// error handling.\n/// @dev Provides mechanisms for direct and batched transactions with both committed and tentative execution strategies\n/// as per ERC-4337 and ERC-7579 standards.\n/// @author @livingrockrises | Biconomy | chirag@biconomy.io\n/// @author @aboudjem | Biconomy | adam.boudjemaa@biconomy.io\n/// @author @filmakarov | Biconomy | filipp.makarov@biconomy.io\n/// @author @zeroknots | Rhinestone.wtf | zeroknots.eth\n/// Special thanks to the Solady team for foundational contributions: https://github.com/Vectorized/solady\ncontract ExecutionHelper is IExecutionHelperEventsAndErrors {\n    using ExecLib for bytes;\n\n    /// @notice Executes a call to a target address with specified value and data.\n    /// @notice calls to an EOA should be counted as successful.\n    /// @param target The address to execute the call on.\n    /// @param value The amount of wei to send with the call.\n    /// @param callData The calldata to send.\n    /// @return result The bytes returned from the execution, which contains the returned data from the target address.\n    function _execute(\n        address target,\n        uint256 value,\n        bytes calldata callData\n    )\n        internal\n        virtual\n        returns (bytes memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            calldatacopy(result, callData.offset, callData.length)\n            if iszero(call(gas(), target, value, result, callData.length, codesize(), 0x00)) {\n                // Bubble up the revert if the call reverts.\n                returndatacopy(result, 0x00, returndatasize())\n                revert(result, returndatasize())\n            }\n            mstore(result, returndatasize()) // Store the length.\n            let o := add(result, 0x20)\n            returndatacopy(o, 0x00, returndatasize()) // Copy the returndata.\n            mstore(0x40, add(o, returndatasize())) // Allocate the memory.\n        }\n    }\n\n    /// @notice Executes a call to a target address with specified value and data.\n    /// same as _execute, but callData can be in memory\n    function _executeMemory(\n        address target,\n        uint256 value,\n        bytes memory callData\n    )\n        internal\n        virtual\n        returns (bytes memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            if iszero(call(gas(), target, value, add(callData, 0x20), mload(callData), codesize(), 0x00)) {\n                // Bubble up the revert if the call reverts.\n                returndatacopy(result, 0x00, returndatasize())\n                revert(result, returndatasize())\n            }\n            mstore(result, returndatasize()) // Store the length.\n            let o := add(result, 0x20)\n            returndatacopy(o, 0x00, returndatasize()) // Copy the returndata.\n            mstore(0x40, add(o, returndatasize())) // Allocate the memory.\n        }\n    }\n\n    /// @notice Executes a call to a target address with specified value and data.\n    /// Same as _execute but without return data for gas optimization.\n    function _executeNoReturndata(address target, uint256 value, bytes calldata callData) internal virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let result := mload(0x40)\n            calldatacopy(result, callData.offset, callData.length)\n            if iszero(call(gas(), target, value, result, callData.length, codesize(), 0x00)) {\n                // Bubble up the revert if the call reverts.\n                returndatacopy(result, 0x00, returndatasize())\n                revert(result, returndatasize())\n            }\n            mstore(0x40, add(result, callData.length)) //allocate memory\n        }\n    }\n\n    /// @notice Tries to execute a call and captures if it was successful or not.\n    /// @dev Similar to _execute but returns a success boolean and catches reverts instead of propagating them.\n    /// @notice calls to an EOA should be counted as successful.\n    /// @param target The address to execute the call on.\n    /// @param value The amount of wei to send with the call.\n    /// @param callData The calldata to send.\n    /// @return success True if the execution was successful, false otherwise.\n    /// @return result The bytes returned from the execution, which contains the returned data from the target address.\n    function _tryExecute(\n        address target,\n        uint256 value,\n        bytes calldata callData\n    )\n        internal\n        virtual\n        returns (bool success, bytes memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            calldatacopy(result, callData.offset, callData.length)\n            success := call(gas(), target, value, result, callData.length, codesize(), 0x00)\n            mstore(result, returndatasize()) // Store the length.\n            let o := add(result, 0x20)\n            returndatacopy(o, 0x00, returndatasize()) // Copy the returndata.\n            mstore(0x40, add(o, returndatasize())) // Allocate the memory.\n        }\n    }\n\n    /// @notice Executes a batch of calls.\n    /// @param executions An array of Execution structs each containing target, value, and calldata.\n    /// @return result An array of bytes returned from each executed call, corresponding to the returndata from each\n    /// target\n    /// address.\n    function _executeBatch(Execution[] calldata executions) internal returns (bytes[] memory result) {\n        result = new bytes[](executions.length);\n\n        Execution calldata exec;\n        for (uint256 i; i < executions.length; i++) {\n            exec = executions[i];\n            result[i] = _execute(exec.target, exec.value, exec.callData);\n        }\n    }\n\n    /// @notice Executes a batch of calls without returning the result.\n    /// @param executions An array of Execution structs each containing target, value, and calldata.\n    function _executeBatchNoReturndata(Execution[] calldata executions) internal {\n        Execution calldata exec;\n        for (uint256 i; i < executions.length; i++) {\n            exec = executions[i];\n            _executeNoReturndata(exec.target, exec.value, exec.callData);\n        }\n    }\n\n    /// @notice Tries to execute a batch of calls and emits an event for each unsuccessful call.\n    /// @param executions An array of Execution structs.\n    /// @return result An array of bytes returned from each executed call, with unsuccessful calls marked by events.\n    function _tryExecuteBatch(Execution[] calldata executions) internal returns (bytes[] memory result) {\n        result = new bytes[](executions.length);\n\n        Execution calldata exec;\n        for (uint256 i; i < executions.length; i++) {\n            exec = executions[i];\n            bool success;\n            (success, result[i]) = _tryExecute(exec.target, exec.value, exec.callData);\n            if (!success) emit TryExecuteUnsuccessful(exec.callData, result[i]);\n        }\n    }\n\n    /// @dev Execute a delegatecall with `delegate` on this account.\n    /// @return result The bytes returned from the delegatecall, which contains the returned data from the delegate\n    /// contract.\n    function _executeDelegatecall(address delegate, bytes calldata callData) internal returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            calldatacopy(result, callData.offset, callData.length)\n            // Forwards the `data` to `delegate` via delegatecall.\n            if iszero(delegatecall(gas(), delegate, result, callData.length, codesize(), 0x00)) {\n                // Bubble up the revert if the call reverts.\n                returndatacopy(result, 0x00, returndatasize())\n                revert(result, returndatasize())\n            }\n            mstore(result, returndatasize()) // Store the length.\n            let o := add(result, 0x20)\n            returndatacopy(o, 0x00, returndatasize()) // Copy the returndata.\n            mstore(0x40, add(o, returndatasize())) // Allocate the memory.\n        }\n    }\n\n    /// @dev Execute a delegatecall with `delegate` on this account.\n    /// Same as _executeDelegatecall but without return data for gas optimization.\n    function _executeDelegatecallNoReturndata(address delegate, bytes calldata callData) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let result := mload(0x40)\n            calldatacopy(result, callData.offset, callData.length)\n            if iszero(delegatecall(gas(), delegate, result, callData.length, codesize(), 0x00)) {\n                // Bubble up the revert if the call reverts.\n                returndatacopy(result, 0x00, returndatasize())\n                revert(result, returndatasize())\n            }\n            mstore(0x40, add(result, callData.length)) //allocate memory\n        }\n    }\n\n    /// @dev Execute a delegatecall with `delegate` on this account and catch reverts.\n    /// @return success True if the delegatecall was successful, false otherwise.\n    /// @return result The bytes returned from the delegatecall, which contains the returned data from the delegate\n    /// contract.\n    function _tryExecuteDelegatecall(\n        address delegate,\n        bytes calldata callData\n    )\n        internal\n        returns (bool success, bytes memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            calldatacopy(result, callData.offset, callData.length)\n            // Forwards the `data` to `delegate` via delegatecall.\n            success := delegatecall(gas(), delegate, result, callData.length, codesize(), 0x00)\n            mstore(result, returndatasize()) // Store the length.\n            let o := add(result, 0x20)\n            returndatacopy(o, 0x00, returndatasize()) // Copy the returndata.\n            mstore(0x40, add(o, returndatasize())) // Allocate the memory.\n        }\n    }\n\n    /// @dev Executes a single transaction based on the specified execution type.\n    /// @param executionCalldata The calldata containing the transaction details (target address, value, and data).\n    /// @param execType The execution type, which can be DEFAULT (revert on failure) or TRY (return on failure).\n    function _handleSingleExecution(bytes calldata executionCalldata, ExecType execType) internal {\n        (address target, uint256 value, bytes calldata callData) = executionCalldata.decodeSingle();\n        if (execType == EXECTYPE_DEFAULT) {\n            _executeNoReturndata(target, value, callData);\n        } else if (execType == EXECTYPE_TRY) {\n            (bool success, bytes memory result) = _tryExecute(target, value, callData);\n            if (!success) emit TryExecuteUnsuccessful(callData, result);\n        } else {\n            revert UnsupportedExecType(execType);\n        }\n    }\n\n    /// @dev Executes a batch of transactions based on the specified execution type.\n    /// @param executionCalldata The calldata for a batch of transactions.\n    /// @param execType The execution type, which can be DEFAULT (revert on failure) or TRY (return on failure).\n    function _handleBatchExecution(bytes calldata executionCalldata, ExecType execType) internal {\n        Execution[] calldata executions = executionCalldata.decodeBatch();\n        if (execType == EXECTYPE_DEFAULT) _executeBatchNoReturndata(executions);\n        else if (execType == EXECTYPE_TRY) _tryExecuteBatch(executions);\n        else revert UnsupportedExecType(execType);\n    }\n\n    /// @dev Executes a single transaction based on the specified execution type.\n    /// @param executionCalldata The calldata containing the transaction details (target address, value, and data).\n    /// @param execType The execution type, which can be DEFAULT (revert on failure) or TRY (return on failure).\n    function _handleDelegateCallExecution(bytes calldata executionCalldata, ExecType execType) internal {\n        (address delegate, bytes calldata callData) = executionCalldata.decodeDelegateCall();\n        if (execType == EXECTYPE_DEFAULT) {\n            _executeDelegatecallNoReturndata(delegate, callData);\n        } else if (execType == EXECTYPE_TRY) {\n            (bool success, bytes memory result) = _tryExecuteDelegatecall(delegate, callData);\n            if (!success) emit TryDelegateCallUnsuccessful(callData, result);\n        } else {\n            revert UnsupportedExecType(execType);\n        }\n    }\n\n    /// @dev Executes a single transaction based on the specified execution type.\n    /// @param executionCalldata The calldata containing the transaction details (target address, value, and data).\n    /// @param execType The execution type, which can be DEFAULT (revert on failure) or TRY (return on failure).\n    /// @return returnData An array containing the execution result. In the case of a single transaction, the array\n    /// contains one element.\n    function _handleSingleExecutionAndReturnData(\n        bytes calldata executionCalldata,\n        ExecType execType\n    )\n        internal\n        returns (bytes[] memory returnData)\n    {\n        (address target, uint256 value, bytes calldata callData) = executionCalldata.decodeSingle();\n        returnData = new bytes[](1);\n        bool success;\n        // check if execType is revert(default) or try\n        if (execType == EXECTYPE_DEFAULT) {\n            returnData[0] = _execute(target, value, callData);\n        } else if (execType == EXECTYPE_TRY) {\n            (success, returnData[0]) = _tryExecute(target, value, callData);\n            if (!success) emit TryExecuteUnsuccessful(callData, returnData[0]);\n        } else {\n            revert UnsupportedExecType(execType);\n        }\n    }\n\n    /// @dev Executes a batch of transactions based on the specified execution type.\n    /// @param executionCalldata The calldata for a batch of transactions.\n    /// @param execType The execution type, which can be DEFAULT (revert on failure) or TRY (return on failure).\n    /// @return returnData An array containing the execution results for each transaction in the batch.\n    function _handleBatchExecutionAndReturnData(\n        bytes calldata executionCalldata,\n        ExecType execType\n    )\n        internal\n        returns (bytes[] memory returnData)\n    {\n        Execution[] calldata executions = executionCalldata.decodeBatch();\n        if (execType == EXECTYPE_DEFAULT) returnData = _executeBatch(executions);\n        else if (execType == EXECTYPE_TRY) returnData = _tryExecuteBatch(executions);\n        else revert UnsupportedExecType(execType);\n    }\n\n    /// @dev Executes a single transaction based on the specified execution type.\n    /// @param executionCalldata The calldata containing the transaction details (target address, value, and data).\n    /// @param execType The execution type, which can be DEFAULT (revert on failure) or TRY (return on failure).\n    /// @return returnData An array containing the result of the delegatecall execution.\n    function _handleDelegateCallExecutionAndReturnData(\n        bytes calldata executionCalldata,\n        ExecType execType\n    )\n        internal\n        returns (bytes[] memory returnData)\n    {\n        (address delegate, bytes calldata callData) = executionCalldata.decodeDelegateCall();\n        returnData = new bytes[](1);\n        bool success;\n        if (execType == EXECTYPE_DEFAULT) {\n            returnData[0] = _executeDelegatecall(delegate, callData);\n        } else if (execType == EXECTYPE_TRY) {\n            (success, returnData[0]) = _tryExecuteDelegatecall(delegate, callData);\n            if (!success) emit TryDelegateCallUnsuccessful(callData, returnData[0]);\n        } else {\n            revert UnsupportedExecType(execType);\n        }\n    }\n}\n"},"contracts/composability/ComposableExecutionBase.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\nimport { ComposableExecutionLib } from \"./ComposableExecutionLib.sol\";\nimport { InputParam, OutputParam, ComposableExecution } from \"../types/ComposabilityDataTypes.sol\";\nimport { IComposableExecution } from \"../interfaces/IComposableExecution.sol\";\nimport { Execution } from \"erc7579/interfaces/IERC7579Account.sol\";\n\nabstract contract ComposableExecutionBase is IComposableExecution {\n    using ComposableExecutionLib for InputParam[];\n    using ComposableExecutionLib for OutputParam[];\n\n    /// @dev Override it in the account and introduce additional access control or other checks\n    function executeComposable(ComposableExecution[] calldata cExecutions) external payable virtual;\n\n    /// @dev internal function to execute the composable execution flow\n    /// First, processes the input parameters and returns the composed calldata\n    /// Then, executes the action\n    /// Then, processes the output parameters\n    function _executeComposable(ComposableExecution[] calldata cExecutions) internal {\n        uint256 length = cExecutions.length;\n        for (uint256 i; i < length; i++) {\n            ComposableExecution calldata cExecution = cExecutions[i];\n            Execution memory execution = cExecution.inputParams.processInputs(cExecution.functionSig);\n            bytes memory returnData;\n            if (execution.target != address(0)) {\n                returnData = _executeAction(execution.target, execution.value, execution.callData);\n            } else {\n                returnData = new bytes(0);\n            }\n            // TODO: add early sanity check that output params length is > 0\n            // so if it is 0, we can not even call processOutputs\n            cExecution.outputParams.processOutputs(returnData, address(this));\n        }\n    }\n\n    /// @dev Override this in the account\n    /// using account's native execution approach\n    /// we do not use Execution struct as an argument to be as less opinionated as possible\n    /// instead we just use standard types\n    function _executeAction(\n        address to,\n        uint256 value,\n        bytes memory data\n    )\n        internal\n        virtual\n        returns (bytes memory returnData);\n}\n"},"contracts/lib/nexus/Initializable.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\n// keccak256(abi.encode(uint256(keccak256(\"initializable.transient.Nexus\")) - 1)) & ~bytes32(uint256(0xff));\nbytes32 constant INIT_SLOT = 0x90b772c2cb8a51aa7a8a65fc23543c6d022d5b3f8e2b92eed79fba7eef829300;\n\n/// @title Initializable\n/// @dev This library provides a way to set a transient flag on a contract to ensure that it is only initialized during\n/// the\n/// constructor execution. This is useful to prevent a contract from being initialized multiple times.\nlibrary Initializable {\n    /// @dev Thrown when an attempt to initialize an already initialized contract is made\n    error NotInitializable();\n\n    /// @dev Sets the initializable flag in the transient storage slot to true\n    function setInitializable() internal {\n        bytes32 slot = INIT_SLOT;\n        assembly {\n            tstore(slot, 0x01)\n        }\n    }\n\n    /// @dev Checks if the initializable flag is set in the transient storage slot, reverts with NotInitializable if not\n    function requireInitializable() internal view {\n        bytes32 slot = INIT_SLOT;\n        // Load the current value from the slot, revert if 0\n        assembly {\n            let isInitializable := tload(slot)\n            if iszero(isInitializable) {\n                mstore(0x0, 0xaed59595) // NotInitializable()\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n}\n"},"node_modules/solady/src/utils/UUPSUpgradeable.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport {CallContextChecker} from \"./CallContextChecker.sol\";\n\n/// @notice UUPS proxy mixin.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/UUPSUpgradeable.sol)\n/// @author Modified from OpenZeppelin\n/// (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/proxy/utils/UUPSUpgradeable.sol)\n///\n/// @dev Note:\n/// - This implementation is intended to be used with ERC1967 proxies.\n/// See: `LibClone.deployERC1967` and related functions.\n/// - This implementation is NOT compatible with legacy OpenZeppelin proxies\n/// which do not store the implementation at `_ERC1967_IMPLEMENTATION_SLOT`.\nabstract contract UUPSUpgradeable is CallContextChecker {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The upgrade failed.\n    error UpgradeFailed();\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                           EVENTS                           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Emitted when the proxy's implementation is upgraded.\n    event Upgraded(address indexed implementation);\n\n    /// @dev `keccak256(bytes(\"Upgraded(address)\"))`.\n    uint256 private constant _UPGRADED_EVENT_SIGNATURE =\n        0xbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                          STORAGE                           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The ERC-1967 storage slot for the implementation in the proxy.\n    /// `uint256(keccak256(\"eip1967.proxy.implementation\")) - 1`.\n    bytes32 internal constant _ERC1967_IMPLEMENTATION_SLOT =\n        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                      UUPS OPERATIONS                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Please override this function to check if `msg.sender` is authorized\n    /// to upgrade the proxy to `newImplementation`, reverting if not.\n    /// ```\n    ///     function _authorizeUpgrade(address) internal override onlyOwner {}\n    /// ```\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n\n    /// @dev Returns the storage slot used by the implementation,\n    /// as specified in [ERC1822](https://eips.ethereum.org/EIPS/eip-1822).\n    ///\n    /// Note: The `notDelegated` modifier prevents accidental upgrades to\n    /// an implementation that is a proxy contract.\n    function proxiableUUID() public view virtual notDelegated returns (bytes32) {\n        // This function must always return `_ERC1967_IMPLEMENTATION_SLOT` to comply with ERC1967.\n        return _ERC1967_IMPLEMENTATION_SLOT;\n    }\n\n    /// @dev Upgrades the proxy's implementation to `newImplementation`.\n    /// Emits a {Upgraded} event.\n    ///\n    /// Note: Passing in empty `data` skips the delegatecall to `newImplementation`.\n    function upgradeToAndCall(address newImplementation, bytes calldata data)\n        public\n        payable\n        virtual\n        onlyProxy\n    {\n        _authorizeUpgrade(newImplementation);\n        /// @solidity memory-safe-assembly\n        assembly {\n            newImplementation := shr(96, shl(96, newImplementation)) // Clears upper 96 bits.\n            mstore(0x00, returndatasize())\n            mstore(0x01, 0x52d1902d) // `proxiableUUID()`.\n            let s := _ERC1967_IMPLEMENTATION_SLOT\n            // Check if `newImplementation` implements `proxiableUUID` correctly.\n            if iszero(eq(mload(staticcall(gas(), newImplementation, 0x1d, 0x04, 0x01, 0x20)), s)) {\n                mstore(0x01, 0x55299b49) // `UpgradeFailed()`.\n                revert(0x1d, 0x04)\n            }\n            // Emit the {Upgraded} event.\n            log2(codesize(), 0x00, _UPGRADED_EVENT_SIGNATURE, newImplementation)\n            sstore(s, newImplementation) // Updates the implementation.\n\n            // Perform a delegatecall to `newImplementation` if `data` is non-empty.\n            if data.length {\n                // Forwards the `data` to `newImplementation` via delegatecall.\n                let m := mload(0x40)\n                calldatacopy(m, data.offset, data.length)\n                if iszero(\n                    delegatecall(gas(), newImplementation, m, data.length, codesize(), 0x00)\n                ) {\n                    // Bubble up the revert if the call reverts.\n                    returndatacopy(m, 0x00, returndatasize())\n                    revert(m, returndatasize())\n                }\n            }\n        }\n    }\n}\n"},"contracts/interfaces/nexus/INexus.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\n// ──────────────────────────────────────────────────────────────────────────────\n//     _   __    _  __\n//    / | / /__ | |/ /_  _______\n//   /  |/ / _ \\|   / / / / ___/\n//  / /|  /  __/   / /_/ (__  )\n// /_/ |_/\\___/_/|_\\__,_/____/\n//\n// ──────────────────────────────────────────────────────────────────────────────\n// Nexus: A suite of contracts for Modular Smart Accounts compliant with ERC-7579 and ERC-4337, developed by Biconomy.\n// Learn more at https://biconomy.io. To report security issues, please contact us at: security@biconomy.io\n\nimport { IAccountConfig } from \"./base/IAccountConfig.sol\";\nimport { IExecutionHelper } from \"./base/IExecutionHelper.sol\";\nimport { INexusEventsAndErrors } from \"./INexusEventsAndErrors.sol\";\nimport { IERC1271 } from \"../standard/IERC1271.sol\";\nimport { IAccount } from \"account-abstraction/interfaces/IAccount.sol\";\n\n/// @title Nexus - INexus Interface\n/// @notice Integrates ERC-4337 and ERC-7579 standards to manage smart accounts within the Nexus suite.\n/// @dev Consolidates ERC-4337 user operations and ERC-7579 configurations into a unified interface for smart account\n/// management.\n/// It extends both IERC4337Account and IERC7579Account, enhancing modular capabilities and supporting advanced contract\n/// architectures.\n/// Includes error definitions for robust handling of common issues such as unsupported module types and execution\n/// failures.\n/// The initialize function sets up the account with validators and configurations, ensuring readiness for use.\n/// @author @livingrockrises | Biconomy | chirag@biconomy.io\n/// @author @aboudjem | Biconomy | adam.boudjemaa@biconomy.io\n/// @author @filmakarov | Biconomy | filipp.makarov@biconomy.io\n/// @author @zeroknots | Rhinestone.wtf | zeroknots.eth\n/// Special thanks to the Solady team for foundational contributions: https://github.com/Vectorized/solady\ninterface INexus is IAccountConfig, IExecutionHelper, IERC1271, IAccount, INexusEventsAndErrors {\n    /// @notice Initializes the smart account with a validator and custom data.\n    /// @dev This method sets up the account for operation, linking it with a validator and initializing it with\n    /// specific\n    /// data.\n    /// Can be called directly or via a factory.\n    /// @param initData Encoded data used for the account's configuration during initialization.\n    function initializeAccount(bytes calldata initData) external payable;\n}\n"},"contracts/lib/erc-7579/ExecLib.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\nimport { Execution } from \"erc7579/interfaces/IERC7579Account.sol\";\n\n/// @title ExecutionLib\n/// @author zeroknots.eth | rhinestone.wtf\n/// Helper Library for decoding Execution calldata\n/// malloc for memory allocation is bad for gas. use this assembly instead\nlibrary ExecLib {\n    function get2771CallData(bytes calldata cd) internal view returns (bytes memory callData) {\n        /// @solidity memory-safe-assembly\n        (cd);\n        assembly {\n            // as per solidity docs\n            function allocate(length) -> pos {\n                pos := mload(0x40)\n                mstore(0x40, add(pos, length))\n            }\n\n            callData := allocate(add(calldatasize(), 0x20)) //allocate extra 0x20 to store length\n            mstore(callData, add(calldatasize(), 0x14)) //store length, extra 0x14 is for msg.sender address\n            calldatacopy(add(callData, 0x20), 0, calldatasize())\n\n            // The msg.sender address is shifted to the left by 12 bytes to remove the padding\n            // Then the address without padding is stored right after the calldata\n            let senderPtr := allocate(0x14)\n            mstore(senderPtr, shl(96, caller()))\n        }\n    }\n\n    /**\n     * @notice Decode a batch of `Execution` executionBatch from a `bytes` calldata.\n     * @dev code is copied from solady's LibERC7579.sol\n     * https://github.com/Vectorized/solady/blob/740812cedc9a1fc11e17cb3d4569744367dedf19/src/accounts/LibERC7579.sol#L146\n     *      Credits to Vectorized and the Solady Team\n     */\n    function decodeBatch(bytes calldata executionCalldata) internal pure returns (Execution[] calldata executionBatch) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let u := calldataload(executionCalldata.offset)\n            let s := add(executionCalldata.offset, u)\n            let e := sub(add(executionCalldata.offset, executionCalldata.length), 0x20)\n            executionBatch.offset := add(s, 0x20)\n            executionBatch.length := calldataload(s)\n            if or(shr(64, u), gt(add(s, shl(5, executionBatch.length)), e)) {\n                mstore(0x00, 0xba597e7e) // `DecodingError()`.\n                revert(0x1c, 0x04)\n            }\n            if executionBatch.length {\n                // Perform bounds checks on the decoded `executionBatch`.\n                // Loop runs out-of-gas if `executionBatch.length` is big enough to cause overflows.\n                for { let i := executionBatch.length } 1 { } {\n                    i := sub(i, 1)\n                    let p := calldataload(add(executionBatch.offset, shl(5, i)))\n                    let c := add(executionBatch.offset, p)\n                    let q := calldataload(add(c, 0x40))\n                    let o := add(c, q)\n                    // forgefmt: disable-next-item\n                    if or(shr(64, or(calldataload(o), or(p, q))),\n                        or(gt(add(c, 0x40), e), gt(add(o, calldataload(o)), e))) {\n                        mstore(0x00, 0xba597e7e) // `DecodingError()`.\n                        revert(0x1c, 0x04)\n                    }\n                    if iszero(i) { break }\n                }\n            }\n        }\n    }\n\n    function encodeBatch(Execution[] memory executions) internal pure returns (bytes memory callData) {\n        callData = abi.encode(executions);\n    }\n\n    function decodeSingle(bytes calldata executionCalldata)\n        internal\n        pure\n        returns (address target, uint256 value, bytes calldata callData)\n    {\n        target = address(bytes20(executionCalldata[0:20]));\n        value = uint256(bytes32(executionCalldata[20:52]));\n        callData = executionCalldata[52:];\n    }\n\n    function decodeDelegateCall(bytes calldata executionCalldata)\n        internal\n        pure\n        returns (address delegate, bytes calldata callData)\n    {\n        // destructure executionCallData according to single exec\n        delegate = address(uint160(bytes20(executionCalldata[0:20])));\n        callData = executionCalldata[20:];\n    }\n\n    function encodeSingle(\n        address target,\n        uint256 value,\n        bytes memory callData\n    )\n        internal\n        pure\n        returns (bytes memory userOpCalldata)\n    {\n        userOpCalldata = abi.encodePacked(target, value, callData);\n    }\n}\n"},"contracts/lib/nexus/NonceLib.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\n// solhint-disable-next-line no-unused-import\nimport { MODE_MODULE_ENABLE, MODE_PREP, MODE_VALIDATION } from \"../../types/Constants.sol\";\n\n/**\n * Nonce structure\n *     [3 bytes empty][1 bytes validation mode][20 bytes validator][8 bytes nonce]\n */\nlibrary NonceLib {\n    /// @dev Parses validator address out of nonce\n    /// @param nonce The nonce\n    /// @return validator\n    function getValidator(uint256 nonce) internal pure returns (address validator) {\n        assembly {\n            validator := shr(96, shl(32, nonce))\n        }\n    }\n\n    /// @dev Detects if Validation Mode is Module Enable Mode\n    /// @param nonce The nonce\n    /// @return res boolean result, true if it is the Module Enable Mode\n    function isModuleEnableMode(uint256 nonce) internal pure returns (bool res) {\n        assembly {\n            let vmode := byte(3, nonce)\n            res := eq(shl(248, vmode), MODE_MODULE_ENABLE)\n        }\n    }\n\n    /// @dev Detects if the validator provided in the nonce is address(0)\n    /// which means the default validator is used\n    /// @param nonce The nonce\n    /// @return res boolean result, true if it is the Default Validator Mode\n    function isDefaultValidatorMode(uint256 nonce) internal pure returns (bool res) {\n        assembly {\n            res := iszero(shr(96, shl(32, nonce)))\n        }\n    }\n\n    /// @dev Detects if Validation Mode is Prep Mode\n    /// @param nonce The nonce\n    /// @return res boolean result, true if it is the Prep Mode\n    function isPrepMode(uint256 nonce) internal pure returns (bool res) {\n        assembly {\n            let vmode := byte(3, nonce)\n            res := eq(shl(248, vmode), MODE_PREP)\n        }\n    }\n\n    /// @dev Detects if Validation Mode is Validate Mode\n    /// @param nonce The nonce\n    /// @return res boolean result, true if it is the Validation Mode\n    function isValidateMode(uint256 nonce) internal pure returns (bool res) {\n        assembly {\n            let vmode := byte(3, nonce)\n            res := eq(shl(248, vmode), MODE_VALIDATION)\n        }\n    }\n}\n"},"node_modules/@rhinestone/sentinellist/src/SentinelList.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// Sentinel address\naddress constant SENTINEL = address(0x1);\n// Zero address\naddress constant ZERO_ADDRESS = address(0x0);\n\n/**\n * @title SentinelListLib\n * @dev Library for managing a linked list of addresses\n * @author Rhinestone\n */\nlibrary SentinelListLib {\n    // Struct to hold the linked list\n    struct SentinelList {\n        mapping(address => address) entries;\n    }\n\n    error LinkedList_AlreadyInitialized();\n    error LinkedList_InvalidPage();\n    error LinkedList_InvalidEntry(address entry);\n    error LinkedList_EntryAlreadyInList(address entry);\n\n    /**\n     * Initialize the linked list\n     *\n     * @param self The linked list\n     */\n    function init(SentinelList storage self) internal {\n        if (alreadyInitialized(self)) revert LinkedList_AlreadyInitialized();\n        self.entries[SENTINEL] = SENTINEL;\n    }\n\n    /**\n     * Check if the linked list is already initialized\n     *\n     * @param self The linked list\n     *\n     * @return bool True if the linked list is already initialized\n     */\n    function alreadyInitialized(SentinelList storage self) internal view returns (bool) {\n        return self.entries[SENTINEL] != ZERO_ADDRESS;\n    }\n\n    /**\n     * Get the next entry in the linked list\n     *\n     * @param self The linked list\n     * @param entry The current entry\n     *\n     * @return address The next entry\n     */\n    function getNext(SentinelList storage self, address entry) internal view returns (address) {\n        if (entry == ZERO_ADDRESS) {\n            revert LinkedList_InvalidEntry(entry);\n        }\n        return self.entries[entry];\n    }\n\n    /**\n     * Push a new entry to the linked list\n     *\n     * @param self The linked list\n     * @param newEntry The new entry\n     */\n    function push(SentinelList storage self, address newEntry) internal {\n        if (newEntry == ZERO_ADDRESS || newEntry == SENTINEL) {\n            revert LinkedList_InvalidEntry(newEntry);\n        }\n        if (self.entries[newEntry] != ZERO_ADDRESS) revert LinkedList_EntryAlreadyInList(newEntry);\n        self.entries[newEntry] = self.entries[SENTINEL];\n        self.entries[SENTINEL] = newEntry;\n    }\n\n    /**\n     * Safe push a new entry to the linked list\n     * @dev This ensures that the linked list is initialized and initializes it if it is not\n     *\n     * @param self The linked list\n     * @param newEntry The new entry\n     */\n    function safePush(SentinelList storage self, address newEntry) internal {\n        if (!alreadyInitialized({ self: self })) {\n            init({ self: self });\n        }\n        push({ self: self, newEntry: newEntry });\n    }\n\n    /**\n     * Pop an entry from the linked list\n     *\n     * @param self The linked list\n     * @param prevEntry The entry before the entry to pop\n     * @param popEntry The entry to pop\n     */\n    function pop(SentinelList storage self, address prevEntry, address popEntry) internal {\n        if (popEntry == ZERO_ADDRESS || popEntry == SENTINEL) {\n            revert LinkedList_InvalidEntry(prevEntry);\n        }\n        if (self.entries[prevEntry] != popEntry) revert LinkedList_InvalidEntry(popEntry);\n        self.entries[prevEntry] = self.entries[popEntry];\n        self.entries[popEntry] = ZERO_ADDRESS;\n    }\n\n    /**\n     * Pop all entries from the linked list\n     *\n     * @param self The linked list\n     */\n    function popAll(SentinelList storage self) internal {\n        address next = self.entries[SENTINEL];\n        while (next != ZERO_ADDRESS) {\n            address current = next;\n            next = self.entries[next];\n            self.entries[current] = ZERO_ADDRESS;\n        }\n    }\n\n    /**\n     * Check if the linked list contains an entry\n     *\n     * @param self The linked list\n     * @param entry The entry to check\n     *\n     * @return bool True if the linked list contains the entry\n     */\n    function contains(SentinelList storage self, address entry) internal view returns (bool) {\n        return SENTINEL != entry && self.entries[entry] != ZERO_ADDRESS;\n    }\n\n    /**\n     * Get all entries in the linked list\n     *\n     * @param self The linked list\n     * @param start The start entry\n     * @param pageSize The page size\n     *\n     * @return array All entries in the linked list\n     * @return next The next entry\n     */\n    function getEntriesPaginated(\n        SentinelList storage self,\n        address start,\n        uint256 pageSize\n    )\n        internal\n        view\n        returns (address[] memory array, address next)\n    {\n        if (start != SENTINEL && !contains(self, start)) revert LinkedList_InvalidEntry(start);\n        if (pageSize == 0) revert LinkedList_InvalidPage();\n        // Init array with max page size\n        array = new address[](pageSize);\n\n        // Populate return array\n        uint256 entryCount = 0;\n        next = self.entries[start];\n        while (next != ZERO_ADDRESS && next != SENTINEL && entryCount < pageSize) {\n            array[entryCount] = next;\n            next = self.entries[next];\n            entryCount++;\n        }\n\n        /**\n         * Because of the argument validation, we can assume that the loop will always iterate over\n         * the valid entry list values\n         *       and the `next` variable will either be an enabled entry or a sentinel address\n         * (signalling the end).\n         *\n         *       If we haven't reached the end inside the loop, we need to set the next pointer to\n         * the last element of the entry array\n         *       because the `next` variable (which is a entry by itself) acting as a pointer to the\n         * start of the next page is neither\n         *       incSENTINELrent page, nor will it be included in the next one if you pass it as a\n         * start.\n         */\n        if (next != SENTINEL && entryCount > 0) {\n            next = array[entryCount - 1];\n        }\n        // Set correct size of returned array\n        // solhint-disable-next-line no-inline-assembly\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(array, entryCount)\n        }\n    }\n}\n"},"contracts/types/DataTypes.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\n// ──────────────────────────────────────────────────────────────────────────────\n//     _   __    _  __\n//    / | / /__ | |/ /_  _______\n//   /  |/ / _ \\|   / / / / ___/\n//  / /|  /  __/   / /_/ (__  )\n// /_/ |_/\\___/_/|_\\__,_/____/\n//\n// ──────────────────────────────────────────────────────────────────────────────\n// Nexus: A suite of contracts for Modular Smart Accounts compliant with ERC-7579 and ERC-4337, developed by Biconomy.\n// Learn more at https://biconomy.io. To report security issues, please contact us at: security@biconomy.io\n\n/// @title Emergency Uninstall\n/// @notice Struct to encapsulate emergency uninstall data for a hook\nstruct EmergencyUninstall {\n    /// @notice The address of the hook to be uninstalled\n    address hook;\n    /// @notice The hook type identifier\n    uint256 hookType;\n    /// @notice Data used to uninstall the hook\n    bytes deInitData;\n    /// @notice Nonce used to prevent replay attacks\n    uint256 nonce;\n}\n"},"contracts/lib/nexus/local/LibPREP.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\nimport { EfficientHashLib } from \"solady/utils/EfficientHashLib.sol\";\nimport { LibBit } from \"solady/utils/LibBit.sol\";\nimport { ECDSA } from \"solady/utils/ECDSA.sol\";\nimport { LibEIP7702 } from \"solady/accounts/LibEIP7702.sol\";\n\n/// @title LibPREP\n/// @notice A library to encapsulate the PREP (Provably Rootless EIP-7702 Proxy) workflow.\n/// See: https://blog.biconomy.io/prep-deep-dive/\nlibrary LibPREP {\n    /// @dev Validates if `digest` and `saltAndDelegation` results in `target`.\n    /// `saltAndDelegation` is `bytes32((uint256(salt) << 160) | uint160(delegation))`.\n    /// Returns a non-zero `r` for the PREP signature, if valid.\n    /// Otherwise returns 0.\n    /// `r` will be less than `2**160`, allowing for optional storage packing.\n    function rPREP(address target, bytes32 digest, bytes32 saltAndDelegation) internal view returns (bytes32 r) {\n        r = (EfficientHashLib.hash(digest, saltAndDelegation >> 160) << 96) >> 96;\n        if (!isValid(target, r, address(uint160(uint256(saltAndDelegation))))) r = 0;\n    }\n\n    /// @dev Returns if `r` and `delegation` results in `target`.\n    function isValid(address target, bytes32 r, address delegation) internal view returns (bool) {\n        bytes32 s = EfficientHashLib.hash(r);\n        bytes32 h; // `keccak256(abi.encodePacked(hex\"05\", LibRLP.p(0).p(delegation).p(0).encode()))`.\n        assembly (\"memory-safe\") {\n            mstore(0x20, 0x80)\n            mstore(0x1f, delegation)\n            mstore(0x0b, 0x05d78094)\n            h := keccak256(0x27, 0x19)\n        }\n        return LibBit.and(target != address(0), ECDSA.tryRecover(h, 27, r, s) == target);\n    }\n\n    /// @dev Returns if `target` is a PREP.\n    function isPREP(address target, bytes32 r) internal view returns (bool) {\n        address delegation = LibEIP7702.delegationOf(target);\n        return !LibBit.or(delegation == address(0), r == 0) && isValid(target, r, delegation);\n    }\n}\n"},"node_modules/solady/src/utils/ECDSA.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Gas optimized ECDSA wrapper.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/ECDSA.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/ECDSA.sol)\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/ECDSA.sol)\n///\n/// @dev Note:\n/// - The recovery functions use the ecrecover precompile (0x1).\n/// - As of Solady version 0.0.68, the `recover` variants will revert upon recovery failure.\n///   This is for more safety by default.\n///   Use the `tryRecover` variants if you need to get the zero address back\n///   upon recovery failure instead.\n/// - As of Solady version 0.0.134, all `bytes signature` variants accept both\n///   regular 65-byte `(r, s, v)` and EIP-2098 `(r, vs)` short form signatures.\n///   See: https://eips.ethereum.org/EIPS/eip-2098\n///   This is for calldata efficiency on smart accounts prevalent on L2s.\n///\n/// WARNING! Do NOT directly use signatures as unique identifiers:\n/// - The recovery operations do NOT check if a signature is non-malleable.\n/// - Use a nonce in the digest to prevent replay attacks on the same contract.\n/// - Use EIP-712 for the digest to prevent replay attacks across different chains and contracts.\n///   EIP-712 also enables readable signing of typed data for better user safety.\n/// - If you need a unique hash from a signature, please use the `canonicalHash` functions.\nlibrary ECDSA {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         CONSTANTS                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The order of the secp256k1 elliptic curve.\n    uint256 internal constant N =\n        0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141;\n\n    /// @dev `N/2 + 1`. Used for checking the malleability of the signature.\n    uint256 private constant _HALF_N_PLUS_1 =\n        0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a1;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                        CUSTOM ERRORS                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The signature is invalid.\n    error InvalidSignature();\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                    RECOVERY OPERATIONS                     */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Recovers the signer's address from a message digest `hash`, and the `signature`.\n    function recover(bytes32 hash, bytes memory signature) internal view returns (address result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for { let m := mload(0x40) } 1 {\n                mstore(0x00, 0x8baa579f) // `InvalidSignature()`.\n                revert(0x1c, 0x04)\n            } {\n                switch mload(signature)\n                case 64 {\n                    let vs := mload(add(signature, 0x40))\n                    mstore(0x20, add(shr(255, vs), 27)) // `v`.\n                    mstore(0x60, shr(1, shl(1, vs))) // `s`.\n                }\n                case 65 {\n                    mstore(0x20, byte(0, mload(add(signature, 0x60)))) // `v`.\n                    mstore(0x60, mload(add(signature, 0x40))) // `s`.\n                }\n                default { continue }\n                mstore(0x00, hash)\n                mstore(0x40, mload(add(signature, 0x20))) // `r`.\n                result := mload(staticcall(gas(), 1, 0x00, 0x80, 0x01, 0x20))\n                mstore(0x60, 0) // Restore the zero slot.\n                mstore(0x40, m) // Restore the free memory pointer.\n                // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\n                if returndatasize() { break }\n            }\n        }\n    }\n\n    /// @dev Recovers the signer's address from a message digest `hash`, and the `signature`.\n    function recoverCalldata(bytes32 hash, bytes calldata signature)\n        internal\n        view\n        returns (address result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for { let m := mload(0x40) } 1 {\n                mstore(0x00, 0x8baa579f) // `InvalidSignature()`.\n                revert(0x1c, 0x04)\n            } {\n                switch signature.length\n                case 64 {\n                    let vs := calldataload(add(signature.offset, 0x20))\n                    mstore(0x20, add(shr(255, vs), 27)) // `v`.\n                    mstore(0x40, calldataload(signature.offset)) // `r`.\n                    mstore(0x60, shr(1, shl(1, vs))) // `s`.\n                }\n                case 65 {\n                    mstore(0x20, byte(0, calldataload(add(signature.offset, 0x40)))) // `v`.\n                    calldatacopy(0x40, signature.offset, 0x40) // Copy `r` and `s`.\n                }\n                default { continue }\n                mstore(0x00, hash)\n                result := mload(staticcall(gas(), 1, 0x00, 0x80, 0x01, 0x20))\n                mstore(0x60, 0) // Restore the zero slot.\n                mstore(0x40, m) // Restore the free memory pointer.\n                // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\n                if returndatasize() { break }\n            }\n        }\n    }\n\n    /// @dev Recovers the signer's address from a message digest `hash`,\n    /// and the EIP-2098 short form signature defined by `r` and `vs`.\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal view returns (address result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x00, hash)\n            mstore(0x20, add(shr(255, vs), 27)) // `v`.\n            mstore(0x40, r)\n            mstore(0x60, shr(1, shl(1, vs))) // `s`.\n            result := mload(staticcall(gas(), 1, 0x00, 0x80, 0x01, 0x20))\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\n            if iszero(returndatasize()) {\n                mstore(0x00, 0x8baa579f) // `InvalidSignature()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x60, 0) // Restore the zero slot.\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }\n\n    /// @dev Recovers the signer's address from a message digest `hash`,\n    /// and the signature defined by `v`, `r`, `s`.\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s)\n        internal\n        view\n        returns (address result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x00, hash)\n            mstore(0x20, and(v, 0xff))\n            mstore(0x40, r)\n            mstore(0x60, s)\n            result := mload(staticcall(gas(), 1, 0x00, 0x80, 0x01, 0x20))\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\n            if iszero(returndatasize()) {\n                mstore(0x00, 0x8baa579f) // `InvalidSignature()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x60, 0) // Restore the zero slot.\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   TRY-RECOVER OPERATIONS                   */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    // WARNING!\n    // These functions will NOT revert upon recovery failure.\n    // Instead, they will return the zero address upon recovery failure.\n    // It is critical that the returned address is NEVER compared against\n    // a zero address (e.g. an uninitialized address variable).\n\n    /// @dev Recovers the signer's address from a message digest `hash`, and the `signature`.\n    function tryRecover(bytes32 hash, bytes memory signature)\n        internal\n        view\n        returns (address result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for { let m := mload(0x40) } 1 {} {\n                switch mload(signature)\n                case 64 {\n                    let vs := mload(add(signature, 0x40))\n                    mstore(0x20, add(shr(255, vs), 27)) // `v`.\n                    mstore(0x60, shr(1, shl(1, vs))) // `s`.\n                }\n                case 65 {\n                    mstore(0x20, byte(0, mload(add(signature, 0x60)))) // `v`.\n                    mstore(0x60, mload(add(signature, 0x40))) // `s`.\n                }\n                default { break }\n                mstore(0x00, hash)\n                mstore(0x40, mload(add(signature, 0x20))) // `r`.\n                pop(staticcall(gas(), 1, 0x00, 0x80, 0x40, 0x20))\n                mstore(0x60, 0) // Restore the zero slot.\n                // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\n                result := mload(xor(0x60, returndatasize()))\n                mstore(0x40, m) // Restore the free memory pointer.\n                break\n            }\n        }\n    }\n\n    /// @dev Recovers the signer's address from a message digest `hash`, and the `signature`.\n    function tryRecoverCalldata(bytes32 hash, bytes calldata signature)\n        internal\n        view\n        returns (address result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for { let m := mload(0x40) } 1 {} {\n                switch signature.length\n                case 64 {\n                    let vs := calldataload(add(signature.offset, 0x20))\n                    mstore(0x20, add(shr(255, vs), 27)) // `v`.\n                    mstore(0x40, calldataload(signature.offset)) // `r`.\n                    mstore(0x60, shr(1, shl(1, vs))) // `s`.\n                }\n                case 65 {\n                    mstore(0x20, byte(0, calldataload(add(signature.offset, 0x40)))) // `v`.\n                    calldatacopy(0x40, signature.offset, 0x40) // Copy `r` and `s`.\n                }\n                default { break }\n                mstore(0x00, hash)\n                pop(staticcall(gas(), 1, 0x00, 0x80, 0x40, 0x20))\n                mstore(0x60, 0) // Restore the zero slot.\n                // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\n                result := mload(xor(0x60, returndatasize()))\n                mstore(0x40, m) // Restore the free memory pointer.\n                break\n            }\n        }\n    }\n\n    /// @dev Recovers the signer's address from a message digest `hash`,\n    /// and the EIP-2098 short form signature defined by `r` and `vs`.\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs)\n        internal\n        view\n        returns (address result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x00, hash)\n            mstore(0x20, add(shr(255, vs), 27)) // `v`.\n            mstore(0x40, r)\n            mstore(0x60, shr(1, shl(1, vs))) // `s`.\n            pop(staticcall(gas(), 1, 0x00, 0x80, 0x40, 0x20))\n            mstore(0x60, 0) // Restore the zero slot.\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\n            result := mload(xor(0x60, returndatasize()))\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }\n\n    /// @dev Recovers the signer's address from a message digest `hash`,\n    /// and the signature defined by `v`, `r`, `s`.\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s)\n        internal\n        view\n        returns (address result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x00, hash)\n            mstore(0x20, and(v, 0xff))\n            mstore(0x40, r)\n            mstore(0x60, s)\n            pop(staticcall(gas(), 1, 0x00, 0x80, 0x40, 0x20))\n            mstore(0x60, 0) // Restore the zero slot.\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\n            result := mload(xor(0x60, returndatasize()))\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                     HASHING OPERATIONS                     */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns an Ethereum Signed Message, created from a `hash`.\n    /// This produces a hash corresponding to the one signed with the\n    /// [`eth_sign`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_sign)\n    /// JSON-RPC method as part of EIP-191.\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x20, hash) // Store into scratch space for keccak256.\n            mstore(0x00, \"\\x00\\x00\\x00\\x00\\x19Ethereum Signed Message:\\n32\") // 28 bytes.\n            result := keccak256(0x04, 0x3c) // `32 * 2 - (32 - 28) = 60 = 0x3c`.\n        }\n    }\n\n    /// @dev Returns an Ethereum Signed Message, created from `s`.\n    /// This produces a hash corresponding to the one signed with the\n    /// [`eth_sign`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_sign)\n    /// JSON-RPC method as part of EIP-191.\n    /// Note: Supports lengths of `s` up to 999999 bytes.\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let sLength := mload(s)\n            let o := 0x20\n            mstore(o, \"\\x19Ethereum Signed Message:\\n\") // 26 bytes, zero-right-padded.\n            mstore(0x00, 0x00)\n            // Convert the `s.length` to ASCII decimal representation: `base10(s.length)`.\n            for { let temp := sLength } 1 {} {\n                o := sub(o, 1)\n                mstore8(o, add(48, mod(temp, 10)))\n                temp := div(temp, 10)\n                if iszero(temp) { break }\n            }\n            let n := sub(0x3a, o) // Header length: `26 + 32 - o`.\n            // Throw an out-of-offset error (consumes all gas) if the header exceeds 32 bytes.\n            returndatacopy(returndatasize(), returndatasize(), gt(n, 0x20))\n            mstore(s, or(mload(0x00), mload(n))) // Temporarily store the header.\n            result := keccak256(add(s, sub(0x20, n)), add(n, sLength))\n            mstore(s, sLength) // Restore the length.\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                  CANONICAL HASH FUNCTIONS                  */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    // The following functions return the hash of the signature in its canonicalized format,\n    // which is the 65-byte `abi.encodePacked(r, s, uint8(v))`, where `v` is either 27 or 28.\n    // If `s` is greater than `N / 2` then it will be converted to `N - s`\n    // and the `v` value will be flipped.\n    // If the signature has an invalid length, or if `v` is invalid,\n    // a uniquely corrupt hash will be returned.\n    // These functions are useful for \"poor-mans-VRF\".\n\n    /// @dev Returns the canonical hash of `signature`.\n    function canonicalHash(bytes memory signature) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let l := mload(signature)\n            for {} 1 {} {\n                mstore(0x00, mload(add(signature, 0x20))) // `r`.\n                let s := mload(add(signature, 0x40))\n                let v := mload(add(signature, 0x41))\n                if eq(l, 64) {\n                    v := add(shr(255, s), 27)\n                    s := shr(1, shl(1, s))\n                }\n                if iszero(lt(s, _HALF_N_PLUS_1)) {\n                    v := xor(v, 7)\n                    s := sub(N, s)\n                }\n                mstore(0x21, v)\n                mstore(0x20, s)\n                result := keccak256(0x00, 0x41)\n                mstore(0x21, 0) // Restore the overwritten part of the free memory pointer.\n                break\n            }\n\n            // If the length is neither 64 nor 65, return a uniquely corrupted hash.\n            if iszero(lt(sub(l, 64), 2)) {\n                // `bytes4(keccak256(\"InvalidSignatureLength\"))`.\n                result := xor(keccak256(add(signature, 0x20), l), 0xd62f1ab2)\n            }\n        }\n    }\n\n    /// @dev Returns the canonical hash of `signature`.\n    function canonicalHashCalldata(bytes calldata signature)\n        internal\n        pure\n        returns (bytes32 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for {} 1 {} {\n                mstore(0x00, calldataload(signature.offset)) // `r`.\n                let s := calldataload(add(signature.offset, 0x20))\n                let v := calldataload(add(signature.offset, 0x21))\n                if eq(signature.length, 64) {\n                    v := add(shr(255, s), 27)\n                    s := shr(1, shl(1, s))\n                }\n                if iszero(lt(s, _HALF_N_PLUS_1)) {\n                    v := xor(v, 7)\n                    s := sub(N, s)\n                }\n                mstore(0x21, v)\n                mstore(0x20, s)\n                result := keccak256(0x00, 0x41)\n                mstore(0x21, 0) // Restore the overwritten part of the free memory pointer.\n                break\n            }\n            // If the length is neither 64 nor 65, return a uniquely corrupted hash.\n            if iszero(lt(sub(signature.length, 64), 2)) {\n                calldatacopy(mload(0x40), signature.offset, signature.length)\n                // `bytes4(keccak256(\"InvalidSignatureLength\"))`.\n                result := xor(keccak256(mload(0x40), signature.length), 0xd62f1ab2)\n            }\n        }\n    }\n\n    /// @dev Returns the canonical hash of `signature`.\n    function canonicalHash(bytes32 r, bytes32 vs) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, r) // `r`.\n            let v := add(shr(255, vs), 27)\n            let s := shr(1, shl(1, vs))\n            mstore(0x21, v)\n            mstore(0x20, s)\n            result := keccak256(0x00, 0x41)\n            mstore(0x21, 0) // Restore the overwritten part of the free memory pointer.\n        }\n    }\n\n    /// @dev Returns the canonical hash of `signature`.\n    function canonicalHash(uint8 v, bytes32 r, bytes32 s) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, r) // `r`.\n            if iszero(lt(s, _HALF_N_PLUS_1)) {\n                v := xor(v, 7)\n                s := sub(N, s)\n            }\n            mstore(0x21, v)\n            mstore(0x20, s)\n            result := keccak256(0x00, 0x41)\n            mstore(0x21, 0) // Restore the overwritten part of the free memory pointer.\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   EMPTY CALLDATA HELPERS                   */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns an empty calldata bytes.\n    function emptySignature() internal pure returns (bytes calldata signature) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            signature.length := 0\n        }\n    }\n}\n"},"node_modules/@erc7579/implementation/src/interfaces/IERC7579Module.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.21;\n\nimport { PackedUserOperation } from \"account-abstraction/interfaces/PackedUserOperation.sol\";\n\nuint256 constant VALIDATION_SUCCESS = 0;\nuint256 constant VALIDATION_FAILED = 1;\n\nuint256 constant MODULE_TYPE_VALIDATOR = 1;\nuint256 constant MODULE_TYPE_EXECUTOR = 2;\nuint256 constant MODULE_TYPE_FALLBACK = 3;\nuint256 constant MODULE_TYPE_HOOK = 4;\nuint256 constant MODULE_TYPE_PREVALIDATION_HOOK_ERC1271 = 8;\nuint256 constant MODULE_TYPE_PREVALIDATION_HOOK_ERC4337 = 9;\n\ninterface IModule {\n    error AlreadyInitialized(address smartAccount);\n    error NotInitialized(address smartAccount);\n\n    /**\n     * @dev This function is called by the smart account during installation of the module\n     * @param data arbitrary data that may be required on the module during `onInstall`\n     * initialization\n     *\n     * MUST revert on error (i.e. if module is already enabled)\n     */\n    function onInstall(bytes calldata data) external;\n\n    /**\n     * @dev This function is called by the smart account during uninstallation of the module\n     * @param data arbitrary data that may be required on the module during `onUninstall`\n     * de-initialization\n     *\n     * MUST revert on error\n     */\n    function onUninstall(bytes calldata data) external;\n\n    /**\n     * @dev Returns boolean value if module is a certain type\n     * @param moduleTypeId the module type ID according the ERC-7579 spec\n     *\n     * MUST return true if the module is of the given type and false otherwise\n     */\n    function isModuleType(uint256 moduleTypeId) external view returns (bool);\n\n    /**\n     * @dev Returns if the module was already initialized for a provided smartaccount\n     */\n    function isInitialized(address smartAccount) external view returns (bool);\n}\n\ninterface IValidator is IModule {\n    error InvalidTargetAddress(address target);\n\n    /**\n     * @dev Validates a transaction on behalf of the account.\n     *         This function is intended to be called by the MSA during the ERC-4337 validaton phase\n     *         Note: solely relying on bytes32 hash and signature is not suffcient for some\n     * validation implementations (i.e. SessionKeys often need access to userOp.calldata)\n     * @param userOp The user operation to be validated. The userOp MUST NOT contain any metadata.\n     * The MSA MUST clean up the userOp before sending it to the validator.\n     * @param userOpHash The hash of the user operation to be validated\n     * @return return value according to ERC-4337\n     */\n    function validateUserOp(\n        PackedUserOperation calldata userOp,\n        bytes32 userOpHash\n    )\n        external\n        returns (uint256);\n\n    /**\n     * Validator can be used for ERC-1271 validation\n     */\n    function isValidSignatureWithSender(\n        address sender,\n        bytes32 hash,\n        bytes calldata data\n    )\n        external\n        view\n        returns (bytes4);\n}\n\ninterface IExecutor is IModule { }\n\ninterface IHook is IModule {\n    function preCheck(\n        address msgSender,\n        uint256 msgValue,\n        bytes calldata msgData\n    )\n        external\n        returns (bytes memory hookData);\n\n    function postCheck(bytes calldata hookData) external;\n}\n\ninterface IFallback is IModule { }\n\ninterface IPreValidationHookERC1271 is IModule {\n    function preValidationHookERC1271(\n        address sender,\n        bytes32 hash,\n        bytes calldata data\n    )\n        external\n        view\n        returns (bytes32 hookHash, bytes memory hookSignature);\n}\n\ninterface IPreValidationHookERC4337 is IModule {\n    function preValidationHookERC4337(\n        PackedUserOperation calldata userOp,\n        uint256 missingAccountFunds,\n        bytes32 userOpHash\n    )\n        external\n        returns (bytes32 hookHash, bytes memory hookSignature);\n}\n"},"contracts/types/Constants.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\n// STX Sig types\nbytes3 constant SIG_TYPE_MEE_FLOW = 0x177eee;\n\nbytes4 constant SIG_TYPE_SIMPLE = 0x177eee00;\nbytes4 constant SIG_TYPE_ON_CHAIN = 0x177eee01;\nbytes4 constant SIG_TYPE_ERC20_PERMIT = 0x177eee02;\n// ...other sig types: ERC-7683, Permit2, etc\n\n// EIP-1271 constants\nbytes4 constant ERC1271_SUCCESS = 0x1626ba7e;\nbytes4 constant ERC1271_FAILED = 0xffffffff;\n\n// Node PM constants\nbytes4 constant NODE_PM_MODE_USER = 0x170de000; // refund goes to the user\nbytes4 constant NODE_PM_MODE_DAPP = 0x170de001; // refund goes to the dApp\nbytes4 constant NODE_PM_MODE_KEEP = 0x170de002; // no refund as node sponsored\n\nbytes4 constant NODE_PM_PREMIUM_PERCENT = 0x9ee4ce00; // premium percentage\nbytes4 constant NODE_PM_PREMIUM_FIXED = 0x9ee4ce01;\n\n// ERC-4337 validation constants\nuint256 constant VALIDATION_SUCCESS = 0;\nuint256 constant VALIDATION_FAILED = 1;\n\n// Module type identifiers\nuint256 constant MODULE_TYPE_MULTI = 0; // Module type identifier for Multitype install\nuint256 constant MODULE_TYPE_VALIDATOR = 1;\nuint256 constant MODULE_TYPE_EXECUTOR = 2;\nuint256 constant MODULE_TYPE_FALLBACK = 3;\nuint256 constant MODULE_TYPE_HOOK = 4;\nuint256 constant MODULE_TYPE_STATELESS_VALIDATOR = 7;\nuint256 constant MODULE_TYPE_PREVALIDATION_HOOK_ERC1271 = 8;\nuint256 constant MODULE_TYPE_PREVALIDATION_HOOK_ERC4337 = 9;\n\n// Nexus Validation modes\nbytes1 constant MODE_VALIDATION = 0x00;\nbytes1 constant MODE_MODULE_ENABLE = 0x01;\nbytes1 constant MODE_PREP = 0x02;\n\n// ERC-7739 support constants\nbytes4 constant SUPPORTS_ERC7739 = 0x77390000;\nbytes4 constant SUPPORTS_ERC7739_V1 = 0x77390001;\n\n// Typehashes\n\n// keccak256(\"ModuleEnableMode(address module,uint256 moduleType,bytes32 userOpHash,bytes initData)\")\nbytes32 constant MODULE_ENABLE_MODE_TYPE_HASH = 0xf6c866c1cd985ce61f030431e576c0e82887de0643dfa8a2e6efc3463e638ed0;\n\n// keccak256(\"EmergencyUninstall(address hook,uint256 hookType,bytes deInitData,uint256 nonce)\")\nbytes32 constant EMERGENCY_UNINSTALL_TYPE_HASH = 0xd3ddfc12654178cc44d4a7b6b969cfdce7ffe6342326ba37825314cffa0fba9c;\n"},"contracts/lib/erc-7579/ModeLib.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\n/// @title ModeLib\n/// @author zeroknots.eth | rhinestone.wtf\n/// To allow smart accounts to be very simple, but allow for more complex execution, A custom mode\n/// encoding is used.\n///    Function Signature of execute function:\n///           function execute(ExecutionMode mode, bytes calldata executionCalldata) external payable;\n/// This allows for a single bytes32 to be used to encode the execution mode, calltype, execType and\n/// context.\n/// NOTE: Simple Account implementations only have to scope for the most significant byte. Account  that\n/// implement\n/// more complex execution modes may use the entire bytes32.\n///\n/// |--------------------------------------------------------------------|\n/// | CALLTYPE  | EXECTYPE  |   UNUSED   | ModeSelector  |  ModePayload  |\n/// |--------------------------------------------------------------------|\n/// | 1 byte    | 1 byte    |   4 bytes  | 4 bytes       |   22 bytes    |\n/// |--------------------------------------------------------------------|\n///\n/// CALLTYPE: 1 byte\n/// CallType is used to determine how the executeCalldata paramter of the execute function has to be\n/// decoded.\n/// It can be either single, batch or delegatecall. In the future different calls could be added.\n/// CALLTYPE can be used by a validation module to determine how to decode <userOp.callData[36:]>.\n///\n/// EXECTYPE: 1 byte\n/// ExecType is used to determine how the account should handle the execution.\n/// It can indicate if the execution should revert on failure or continue execution.\n/// In the future more execution modes may be added.\n/// Default Behavior (EXECTYPE = 0x00) is to revert on a single failed execution. If one execution in\n/// a batch fails, the entire batch is reverted\n///\n/// UNUSED: 4 bytes\n/// Unused bytes are reserved for future use.\n///\n/// ModeSelector: bytes4\n/// The \"optional\" mode selector can be used by account vendors, to implement custom behavior in\n/// their accounts.\n/// the way a ModeSelector is to be calculated is bytes4(keccak256(\"vendorname.featurename\"))\n/// this is to prevent collisions between different vendors, while allowing innovation and the\n/// development of new features without coordination between ERC-7579 implementing accounts\n///\n/// ModePayload: 22 bytes\n/// Mode payload is used to pass additional data to the smart account execution, this may be\n/// interpreted depending on the ModeSelector\n///\n/// ExecutionCallData: n bytes\n/// single, delegatecall or batch exec abi.encoded as bytes\n\n// Custom type for improved developer experience\ntype ExecutionMode is bytes32;\n\ntype CallType is bytes1;\n\ntype ExecType is bytes1;\n\ntype ModeSelector is bytes4;\n\ntype ModePayload is bytes22;\n\n// Default CallType\nCallType constant CALLTYPE_SINGLE = CallType.wrap(0x00);\n// Batched CallType\nCallType constant CALLTYPE_BATCH = CallType.wrap(0x01);\n\nCallType constant CALLTYPE_STATIC = CallType.wrap(0xFE);\n\n// @dev Implementing delegatecall is OPTIONAL!\n// implement delegatecall with extreme care.\nCallType constant CALLTYPE_DELEGATECALL = CallType.wrap(0xFF);\n\n// @dev default behavior is to revert on failure\n// To allow very simple accounts to use mode encoding, the default behavior is to revert on failure\n// Since this is value 0x00, no additional encoding is required for simple accounts\nExecType constant EXECTYPE_DEFAULT = ExecType.wrap(0x00);\n// @dev account may elect to change execution behavior. For example \"try exec\" / \"allow fail\"\nExecType constant EXECTYPE_TRY = ExecType.wrap(0x01);\n\nModeSelector constant MODE_DEFAULT = ModeSelector.wrap(bytes4(0x00000000));\n// Example declaration of a custom mode selector\nModeSelector constant MODE_OFFSET = ModeSelector.wrap(bytes4(keccak256(\"default.mode.offset\")));\n\n/// @dev ModeLib is a helper library to encode/decode ModeCodes\nlibrary ModeLib {\n    function decode(ExecutionMode mode)\n        internal\n        pure\n        returns (CallType _calltype, ExecType _execType, ModeSelector _modeSelector, ModePayload _modePayload)\n    {\n        assembly {\n            _calltype := mode\n            _execType := shl(8, mode)\n            _modeSelector := shl(48, mode)\n            _modePayload := shl(80, mode)\n        }\n    }\n\n    function decodeBasic(ExecutionMode mode) internal pure returns (CallType _calltype, ExecType _execType) {\n        assembly {\n            _calltype := mode\n            _execType := shl(8, mode)\n        }\n    }\n\n    function encode(\n        CallType callType,\n        ExecType execType,\n        ModeSelector mode,\n        ModePayload payload\n    )\n        internal\n        pure\n        returns (ExecutionMode)\n    {\n        return ExecutionMode.wrap(\n            bytes32(abi.encodePacked(callType, execType, bytes4(0), ModeSelector.unwrap(mode), payload))\n        );\n    }\n\n    function encodeSimpleBatch() internal pure returns (ExecutionMode mode) {\n        mode = encode(CALLTYPE_BATCH, EXECTYPE_DEFAULT, MODE_DEFAULT, ModePayload.wrap(0x00));\n    }\n\n    function encodeSimpleSingle() internal pure returns (ExecutionMode mode) {\n        mode = encode(CALLTYPE_SINGLE, EXECTYPE_DEFAULT, MODE_DEFAULT, ModePayload.wrap(0x00));\n    }\n\n    function encodeTrySingle() internal pure returns (ExecutionMode mode) {\n        mode = encode(CALLTYPE_SINGLE, EXECTYPE_TRY, MODE_DEFAULT, ModePayload.wrap(0x00));\n    }\n\n    function encodeTryBatch() internal pure returns (ExecutionMode mode) {\n        mode = encode(CALLTYPE_BATCH, EXECTYPE_TRY, MODE_DEFAULT, ModePayload.wrap(0x00));\n    }\n\n    function encodeCustom(CallType callType, ExecType execType) internal pure returns (ExecutionMode mode) {\n        mode = encode(callType, execType, MODE_DEFAULT, ModePayload.wrap(0x00));\n    }\n\n    function getCallType(ExecutionMode mode) internal pure returns (CallType calltype) {\n        assembly {\n            calltype := mode\n        }\n    }\n}\n\nusing { _eqModeSelector as == } for ModeSelector global;\nusing { _eqCallType as == } for CallType global;\nusing { _uneqCallType as != } for CallType global;\nusing { _eqExecType as == } for ExecType global;\n\nfunction _eqCallType(CallType a, CallType b) pure returns (bool) {\n    return CallType.unwrap(a) == CallType.unwrap(b);\n}\n\nfunction _uneqCallType(CallType a, CallType b) pure returns (bool) {\n    return CallType.unwrap(a) != CallType.unwrap(b);\n}\n\nfunction _eqExecType(ExecType a, ExecType b) pure returns (bool) {\n    return ExecType.unwrap(a) == ExecType.unwrap(b);\n}\n\n//slither-disable-next-line dead-code\nfunction _eqModeSelector(ModeSelector a, ModeSelector b) pure returns (bool) {\n    return ModeSelector.unwrap(a) == ModeSelector.unwrap(b);\n}\n"},"node_modules/account-abstraction/contracts/interfaces/PackedUserOperation.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.5;\n\n/**\n * User Operation struct\n * @param sender                - The sender account of this request.\n * @param nonce                 - Unique value the sender uses to verify it is not a replay.\n * @param initCode              - If set, the account contract will be created by this constructor/\n * @param callData              - The method call to execute on this account.\n * @param accountGasLimits      - Packed gas limits for validateUserOp and gas limit passed to the callData method call.\n * @param preVerificationGas    - Gas not calculated by the handleOps method, but added to the gas paid.\n *                                Covers batch overhead.\n * @param gasFees               - packed gas fields maxPriorityFeePerGas and maxFeePerGas - Same as EIP-1559 gas parameters.\n * @param paymasterAndData      - If set, this field holds the paymaster address, verification gas limit, postOp gas limit and paymaster-specific extra data\n *                                The paymaster will pay for the transaction instead of the sender.\n * @param signature             - Sender-verified signature over the entire request, the EntryPoint address and the chain ID.\n */\nstruct PackedUserOperation {\n    address sender;\n    uint256 nonce;\n    bytes initCode;\n    bytes callData;\n    bytes32 accountGasLimits;\n    uint256 preVerificationGas;\n    bytes32 gasFees;\n    bytes paymasterAndData;\n    bytes signature;\n}\n"},"contracts/interfaces/nexus/base/IBaseAccount.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\n// ──────────────────────────────────────────────────────────────────────────────\n//     _   __    _  __\n//    / | / /__ | |/ /_  _______\n//   /  |/ / _ \\|   / / / / ___/\n//  / /|  /  __/   / /_/ (__  )\n// /_/ |_/\\___/_/|_\\__,_/____/\n//\n// ──────────────────────────────────────────────────────────────────────────────\n// Nexus: A suite of contracts for Modular Smart Accounts compliant with ERC-7579 and ERC-4337, developed by Biconomy.\n// Learn more at https://biconomy.io. To report security issues, please contact us at: security@biconomy.io\n\nimport { IBaseAccountEventsAndErrors } from \"./IBaseAccountEventsAndErrors.sol\";\n\n/// @title Nexus - IBaseAccount\n/// @notice Interface for the BaseAccount functionalities compliant with ERC-7579 and ERC-4337.\n/// @dev Interface for organizing the base functionalities using the Nexus suite.\n/// @author @livingrockrises | Biconomy | chirag@biconomy.io\n/// @author @aboudjem | Biconomy | adam.boudjemaa@biconomy.io\n/// @author @filmakarov | Biconomy | filipp.makarov@biconomy.io\n/// @author @zeroknots | Rhinestone.wtf | zeroknots.eth\n/// Special thanks to the Solady team for foundational contributions: https://github.com/Vectorized/solady\ninterface IBaseAccount is IBaseAccountEventsAndErrors {\n    /// @notice Adds deposit to the EntryPoint to fund transactions.\n    function addDeposit() external payable;\n\n    /// @notice Withdraws ETH from the EntryPoint to a specified address.\n    /// @param to The address to receive the withdrawn funds.\n    /// @param amount The amount to withdraw.\n    function withdrawDepositTo(address to, uint256 amount) external payable;\n\n    /// @notice Returns the current deposit balance of this account on the EntryPoint.\n    /// @return The current balance held at the EntryPoint.\n    function getDeposit() external view returns (uint256);\n\n    /// @notice Retrieves the address of the EntryPoint contract, currently using version 0.7.\n    /// @return The address of the EntryPoint contract.\n    function entryPoint() external view returns (address);\n}\n"},"contracts/nexus/base/Storage.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\n// ──────────────────────────────────────────────────────────────────────────────\n//     _   __    _  __\n//    / | / /__ | |/ /_  _______\n//   /  |/ / _ \\|   / / / / ___/\n//  / /|  /  __/   / /_/ (__  )\n// /_/ |_/\\___/_/|_\\__,_/____/\n//\n// ──────────────────────────────────────────────────────────────────────────────\n// Nexus: A suite of contracts for Modular Smart Accounts compliant with ERC-7579 and ERC-4337, developed by Biconomy.\n// Learn more at https://biconomy.io. To report security issues, please contact us at: security@biconomy.io\n\nimport { IStorage } from \"../../interfaces/nexus/base/IStorage.sol\";\n\n/// @title Nexus - Storage\n/// @notice Manages isolated storage spaces for Modular Smart Account in compliance with ERC-7201 standard to ensure\n/// collision-resistant storage.\n/// @dev Implements the ERC-7201 namespaced storage pattern to maintain secure and isolated storage sections for\n/// different\n/// states within Nexus suite.\n/// @author @livingrockrises | Biconomy | chirag@biconomy.io\n/// @author @aboudjem | Biconomy | adam.boudjemaa@biconomy.io\n/// @author @filmakarov | Biconomy | filipp.makarov@biconomy.io\n/// @author @zeroknots | Rhinestone.wtf | zeroknots.eth\n/// Special thanks to the Solady team for foundational contributions: https://github.com/Vectorized/solady\ncontract Storage is IStorage {\n    /// @custom:storage-location erc7201:biconomy.storage.Nexus\n    /// ERC-7201 namespaced via `keccak256(abi.encode(uint256(keccak256(bytes(\"biconomy.storage.Nexus\"))) - 1)) &\n    /// ~bytes32(uint256(0xff));`\n    bytes32 private constant _STORAGE_LOCATION = 0x0bb70095b32b9671358306b0339b4c06e7cbd8cb82505941fba30d1eb5b82f00;\n\n    /// @dev Utilizes ERC-7201's namespaced storage pattern for isolated storage access. This method computes\n    /// the storage slot based on a predetermined location, ensuring collision-resistant storage for contract states.\n    /// @custom:storage-location ERC-7201 formula applied to \"biconomy.storage.Nexus\", facilitating unique\n    /// namespace identification and storage segregation, as detailed in the specification.\n    /// @return $ The proxy to the `AccountStorage` struct, providing a reference to the namespaced storage slot.\n    function _getAccountStorage() internal pure returns (AccountStorage storage $) {\n        assembly {\n            $.slot := _STORAGE_LOCATION\n        }\n    }\n}\n"},"contracts/lib/nexus/local/LocalCallDataParserLib.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\nlibrary LocalCallDataParserLib {\n    /// @dev Parses the `userOp.signature` to extract the module type, module initialization data,\n    ///      enable mode signature, and user operation signature. The `userOp.signature` must be\n    ///      encoded in a specific way to be parsed correctly.\n    /// @param packedData The packed signature data, typically coming from `userOp.signature`.\n    /// @return module The address of the module.\n    /// @return moduleType The type of module as a `uint256`.\n    /// @return moduleInitData Initialization data specific to the module.\n    /// @return enableModeSignature Signature used to enable the module mode.\n    /// @return userOpSignature The remaining user operation signature data.\n    function parseEnableModeData(bytes calldata packedData)\n        internal\n        pure\n        returns (\n            address module,\n            uint256 moduleType,\n            bytes calldata moduleInitData,\n            bytes calldata enableModeSignature,\n            bytes calldata userOpSignature\n        )\n    {\n        uint256 p;\n        assembly (\"memory-safe\") {\n            p := packedData.offset\n            module := shr(96, calldataload(p))\n\n            p := add(p, 0x14)\n            moduleType := calldataload(p)\n\n            moduleInitData.length := shr(224, calldataload(add(p, 0x20)))\n            moduleInitData.offset := add(p, 0x24)\n            p := add(moduleInitData.offset, moduleInitData.length)\n\n            enableModeSignature.length := shr(224, calldataload(p))\n            enableModeSignature.offset := add(p, 0x04)\n            p := sub(add(enableModeSignature.offset, enableModeSignature.length), packedData.offset)\n        }\n        userOpSignature = packedData[p:];\n    }\n\n    /// @dev Parses the data to obtain types and initdata's for Multi Type module install mode\n    /// @param initData Multi Type module init data, abi.encoded\n    function parseMultiTypeInitData(bytes calldata initData)\n        internal\n        pure\n        returns (uint256[] calldata types, bytes[] calldata initDatas)\n    {\n        // equivalent of:\n        // (types, initDatas) = abi.decode(initData,(uint[],bytes[]))\n        assembly (\"memory-safe\") {\n            let offset := initData.offset\n            let baseOffset := offset\n            let dataPointer := add(baseOffset, calldataload(offset))\n\n            types.offset := add(dataPointer, 32)\n            types.length := calldataload(dataPointer)\n            offset := add(offset, 32)\n\n            dataPointer := add(baseOffset, calldataload(offset))\n            initDatas.offset := add(dataPointer, 32)\n            initDatas.length := calldataload(dataPointer)\n        }\n    }\n}\n"},"contracts/interfaces/nexus/base/IModuleManager.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\n// ──────────────────────────────────────────────────────────────────────────────\n//     _   __    _  __\n//    / | / /__ | |/ /_  _______\n//   /  |/ / _ \\|   / / / / ___/\n//  / /|  /  __/   / /_/ (__  )\n// /_/ |_/\\___/_/|_\\__,_/____/\n//\n// ──────────────────────────────────────────────────────────────────────────────\n// Nexus: A suite of contracts for Modular Smart Accounts compliant with ERC-7579 and ERC-4337, developed by Biconomy.\n// Learn more at https://biconomy.io. To report security issues, please contact us at: security@biconomy.io\n\nimport { IModuleManagerEventsAndErrors } from \"./IModuleManagerEventsAndErrors.sol\";\n\n/// @title Nexus - IModuleManager\n/// @notice Interface for managing modules within Smart Accounts, providing methods for installation and removal of\n/// modules.\n/// @dev Extends the IModuleManagerEventsAndErrors interface to include event and error definitions.\n/// @author @livingrockrises | Biconomy | chirag@biconomy.io\n/// @author @aboudjem | Biconomy | adam.boudjemaa@biconomy.io\n/// @author @filmakarov | Biconomy | filipp.makarov@biconomy.io\n/// @author @zeroknots | Rhinestone.wtf | zeroknots.eth\n/// Special thanks to the Solady team for foundational contributions: https://github.com/Vectorized/solady\ninterface IModuleManager is IModuleManagerEventsAndErrors {\n    /// @notice Installs a Module of a specific type onto the smart account.\n    /// @param moduleTypeId The identifier for the module type.\n    /// @param module The address of the module to be installed.\n    /// @param initData Initialization data for configuring the module upon installation.\n    function installModule(uint256 moduleTypeId, address module, bytes calldata initData) external payable;\n\n    /// @notice Uninstalls a Module of a specific type from the smart account.\n    /// @param moduleTypeId The identifier for the module type being uninstalled.\n    /// @param module The address of the module to uninstall.\n    /// @param deInitData De-initialization data for configuring the module upon uninstallation.\n    function uninstallModule(uint256 moduleTypeId, address module, bytes calldata deInitData) external payable;\n\n    /// @notice Checks if a specific module is installed on the smart account.\n    /// @param moduleTypeId The module type identifier to check.\n    /// @param module The address of the module.\n    /// @param additionalContext Additional information that may be required to verify the module's installation.\n    /// @return installed True if the module is installed, false otherwise.\n    function isModuleInstalled(\n        uint256 moduleTypeId,\n        address module,\n        bytes calldata additionalContext\n    )\n        external\n        view\n        returns (bool installed);\n}\n"},"node_modules/solady/src/utils/EIP712.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Contract for EIP-712 typed structured data hashing and signing.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/EIP712.sol)\n/// @author Modified from Solbase (https://github.com/Sol-DAO/solbase/blob/main/src/utils/EIP712.sol)\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/EIP712.sol)\n///\n/// @dev Note, this implementation:\n/// - Uses `address(this)` for the `verifyingContract` field.\n/// - Does NOT use the optional EIP-712 salt.\n/// - Does NOT use any EIP-712 extensions.\n/// This is for simplicity and to save gas.\n/// If you need to customize, please fork / modify accordingly.\nabstract contract EIP712 {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                  CONSTANTS AND IMMUTABLES                  */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev `keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\")`.\n    bytes32 internal constant _DOMAIN_TYPEHASH =\n        0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;\n\n    /// @dev `keccak256(\"EIP712Domain(string name,string version,address verifyingContract)\")`.\n    /// This is only used in `_hashTypedDataSansChainId`.\n    bytes32 internal constant _DOMAIN_TYPEHASH_SANS_CHAIN_ID =\n        0x91ab3d17e3a50a9d89e63fd30b92be7f5336b03b287bb946787a83a9d62a2766;\n\n    /// @dev `keccak256(\"EIP712Domain(string name,string version)\")`.\n    /// This is only used in `_hashTypedDataSansChainIdAndVerifyingContract`.\n    bytes32 internal constant _DOMAIN_TYPEHASH_SANS_CHAIN_ID_AND_VERIFYING_CONTRACT =\n        0xb03948446334eb9b2196d5eb166f69b9d49403eb4a12f36de8d3f9f3cb8e15c3;\n\n    /// @dev `keccak256(\"EIP712Domain(string name,string version,uint256 chainId)\")`.\n    /// This is only used in `_hashTypedDataSansVerifyingContract`.\n    bytes32 internal constant _DOMAIN_TYPEHASH_SANS_VERIFYING_CONTRACT =\n        0xc2f8787176b8ac6bf7215b4adcc1e069bf4ab82d9ab1df05a57a91d425935b6e;\n\n    uint256 private immutable _cachedThis;\n    uint256 private immutable _cachedChainId;\n    bytes32 private immutable _cachedNameHash;\n    bytes32 private immutable _cachedVersionHash;\n    bytes32 private immutable _cachedDomainSeparator;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                        CONSTRUCTOR                         */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Cache the hashes for cheaper runtime gas costs.\n    /// In the case of upgradeable contracts (i.e. proxies),\n    /// or if the chain id changes due to a hard fork,\n    /// the domain separator will be seamlessly calculated on-the-fly.\n    constructor() {\n        _cachedThis = uint256(uint160(address(this)));\n        _cachedChainId = block.chainid;\n\n        string memory name;\n        string memory version;\n        if (!_domainNameAndVersionMayChange()) (name, version) = _domainNameAndVersion();\n        bytes32 nameHash = _domainNameAndVersionMayChange() ? bytes32(0) : keccak256(bytes(name));\n        bytes32 versionHash =\n            _domainNameAndVersionMayChange() ? bytes32(0) : keccak256(bytes(version));\n        _cachedNameHash = nameHash;\n        _cachedVersionHash = versionHash;\n\n        bytes32 separator;\n        if (!_domainNameAndVersionMayChange()) {\n            /// @solidity memory-safe-assembly\n            assembly {\n                let m := mload(0x40) // Load the free memory pointer.\n                mstore(m, _DOMAIN_TYPEHASH)\n                mstore(add(m, 0x20), nameHash)\n                mstore(add(m, 0x40), versionHash)\n                mstore(add(m, 0x60), chainid())\n                mstore(add(m, 0x80), address())\n                separator := keccak256(m, 0xa0)\n            }\n        }\n        _cachedDomainSeparator = separator;\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   FUNCTIONS TO OVERRIDE                    */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Please override this function to return the domain name and version.\n    /// ```\n    ///     function _domainNameAndVersion()\n    ///         internal\n    ///         pure\n    ///         virtual\n    ///         returns (string memory name, string memory version)\n    ///     {\n    ///         name = \"Solady\";\n    ///         version = \"1\";\n    ///     }\n    /// ```\n    ///\n    /// Note: If the returned result may change after the contract has been deployed,\n    /// you must override `_domainNameAndVersionMayChange()` to return true.\n    function _domainNameAndVersion()\n        internal\n        view\n        virtual\n        returns (string memory name, string memory version);\n\n    /// @dev Returns if `_domainNameAndVersion()` may change\n    /// after the contract has been deployed (i.e. after the constructor).\n    /// Default: false.\n    function _domainNameAndVersionMayChange() internal pure virtual returns (bool result) {}\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                     HASHING OPERATIONS                     */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the EIP-712 domain separator.\n    function _domainSeparator() internal view virtual returns (bytes32 separator) {\n        if (_domainNameAndVersionMayChange()) {\n            separator = _buildDomainSeparator();\n        } else {\n            separator = _cachedDomainSeparator;\n            if (_cachedDomainSeparatorInvalidated()) separator = _buildDomainSeparator();\n        }\n    }\n\n    /// @dev Returns the hash of the fully encoded EIP-712 message for this domain,\n    /// given `structHash`, as defined in\n    /// https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct.\n    ///\n    /// The hash can be used together with {ECDSA-recover} to obtain the signer of a message:\n    /// ```\n    ///     bytes32 digest = _hashTypedData(keccak256(abi.encode(\n    ///         keccak256(\"Mail(address to,string contents)\"),\n    ///         mailTo,\n    ///         keccak256(bytes(mailContents))\n    ///     )));\n    ///     address signer = ECDSA.recover(digest, signature);\n    /// ```\n    function _hashTypedData(bytes32 structHash) internal view virtual returns (bytes32 digest) {\n        // We will use `digest` to store the domain separator to save a bit of gas.\n        if (_domainNameAndVersionMayChange()) {\n            digest = _buildDomainSeparator();\n        } else {\n            digest = _cachedDomainSeparator;\n            if (_cachedDomainSeparatorInvalidated()) digest = _buildDomainSeparator();\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the digest.\n            mstore(0x00, 0x1901000000000000) // Store \"\\x19\\x01\".\n            mstore(0x1a, digest) // Store the domain separator.\n            mstore(0x3a, structHash) // Store the struct hash.\n            digest := keccak256(0x18, 0x42)\n            // Restore the part of the free memory slot that was overwritten.\n            mstore(0x3a, 0)\n        }\n    }\n\n    /// @dev Variant of `_hashTypedData` that excludes the chain ID.\n    /// Included for the niche use case of cross-chain workflows.\n    function _hashTypedDataSansChainId(bytes32 structHash)\n        internal\n        view\n        virtual\n        returns (bytes32 digest)\n    {\n        (string memory name, string memory version) = _domainNameAndVersion();\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Load the free memory pointer.\n            mstore(0x00, _DOMAIN_TYPEHASH_SANS_CHAIN_ID)\n            mstore(0x20, keccak256(add(name, 0x20), mload(name)))\n            mstore(0x40, keccak256(add(version, 0x20), mload(version)))\n            mstore(0x60, address())\n            // Compute the digest.\n            mstore(0x20, keccak256(0x00, 0x80)) // Store the domain separator.\n            mstore(0x00, 0x1901) // Store \"\\x19\\x01\".\n            mstore(0x40, structHash) // Store the struct hash.\n            digest := keccak256(0x1e, 0x42)\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero pointer.\n        }\n    }\n\n    /// @dev Variant of `_hashTypedData` that excludes the chain ID and verifying contract.\n    /// Included for the niche use case of cross-chain and multi-verifier workflows.\n    function _hashTypedDataSansChainIdAndVerifyingContract(bytes32 structHash)\n        internal\n        view\n        virtual\n        returns (bytes32 digest)\n    {\n        (string memory name, string memory version) = _domainNameAndVersion();\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Load the free memory pointer.\n            mstore(0x00, _DOMAIN_TYPEHASH_SANS_CHAIN_ID_AND_VERIFYING_CONTRACT)\n            mstore(0x20, keccak256(add(name, 0x20), mload(name)))\n            mstore(0x40, keccak256(add(version, 0x20), mload(version)))\n            // Compute the digest.\n            mstore(0x20, keccak256(0x00, 0x60)) // Store the domain separator.\n            mstore(0x00, 0x1901) // Store \"\\x19\\x01\".\n            mstore(0x40, structHash) // Store the struct hash.\n            digest := keccak256(0x1e, 0x42)\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero pointer.\n        }\n    }\n\n    /// @dev Variant of `_hashTypedData` that excludes the chain ID and verifying contract.\n    /// Included for the niche use case of multi-verifier workflows.\n    function _hashTypedDataSansVerifyingContract(bytes32 structHash)\n        internal\n        view\n        virtual\n        returns (bytes32 digest)\n    {\n        (string memory name, string memory version) = _domainNameAndVersion();\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Load the free memory pointer.\n            mstore(0x00, _DOMAIN_TYPEHASH_SANS_VERIFYING_CONTRACT)\n            mstore(0x20, keccak256(add(name, 0x20), mload(name)))\n            mstore(0x40, keccak256(add(version, 0x20), mload(version)))\n            mstore(0x60, chainid())\n            // Compute the digest.\n            mstore(0x20, keccak256(0x00, 0x80)) // Store the domain separator.\n            mstore(0x00, 0x1901) // Store \"\\x19\\x01\".\n            mstore(0x40, structHash) // Store the struct hash.\n            digest := keccak256(0x1e, 0x42)\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero pointer.\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                    EIP-5267 OPERATIONS                     */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev See: https://eips.ethereum.org/EIPS/eip-5267\n    function eip712Domain()\n        public\n        view\n        virtual\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        fields = hex\"0f\"; // `0b01111`.\n        (name, version) = _domainNameAndVersion();\n        chainId = block.chainid;\n        verifyingContract = address(this);\n        salt = salt; // `bytes32(0)`.\n        extensions = extensions; // `new uint256[](0)`.\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                      PRIVATE HELPERS                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the EIP-712 domain separator.\n    function _buildDomainSeparator() private view returns (bytes32 separator) {\n        // We will use `separator` to store the name hash to save a bit of gas.\n        bytes32 versionHash;\n        if (_domainNameAndVersionMayChange()) {\n            (string memory name, string memory version) = _domainNameAndVersion();\n            separator = keccak256(bytes(name));\n            versionHash = keccak256(bytes(version));\n        } else {\n            separator = _cachedNameHash;\n            versionHash = _cachedVersionHash;\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Load the free memory pointer.\n            mstore(m, _DOMAIN_TYPEHASH)\n            mstore(add(m, 0x20), separator) // Name hash.\n            mstore(add(m, 0x40), versionHash)\n            mstore(add(m, 0x60), chainid())\n            mstore(add(m, 0x80), address())\n            separator := keccak256(m, 0xa0)\n        }\n    }\n\n    /// @dev Returns if the cached domain separator has been invalidated.\n    function _cachedDomainSeparatorInvalidated() private view returns (bool result) {\n        uint256 cachedChainId = _cachedChainId;\n        uint256 cachedThis = _cachedThis;\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := iszero(and(eq(chainid(), cachedChainId), eq(address(), cachedThis)))\n        }\n    }\n}\n"},"node_modules/excessively-safe-call/src/ExcessivelySafeCall.sol":{"content":"// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.7.6;\n\nlibrary ExcessivelySafeCall {\n    uint256 constant LOW_28_MASK =\n        0x00000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n\n    /// @notice Use when you _really_ really _really_ don't trust the called\n    /// contract. This prevents the called contract from causing reversion of\n    /// the caller in as many ways as we can.\n    /// @dev The main difference between this and a solidity low-level call is\n    /// that we limit the number of bytes that the callee can cause to be\n    /// copied to caller memory. This prevents stupid things like malicious\n    /// contracts returning 10,000,000 bytes causing a local OOG when copying\n    /// to memory.\n    /// @param _target The address to call\n    /// @param _gas The amount of gas to forward to the remote contract\n    /// @param _value The value in wei to send to the remote contract\n    /// @param _maxCopy The maximum number of bytes of returndata to copy\n    /// to memory.\n    /// @param _calldata The data to send to the remote contract\n    /// @return success and returndata, as `.call()`. Returndata is capped to\n    /// `_maxCopy` bytes.\n    function excessivelySafeCall(\n        address _target,\n        uint256 _gas,\n        uint256 _value,\n        uint16 _maxCopy,\n        bytes memory _calldata\n    ) internal returns (bool, bytes memory) {\n        // set up for assembly call\n        uint256 _toCopy;\n        bool _success;\n        bytes memory _returnData = new bytes(_maxCopy);\n        // dispatch message to recipient\n        // by assembly calling \"handle\" function\n        // we call via assembly to avoid memcopying a very large returndata\n        // returned by a malicious contract\n        assembly {\n            _success := call(\n                _gas, // gas\n                _target, // recipient\n                _value, // ether value\n                add(_calldata, 0x20), // inloc\n                mload(_calldata), // inlen\n                0, // outloc\n                0 // outlen\n            )\n            // limit our copy to 256 bytes\n            _toCopy := returndatasize()\n            if gt(_toCopy, _maxCopy) {\n                _toCopy := _maxCopy\n            }\n            // Store the length of the copied bytes\n            mstore(_returnData, _toCopy)\n            // copy the bytes from returndata[0:_toCopy]\n            returndatacopy(add(_returnData, 0x20), 0, _toCopy)\n        }\n        return (_success, _returnData);\n    }\n\n    /// @notice Use when you _really_ really _really_ don't trust the called\n    /// contract. This prevents the called contract from causing reversion of\n    /// the caller in as many ways as we can.\n    /// @dev The main difference between this and a solidity low-level call is\n    /// that we limit the number of bytes that the callee can cause to be\n    /// copied to caller memory. This prevents stupid things like malicious\n    /// contracts returning 10,000,000 bytes causing a local OOG when copying\n    /// to memory.\n    /// @param _target The address to call\n    /// @param _gas The amount of gas to forward to the remote contract\n    /// @param _maxCopy The maximum number of bytes of returndata to copy\n    /// to memory.\n    /// @param _calldata The data to send to the remote contract\n    /// @return success and returndata, as `.call()`. Returndata is capped to\n    /// `_maxCopy` bytes.\n    function excessivelySafeStaticCall(\n        address _target,\n        uint256 _gas,\n        uint16 _maxCopy,\n        bytes memory _calldata\n    ) internal view returns (bool, bytes memory) {\n        // set up for assembly call\n        uint256 _toCopy;\n        bool _success;\n        bytes memory _returnData = new bytes(_maxCopy);\n        // dispatch message to recipient\n        // by assembly calling \"handle\" function\n        // we call via assembly to avoid memcopying a very large returndata\n        // returned by a malicious contract\n        assembly {\n            _success := staticcall(\n                _gas, // gas\n                _target, // recipient\n                add(_calldata, 0x20), // inloc\n                mload(_calldata), // inlen\n                0, // outloc\n                0 // outlen\n            )\n            // limit our copy to 256 bytes\n            _toCopy := returndatasize()\n            if gt(_toCopy, _maxCopy) {\n                _toCopy := _maxCopy\n            }\n            // Store the length of the copied bytes\n            mstore(_returnData, _toCopy)\n            // copy the bytes from returndata[0:_toCopy]\n            returndatacopy(add(_returnData, 0x20), 0, _toCopy)\n        }\n        return (_success, _returnData);\n    }\n\n    /**\n     * @notice Swaps function selectors in encoded contract calls\n     * @dev Allows reuse of encoded calldata for functions with identical\n     * argument types but different names. It simply swaps out the first 4 bytes\n     * for the new selector. This function modifies memory in place, and should\n     * only be used with caution.\n     * @param _newSelector The new 4-byte selector\n     * @param _buf The encoded contract args\n     */\n    function swapSelector(bytes4 _newSelector, bytes memory _buf)\n        internal\n        pure\n    {\n        require(_buf.length >= 4);\n        uint256 _mask = LOW_28_MASK;\n        assembly {\n            // load the first word of\n            let _word := mload(add(_buf, 0x20))\n            // mask out the top 4 bytes\n            // /x\n            _word := and(_word, _mask)\n            _word := or(_newSelector, _word)\n            mstore(add(_buf, 0x20), _word)\n        }\n    }\n}\n"},"node_modules/@erc7579/implementation/src/interfaces/IERC7579Account.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.21;\n\nimport { CallType, ExecType, ModeCode } from \"../lib/ModeLib.sol\";\n\nstruct Execution {\n    address target;\n    uint256 value;\n    bytes callData;\n}\n\ninterface IERC7579Account {\n    event ModuleInstalled(uint256 moduleTypeId, address module);\n    event ModuleUninstalled(uint256 moduleTypeId, address module);\n\n    /**\n     * @dev Executes a transaction on behalf of the account.\n     *         This function is intended to be called by ERC-4337 EntryPoint.sol\n     * @dev Ensure adequate authorization control: i.e. onlyEntryPointOrSelf\n     *\n     * @dev MSA MUST implement this function signature.\n     * If a mode is requested that is not supported by the Account, it MUST revert\n     * @param mode The encoded execution mode of the transaction. See ModeLib.sol for details\n     * @param executionCalldata The encoded execution call data\n     */\n    function execute(ModeCode mode, bytes calldata executionCalldata) external payable;\n\n    /**\n     * @dev Executes a transaction on behalf of the account.\n     *         This function is intended to be called by Executor Modules\n     * @dev Ensure adequate authorization control: i.e. onlyExecutorModule\n     *\n     * @dev MSA MUST implement this function signature.\n     * If a mode is requested that is not supported by the Account, it MUST revert\n     * @param mode The encoded execution mode of the transaction. See ModeLib.sol for details\n     * @param executionCalldata The encoded execution call data\n     */\n    function executeFromExecutor(\n        ModeCode mode,\n        bytes calldata executionCalldata\n    )\n        external\n        payable\n        returns (bytes[] memory returnData);\n\n    /**\n     * @dev ERC-1271 isValidSignature\n     *         This function is intended to be used to validate a smart account signature\n     * and may forward the call to a validator module\n     *\n     * @param hash The hash of the data that is signed\n     * @param data The data that is signed\n     */\n    function isValidSignature(bytes32 hash, bytes calldata data) external view returns (bytes4);\n\n    /**\n     * @dev installs a Module of a certain type on the smart account\n     * @dev Implement Authorization control of your chosing\n     * @param moduleTypeId the module type ID according the ERC-7579 spec\n     * @param module the module address\n     * @param initData arbitrary data that may be required on the module during `onInstall`\n     * initialization.\n     */\n    function installModule(\n        uint256 moduleTypeId,\n        address module,\n        bytes calldata initData\n    )\n        external\n        payable;\n\n    /**\n     * @dev uninstalls a Module of a certain type on the smart account\n     * @dev Implement Authorization control of your chosing\n     * @param moduleTypeId the module type ID according the ERC-7579 spec\n     * @param module the module address\n     * @param deInitData arbitrary data that may be required on the module during `onUninstall`\n     * de-initialization.\n     */\n    function uninstallModule(\n        uint256 moduleTypeId,\n        address module,\n        bytes calldata deInitData\n    )\n        external\n        payable;\n\n    /**\n     * Function to check if the account supports a certain CallType or ExecType (see ModeLib.sol)\n     * @param encodedMode the encoded mode\n     */\n    function supportsExecutionMode(ModeCode encodedMode) external view returns (bool);\n\n    /**\n     * Function to check if the account supports installation of a certain module type Id\n     * @param moduleTypeId the module type ID according the ERC-7579 spec\n     */\n    function supportsModule(uint256 moduleTypeId) external view returns (bool);\n\n    /**\n     * Function to check if the account has a certain module installed\n     * @param moduleTypeId the module type ID according the ERC-7579 spec\n     *      Note: keep in mind that some contracts can be multiple module types at the same time. It\n     *            thus may be necessary to query multiple module types\n     * @param module the module address\n     * @param additionalContext additional context data that the smart account may interpret to\n     *                          identifiy conditions under which the module is installed.\n     *                          usually this is not necessary, but for some special hooks that\n     *                          are stored in mappings, this param might be needed\n     */\n    function isModuleInstalled(\n        uint256 moduleTypeId,\n        address module,\n        bytes calldata additionalContext\n    )\n        external\n        view\n        returns (bool);\n\n    /**\n     * @dev Returns the account id of the smart account\n     * @return accountImplementationId the account id of the smart account\n     * the accountId should be structured like so:\n     *        \"vendorname.accountname.semver\"\n     */\n    function accountId() external view returns (string memory accountImplementationId);\n}\n"},"contracts/interfaces/nexus/base/IExecutionHelper.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\n// ──────────────────────────────────────────────────────────────────────────────\n//     _   __    _  __\n//    / | / /__ | |/ /_  _______\n//   /  |/ / _ \\|   / / / / ___/\n//  / /|  /  __/   / /_/ (__  )\n// /_/ |_/\\___/_/|_\\__,_/____/\n//\n// ──────────────────────────────────────────────────────────────────────────────\n// Nexus: A suite of contracts for Modular Smart Accounts compliant with ERC-7579 and ERC-4337, developed by Biconomy.\n// Learn more at https://biconomy.io. To report security issues, please contact us at: security@biconomy.io\n\nimport { ExecutionMode } from \"../../../lib/erc-7579/ModeLib.sol\";\nimport { IExecutionHelperEventsAndErrors } from \"./IExecutionHelperEventsAndErrors.sol\";\nimport { PackedUserOperation } from \"account-abstraction/interfaces/PackedUserOperation.sol\";\n\n/// @title Nexus - IExecutionHelper\n/// @notice Interface for executing transactions on behalf of smart accounts within the Nexus system.\n/// @dev Extends functionality for transaction execution with error handling as defined in\n/// IExecutionHelperEventsAndErrors.\n/// @author @livingrockrises | Biconomy | chirag@biconomy.io\n/// @author @aboudjem | Biconomy | adam.boudjemaa@biconomy.io\n/// @author @filmakarov | Biconomy | filipp.makarov@biconomy.io\n/// @author @zeroknots | Rhinestone.wtf | zeroknots.eth\n/// Special thanks to the Solady team for foundational contributions: https://github.com/Vectorized/solady\ninterface IExecutionHelper is IExecutionHelperEventsAndErrors {\n    /// @notice Executes a transaction with specified execution mode and calldata.\n    /// @param mode The execution mode, defining how the transaction is processed.\n    /// @param executionCalldata The calldata to execute.\n    /// @dev This function ensures that the execution complies with smart account execution policies and handles errors\n    /// appropriately.\n    function execute(ExecutionMode mode, bytes calldata executionCalldata) external payable;\n\n    /// @notice Allows an executor module to perform transactions on behalf of the account.\n    /// @param mode The execution mode that details how the transaction should be handled.\n    /// @param executionCalldata The transaction data to be executed.\n    /// @return returnData The result of the execution, allowing for error handling and results interpretation by the\n    /// executor module.\n    function executeFromExecutor(\n        ExecutionMode mode,\n        bytes calldata executionCalldata\n    )\n        external\n        payable\n        returns (bytes[] memory returnData);\n\n    /**\n     * Account may implement this execute method.\n     * passing this methodSig at the beginning of callData will cause the entryPoint to pass the full UserOp (and hash)\n     * to the account.\n     * The account should skip the methodSig, and use the callData (and optionally, other UserOp fields)\n     *\n     * @param userOp              - The operation that was just validated.\n     * @param userOpHash          - Hash of the user's request data.\n     */\n    function executeUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash) external payable;\n}\n"},"contracts/composability/ComposableExecutionLib.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\nimport { ComposableStorage } from \"./ComposableStorage.sol\";\nimport {\n    InputParam,\n    OutputParam,\n    Constraint,\n    ConstraintType,\n    InputParamType,\n    InputParamFetcherType,\n    OutputParamFetcherType\n} from \"../types/ComposabilityDataTypes.sol\";\nimport { Execution } from \"erc7579/interfaces/IERC7579Account.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n// Library for composable execution handling\nlibrary ComposableExecutionLib {\n    error ConstraintNotMet(ConstraintType constraintType);\n    error Output_StaticCallFailed();\n    error InvalidParameterEncoding(string message);\n    error InvalidOutputParamFetcherType();\n    error InvalidConstraintType();\n    error InvalidSetOfInputParams(string message);\n\n    // Process the input parameters and return the composed calldata\n    function processInputs(\n        InputParam[] calldata inputParams,\n        bytes4 functionSig\n    )\n        internal\n        view\n        returns (Execution memory)\n    {\n        address composedTarget;\n        uint256 composedValue;\n        bytes memory composedCalldata = abi.encodePacked(functionSig);\n        uint256 length = inputParams.length;\n\n        // Bit 0: TARGET param type set, Bit 1: VALUE param type set\n        uint256 paramTypeFlags = 0;\n        for (uint256 i; i < length; i++) {\n            bytes memory processedInput = processInput(inputParams[i]);\n            if (inputParams[i].paramType == InputParamType.TARGET) {\n                if (inputParams[i].fetcherType == InputParamFetcherType.BALANCE) {\n                    revert InvalidParameterEncoding(\"BALANCE fetcher type is not supported for TARGET param type\");\n                }\n                // Check if TARGET has already been set (bit 0)\n                if (paramTypeFlags & 1 != 0) {\n                    revert InvalidSetOfInputParams(\"TARGET param type can only be set once\");\n                }\n                paramTypeFlags |= 1; // Set bit 0\n                composedTarget = abi.decode(processedInput, (address));\n            } else if (inputParams[i].paramType == InputParamType.VALUE) {\n                // Check if VALUE has already been set (bit 1)\n                if (paramTypeFlags & 2 != 0) {\n                    revert InvalidSetOfInputParams(\"VALUE param type can only be set once\");\n                }\n                paramTypeFlags |= 2; // Set bit 1\n                composedValue = abi.decode(processedInput, (uint256));\n            } else if (inputParams[i].paramType == InputParamType.CALL_DATA) {\n                composedCalldata = bytes.concat(composedCalldata, processedInput);\n            } else {\n                revert InvalidParameterEncoding(\"Invalid param type\");\n            }\n        }\n        // if a param with TARGET type was not provided, it will be address(0)\n        // we don't restrict it since some calls may want to call address(0)\n        // if a param with VALUE type was not provided, it will be 0\n        // this is even more often case, as many calls happen with 0 value\n        return Execution({ target: composedTarget, value: composedValue, callData: composedCalldata });\n    }\n\n    // Process a single input parameter and return the composed calldata\n    function processInput(InputParam calldata param) internal view returns (bytes memory) {\n        if (param.fetcherType == InputParamFetcherType.RAW_BYTES) {\n            _validateConstraints(param.paramData, param.constraints);\n            return param.paramData;\n        } else if (param.fetcherType == InputParamFetcherType.STATIC_CALL) {\n            address contractAddr;\n            bytes calldata callData;\n            bytes calldata paramData = param.paramData;\n            // expect paramData to be abi.encode(address contractAddr, bytes callData)\n            assembly {\n                contractAddr := calldataload(paramData.offset)\n                let s := calldataload(add(paramData.offset, 0x20))\n                let u := add(paramData.offset, s)\n                callData.offset := add(u, 0x20)\n                callData.length := calldataload(u)\n            }\n            (bool success, bytes memory returnData) = contractAddr.staticcall(callData);\n            assembly {\n                if iszero(success) {\n                    // revert ComposableExecutionFailed()\n                    mstore(0x00, 0x6533cc8d)\n                    revert(0x1c, 0x04)\n                }\n            }\n            _validateConstraints(returnData, param.constraints);\n            return returnData;\n        } else if (param.fetcherType == InputParamFetcherType.BALANCE) {\n            address tokenAddr;\n            address account;\n            bytes calldata paramData = param.paramData;\n\n            // expect paramData to be abi.encodePacked(address token, address account)\n            // Validate exact length requirement\n            require(paramData.length == 40, InvalidParameterEncoding(\"Invalid paramData length\"));\n            assembly {\n                tokenAddr := shr(96, calldataload(paramData.offset))\n                account := shr(96, calldataload(add(paramData.offset, 0x14)))\n            }\n\n            uint256 balance;\n            if (tokenAddr == address(0)) {\n                balance = account.balance;\n            } else {\n                balance = IERC20(tokenAddr).balanceOf(account);\n            }\n            _validateConstraints(abi.encode(balance), param.constraints);\n            return abi.encode(balance);\n        } else {\n            revert InvalidParameterEncoding(\"Invalid param fetcher type\");\n        }\n    }\n\n    // Process the output parameters\n    function processOutputs(OutputParam[] calldata outputParams, bytes memory returnData, address account) internal {\n        uint256 length = outputParams.length;\n        for (uint256 i; i < length; i++) {\n            processOutput(outputParams[i], returnData, account);\n        }\n    }\n\n    // Process a single output parameter and write to storage\n    function processOutput(OutputParam calldata param, bytes memory returnData, address account) internal {\n        // only static types are supported for now as return values\n        // can also process all the static return values which are before the first dynamic return value in the\n        // returnData\n        if (param.fetcherType == OutputParamFetcherType.EXEC_RESULT) {\n            uint256 returnValues;\n            address targetStorageContract;\n            bytes32 targetStorageSlot;\n            bytes calldata paramData = param.paramData;\n            assembly {\n                returnValues := calldataload(paramData.offset)\n                targetStorageContract := calldataload(add(paramData.offset, 0x20))\n                targetStorageSlot := calldataload(add(paramData.offset, 0x40))\n            }\n            _parseReturnDataAndWriteToStorage(\n                returnValues, returnData, targetStorageContract, targetStorageSlot, account\n            );\n            // same for static calls\n        } else if (param.fetcherType == OutputParamFetcherType.STATIC_CALL) {\n            uint256 returnValues;\n            address sourceContract;\n            bytes calldata sourceCallData;\n            address targetStorageContract;\n            bytes32 targetStorageSlot;\n            bytes calldata paramData = param.paramData;\n            assembly {\n                returnValues := calldataload(paramData.offset)\n                sourceContract := calldataload(add(paramData.offset, 0x20))\n                let s := calldataload(add(paramData.offset, 0x40))\n                let u := add(paramData.offset, s)\n                sourceCallData.offset := add(u, 0x20)\n                sourceCallData.length := calldataload(u)\n                targetStorageContract := calldataload(add(paramData.offset, 0x60))\n                targetStorageSlot := calldataload(add(paramData.offset, 0x80))\n            }\n            (bool outputSuccess, bytes memory outputReturnData) = sourceContract.staticcall(sourceCallData);\n            if (!outputSuccess) {\n                revert Output_StaticCallFailed();\n            }\n            _parseReturnDataAndWriteToStorage(\n                returnValues, outputReturnData, targetStorageContract, targetStorageSlot, account\n            );\n        } else {\n            revert InvalidOutputParamFetcherType();\n        }\n    }\n\n    /// @dev Validate the constraints => compare the value with the reference data\n    function _validateConstraints(bytes memory rawValue, Constraint[] calldata constraints) private pure {\n        if (constraints.length > 0) {\n            for (uint256 i; i < constraints.length; i++) {\n                Constraint memory constraint = constraints[i];\n                bytes32 returnValue;\n                assembly {\n                    returnValue := mload(add(rawValue, add(0x20, mul(i, 0x20))))\n                }\n                if (constraint.constraintType == ConstraintType.EQ) {\n                    require(returnValue == bytes32(constraint.referenceData), ConstraintNotMet(ConstraintType.EQ));\n                } else if (constraint.constraintType == ConstraintType.GTE) {\n                    require(returnValue >= bytes32(constraint.referenceData), ConstraintNotMet(ConstraintType.GTE));\n                } else if (constraint.constraintType == ConstraintType.LTE) {\n                    require(returnValue <= bytes32(constraint.referenceData), ConstraintNotMet(ConstraintType.LTE));\n                } else if (constraint.constraintType == ConstraintType.IN) {\n                    (bytes32 lowerBound, bytes32 upperBound) = abi.decode(constraint.referenceData, (bytes32, bytes32));\n                    require(returnValue >= lowerBound && returnValue <= upperBound, ConstraintNotMet(ConstraintType.IN));\n                } else {\n                    revert InvalidConstraintType();\n                }\n            }\n        }\n    }\n\n    /// @dev Parse the return data and write to the appropriate storage contract\n    function _parseReturnDataAndWriteToStorage(\n        uint256 returnValues,\n        bytes memory returnData,\n        address targetStorageContract,\n        bytes32 targetStorageSlot,\n        address account\n    )\n        internal\n    {\n        for (uint256 i; i < returnValues; i++) {\n            bytes32 value;\n            assembly {\n                value := mload(add(returnData, add(0x20, mul(i, 0x20))))\n            }\n            ComposableStorage(targetStorageContract)\n                .writeStorage({\n                    slot: keccak256(abi.encodePacked(targetStorageSlot, i)), value: value, account: account\n                });\n        }\n    }\n}\n"},"contracts/types/ComposabilityDataTypes.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\n// Type of the input parameter\nenum InputParamType {\n    TARGET, // The target address\n    VALUE, // The value\n    CALL_DATA // The call data\n}\n\n// Parameter type for composition\nenum InputParamFetcherType {\n    RAW_BYTES, // Already encoded bytes\n    STATIC_CALL, // Perform a static call\n    BALANCE // Get the balance of an address\n}\n\nenum OutputParamFetcherType {\n    EXEC_RESULT, // The return of the execution call\n    STATIC_CALL // Call to some other function\n}\n\n// Constraint type for parameter validation\nenum ConstraintType {\n    EQ, // Equal to\n    GTE, // Greater than or equal to\n    LTE, // Less than or equal to\n    IN // In range\n}\n\n// Constraint for parameter validation\nstruct Constraint {\n    ConstraintType constraintType;\n    bytes referenceData;\n}\n\n// Structure to define parameter composition\nstruct InputParam {\n    InputParamType paramType;\n    InputParamFetcherType fetcherType; // How to fetch the parameter\n    bytes paramData;\n    Constraint[] constraints;\n}\n\n// Structure to define return value handling\nstruct OutputParam {\n    OutputParamFetcherType fetcherType; // How to fetch the parameter\n    bytes paramData;\n}\n\n// Structure to define a composable execution\nstruct ComposableExecution {\n    bytes4 functionSig;\n    InputParam[] inputParams;\n    OutputParam[] outputParams;\n}\n"},"contracts/interfaces/IComposableExecution.sol":{"content":"// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity ^0.8.23;\n\nimport { ComposableExecution } from \"../types/ComposabilityDataTypes.sol\";\n\ninterface IComposableExecution {\n    function executeComposable(ComposableExecution[] calldata cExecutions) external payable;\n}\n\ninterface IComposableExecutionModule is IComposableExecution {\n    function executeComposableCall(ComposableExecution[] calldata cExecutions) external;\n    function executeComposableDelegateCall(ComposableExecution[] calldata cExecutions) external;\n}\n"},"node_modules/solady/src/utils/CallContextChecker.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Call context checker mixin.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/CallContextChecker.sol)\ncontract CallContextChecker {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The call is from an unauthorized call context.\n    error UnauthorizedCallContext();\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         IMMUTABLES                         */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev For checking if the context is a delegate call.\n    ///\n    /// Note: To enable use cases with an immutable default implementation in the bytecode,\n    /// (see: ERC6551Proxy), we don't require that the proxy address must match the\n    /// value stored in the implementation slot, which may not be initialized.\n    uint256 private immutable __self = uint256(uint160(address(this)));\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                    CALL CONTEXT CHECKS                     */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    // A proxy call can be either via a `delegatecall` to an implementation,\n    // or a 7702 call on an authority that points to a delegation.\n\n    /// @dev Returns whether the current call context is on a EIP7702 authority\n    /// (i.e. externally owned account).\n    function _onEIP7702Authority() internal view virtual returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            extcodecopy(address(), 0x00, 0x00, 0x20)\n            // Note: Checking that it starts with hex\"ef01\" is the most general and futureproof.\n            // 7702 bytecode is `abi.encodePacked(hex\"ef01\", uint8(version), address(delegation))`.\n            result := eq(0xef01, shr(240, mload(0x00)))\n        }\n    }\n\n    /// @dev Returns the implementation of this contract.\n    function _selfImplementation() internal view virtual returns (address) {\n        return address(uint160(__self));\n    }\n\n    /// @dev Returns whether the current call context is on the implementation itself.\n    function _onImplementation() internal view virtual returns (bool) {\n        return __self == uint160(address(this));\n    }\n\n    /// @dev Requires that the current call context is performed via a EIP7702 authority.\n    function _checkOnlyEIP7702Authority() internal view virtual {\n        if (!_onEIP7702Authority()) _revertUnauthorizedCallContext();\n    }\n\n    /// @dev Requires that the current call context is performed via a proxy.\n    function _checkOnlyProxy() internal view virtual {\n        if (_onImplementation()) _revertUnauthorizedCallContext();\n    }\n\n    /// @dev Requires that the current call context is NOT performed via a proxy.\n    /// This is the opposite of `checkOnlyProxy`.\n    function _checkNotDelegated() internal view virtual {\n        if (!_onImplementation()) _revertUnauthorizedCallContext();\n    }\n\n    /// @dev Requires that the current call context is performed via a EIP7702 authority.\n    modifier onlyEIP7702Authority() virtual {\n        _checkOnlyEIP7702Authority();\n        _;\n    }\n\n    /// @dev Requires that the current call context is performed via a proxy.\n    modifier onlyProxy() virtual {\n        _checkOnlyProxy();\n        _;\n    }\n\n    /// @dev Requires that the current call context is NOT performed via a proxy.\n    /// This is the opposite of `onlyProxy`.\n    modifier notDelegated() virtual {\n        _checkNotDelegated();\n        _;\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                      PRIVATE HELPERS                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    function _revertUnauthorizedCallContext() private pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, 0x9f03a026) // `UnauthorizedCallContext()`.\n            revert(0x1c, 0x04)\n        }\n    }\n}\n"},"contracts/interfaces/nexus/base/IAccountConfig.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\n// ──────────────────────────────────────────────────────────────────────────────\n//     _   __    _  __\n//    / | / /__ | |/ /_  _______\n//   /  |/ / _ \\|   / / / / ___/\n//  / /|  /  __/   / /_/ (__  )\n// /_/ |_/\\___/_/|_\\__,_/____/\n//\n// ──────────────────────────────────────────────────────────────────────────────\n// Nexus: A suite of contracts for Modular Smart Accounts compliant with ERC-7579 and ERC-4337, developed by Biconomy.\n// Learn more at https://biconomy.io. To report security issues, please contact us at: security@biconomy.io\n\nimport { ExecutionMode } from \"../../../lib/erc-7579/ModeLib.sol\";\n\n/// @title Nexus - ERC-7579 Account Configuration Interface\n/// @notice Interface for querying and verifying configurations of Smart Accounts compliant with ERC-7579.\n/// @dev Provides methods to check supported execution modes and module types for Smart Accounts, ensuring flexible and\n/// extensible configuration.\n/// @author @livingrockrises | Biconomy | chirag@biconomy.io\n/// @author @aboudjem | Biconomy | adam.boudjemaa@biconomy.io\n/// @author @filmakarov | Biconomy | filipp.makarov@biconomy.io\n/// @author @zeroknots | Rhinestone.wtf | zeroknots.eth\n/// Special thanks to the Solady team for foundational contributions: https://github.com/Vectorized/solady\ninterface IAccountConfig {\n    /// @notice Returns the account ID in a structured format: \"vendorname.accountname.semver\"\n    /// @return accountImplementationId The account ID of the smart account\n    function accountId() external view returns (string memory accountImplementationId);\n\n    /// @notice Checks if the account supports a certain execution mode.\n    /// @param encodedMode The encoded mode to verify.\n    /// @return supported True if the account supports the mode, false otherwise.\n    function supportsExecutionMode(ExecutionMode encodedMode) external view returns (bool supported);\n\n    /// @notice Checks if the account supports a specific module type.\n    /// @param moduleTypeId The module type ID to verify.\n    /// @return supported True if the account supports the module type, false otherwise.\n    function supportsModule(uint256 moduleTypeId) external view returns (bool supported);\n}\n"},"contracts/interfaces/nexus/INexusEventsAndErrors.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\n// ──────────────────────────────────────────────────────────────────────────────\n//     _   __    _  __\n//    / | / /__ | |/ /_  _______\n//   /  |/ / _ \\|   / / / / ___/\n//  / /|  /  __/   / /_/ (__  )\n// /_/ |_/\\___/_/|_\\__,_/____/\n//\n// ──────────────────────────────────────────────────────────────────────────────\n// Nexus: A suite of contracts for Modular Smart Accounts compliant with ERC-7579 and ERC-4337, developed by Biconomy.\n// Learn more at https://biconomy.io. To report security issues, please contact us at: security@biconomy.io\n\n/// @title Nexus - INexus Events and Errors\n/// @notice Defines common errors for the Nexus smart account management interface.\n/// @author @livingrockrises | Biconomy | chirag@biconomy.io\n/// @author @aboudjem | Biconomy | adam.boudjemaa@biconomy.io\n/// @author @filmakarov | Biconomy | filipp.makarov@biconomy.io\n/// @author @zeroknots | Rhinestone.wtf | zeroknots.eth\n/// Special thanks to the Solady team for foundational contributions: https://github.com/Vectorized/solady\ninterface INexusEventsAndErrors {\n    /// @notice Error thrown when an unsupported ModuleType is requested.\n    /// @param moduleTypeId The ID of the unsupported module type.\n    error UnsupportedModuleType(uint256 moduleTypeId);\n\n    /// @notice Error thrown when a zero address is provided as the Entry Point address.\n    error EntryPointCanNotBeZero();\n\n    /// @notice Error thrown when the provided implementation address is invalid.\n    error InvalidImplementationAddress();\n\n    /// @notice Error thrown when attempted to emergency-uninstall a hook\n    error EmergencyTimeLockNotExpired();\n\n    /// @notice Error thrown when attempted to upgrade an ERC7702 account via UUPS proxy upgrade mechanism\n    error ERC7702AccountCannotBeUpgradedThisWay();\n\n    /// @notice Error thrown when the provided initData is invalid.\n    error InvalidInitData();\n\n    /// @notice Error thrown when the account is already initialized.\n    error AccountAlreadyInitialized();\n\n    /// @notice Error thrown when the account is not initialized but expected to be.\n    error AccountNotInitialized();\n\n    /// @notice Error thrown when the provided signature is invalid.\n    error InvalidSignature();\n}\n"},"contracts/interfaces/standard/IERC1271.sol":{"content":"// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity ^0.8.27;\n\ninterface IERC1271 {\n    /**\n     * @dev Should return whether the signature provided is valid for the provided data\n     * @param _dataHash Arbitrary length data signed on behalf of address(this)\n     * @param _signature Signature byte array associated with _data\n     *\n     * MUST return the bytes4 magic value 0x1626ba7e when function passes.\n     * MUST NOT modify state (using STATICCALL for solc < 0.5, view modifier for solc >\n     * 0.5)\n     * MUST allow external calls\n     */\n    function isValidSignature(bytes32 _dataHash, bytes calldata _signature) external view returns (bytes4);\n}\n"},"node_modules/account-abstraction/contracts/interfaces/IAccount.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.5;\n\nimport \"./PackedUserOperation.sol\";\n\ninterface IAccount {\n    /**\n     * Validate user's signature and nonce\n     * the entryPoint will make the call to the recipient only if this validation call returns successfully.\n     * signature failure should be reported by returning SIG_VALIDATION_FAILED (1).\n     * This allows making a \"simulation call\" without a valid signature\n     * Other failures (e.g. nonce mismatch, or invalid signature format) should still revert to signal failure.\n     *\n     * @dev Must validate caller is the entryPoint.\n     *      Must validate the signature and nonce\n     * @param userOp              - The operation that is about to be executed.\n     * @param userOpHash          - Hash of the user's request data. can be used as the basis for signature.\n     * @param missingAccountFunds - Missing funds on the account's deposit in the entrypoint.\n     *                              This is the minimum amount to transfer to the sender(entryPoint) to be\n     *                              able to make the call. The excess is left as a deposit in the entrypoint\n     *                              for future calls. Can be withdrawn anytime using \"entryPoint.withdrawTo()\".\n     *                              In case there is a paymaster in the request (or the current deposit is high\n     *                              enough), this value will be zero.\n     * @return validationData       - Packaged ValidationData structure. use `_packValidationData` and\n     *                              `_unpackValidationData` to encode and decode.\n     *                              <20-byte> sigAuthorizer - 0 for valid signature, 1 to mark signature failure,\n     *                                 otherwise, an address of an \"authorizer\" contract.\n     *                              <6-byte> validUntil - Last timestamp this operation is valid. 0 for \"indefinite\"\n     *                              <6-byte> validAfter - First timestamp this operation is valid\n     *                                                    If an account doesn't use time-range, it is enough to\n     *                                                    return SIG_VALIDATION_FAILED value (1) for signature failure.\n     *                              Note that the validation code cannot use block.timestamp (or block.number) directly.\n     */\n    function validateUserOp(\n        PackedUserOperation calldata userOp,\n        bytes32 userOpHash,\n        uint256 missingAccountFunds\n    ) external returns (uint256 validationData);\n}\n"},"node_modules/solady/src/utils/EfficientHashLib.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Library for efficiently performing keccak256 hashes.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/EfficientHashLib.sol)\n/// @dev To avoid stack-too-deep, you can use:\n/// ```\n/// bytes32[] memory buffer = EfficientHashLib.malloc(10);\n/// EfficientHashLib.set(buffer, 0, value0);\n/// ..\n/// EfficientHashLib.set(buffer, 9, value9);\n/// bytes32 finalHash = EfficientHashLib.hash(buffer);\n/// ```\nlibrary EfficientHashLib {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*               MALLOC-LESS HASHING OPERATIONS               */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns `keccak256(abi.encode(v0))`.\n    function hash(bytes32 v0) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, v0)\n            result := keccak256(0x00, 0x20)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0))`.\n    function hash(uint256 v0) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, v0)\n            result := keccak256(0x00, 0x20)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, v1))`.\n    function hash(bytes32 v0, bytes32 v1) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, v0)\n            mstore(0x20, v1)\n            result := keccak256(0x00, 0x40)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, v1))`.\n    function hash(uint256 v0, uint256 v1) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, v0)\n            mstore(0x20, v1)\n            result := keccak256(0x00, 0x40)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, v1, v2))`.\n    function hash(bytes32 v0, bytes32 v1, bytes32 v2) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            result := keccak256(m, 0x60)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, v1, v2))`.\n    function hash(uint256 v0, uint256 v1, uint256 v2) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            result := keccak256(m, 0x60)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, v1, v2, v3))`.\n    function hash(bytes32 v0, bytes32 v1, bytes32 v2, bytes32 v3)\n        internal\n        pure\n        returns (bytes32 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            result := keccak256(m, 0x80)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, v1, v2, v3))`.\n    function hash(uint256 v0, uint256 v1, uint256 v2, uint256 v3)\n        internal\n        pure\n        returns (bytes32 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            result := keccak256(m, 0x80)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, .., v4))`.\n    function hash(bytes32 v0, bytes32 v1, bytes32 v2, bytes32 v3, bytes32 v4)\n        internal\n        pure\n        returns (bytes32 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            result := keccak256(m, 0xa0)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, .., v4))`.\n    function hash(uint256 v0, uint256 v1, uint256 v2, uint256 v3, uint256 v4)\n        internal\n        pure\n        returns (bytes32 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            result := keccak256(m, 0xa0)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, .., v5))`.\n    function hash(bytes32 v0, bytes32 v1, bytes32 v2, bytes32 v3, bytes32 v4, bytes32 v5)\n        internal\n        pure\n        returns (bytes32 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            result := keccak256(m, 0xc0)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, .., v5))`.\n    function hash(uint256 v0, uint256 v1, uint256 v2, uint256 v3, uint256 v4, uint256 v5)\n        internal\n        pure\n        returns (bytes32 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            result := keccak256(m, 0xc0)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, .., v6))`.\n    function hash(\n        bytes32 v0,\n        bytes32 v1,\n        bytes32 v2,\n        bytes32 v3,\n        bytes32 v4,\n        bytes32 v5,\n        bytes32 v6\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            result := keccak256(m, 0xe0)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, .., v6))`.\n    function hash(\n        uint256 v0,\n        uint256 v1,\n        uint256 v2,\n        uint256 v3,\n        uint256 v4,\n        uint256 v5,\n        uint256 v6\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            result := keccak256(m, 0xe0)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, .., v7))`.\n    function hash(\n        bytes32 v0,\n        bytes32 v1,\n        bytes32 v2,\n        bytes32 v3,\n        bytes32 v4,\n        bytes32 v5,\n        bytes32 v6,\n        bytes32 v7\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            mstore(add(m, 0xe0), v7)\n            result := keccak256(m, 0x100)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, .., v7))`.\n    function hash(\n        uint256 v0,\n        uint256 v1,\n        uint256 v2,\n        uint256 v3,\n        uint256 v4,\n        uint256 v5,\n        uint256 v6,\n        uint256 v7\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            mstore(add(m, 0xe0), v7)\n            result := keccak256(m, 0x100)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, .., v8))`.\n    function hash(\n        bytes32 v0,\n        bytes32 v1,\n        bytes32 v2,\n        bytes32 v3,\n        bytes32 v4,\n        bytes32 v5,\n        bytes32 v6,\n        bytes32 v7,\n        bytes32 v8\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            mstore(add(m, 0xe0), v7)\n            mstore(add(m, 0x100), v8)\n            result := keccak256(m, 0x120)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, .., v8))`.\n    function hash(\n        uint256 v0,\n        uint256 v1,\n        uint256 v2,\n        uint256 v3,\n        uint256 v4,\n        uint256 v5,\n        uint256 v6,\n        uint256 v7,\n        uint256 v8\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            mstore(add(m, 0xe0), v7)\n            mstore(add(m, 0x100), v8)\n            result := keccak256(m, 0x120)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, .., v9))`.\n    function hash(\n        bytes32 v0,\n        bytes32 v1,\n        bytes32 v2,\n        bytes32 v3,\n        bytes32 v4,\n        bytes32 v5,\n        bytes32 v6,\n        bytes32 v7,\n        bytes32 v8,\n        bytes32 v9\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            mstore(add(m, 0xe0), v7)\n            mstore(add(m, 0x100), v8)\n            mstore(add(m, 0x120), v9)\n            result := keccak256(m, 0x140)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, .., v9))`.\n    function hash(\n        uint256 v0,\n        uint256 v1,\n        uint256 v2,\n        uint256 v3,\n        uint256 v4,\n        uint256 v5,\n        uint256 v6,\n        uint256 v7,\n        uint256 v8,\n        uint256 v9\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            mstore(add(m, 0xe0), v7)\n            mstore(add(m, 0x100), v8)\n            mstore(add(m, 0x120), v9)\n            result := keccak256(m, 0x140)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, .., v10))`.\n    function hash(\n        bytes32 v0,\n        bytes32 v1,\n        bytes32 v2,\n        bytes32 v3,\n        bytes32 v4,\n        bytes32 v5,\n        bytes32 v6,\n        bytes32 v7,\n        bytes32 v8,\n        bytes32 v9,\n        bytes32 v10\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            mstore(add(m, 0xe0), v7)\n            mstore(add(m, 0x100), v8)\n            mstore(add(m, 0x120), v9)\n            mstore(add(m, 0x140), v10)\n            result := keccak256(m, 0x160)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, .., v10))`.\n    function hash(\n        uint256 v0,\n        uint256 v1,\n        uint256 v2,\n        uint256 v3,\n        uint256 v4,\n        uint256 v5,\n        uint256 v6,\n        uint256 v7,\n        uint256 v8,\n        uint256 v9,\n        uint256 v10\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            mstore(add(m, 0xe0), v7)\n            mstore(add(m, 0x100), v8)\n            mstore(add(m, 0x120), v9)\n            mstore(add(m, 0x140), v10)\n            result := keccak256(m, 0x160)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, .., v11))`.\n    function hash(\n        bytes32 v0,\n        bytes32 v1,\n        bytes32 v2,\n        bytes32 v3,\n        bytes32 v4,\n        bytes32 v5,\n        bytes32 v6,\n        bytes32 v7,\n        bytes32 v8,\n        bytes32 v9,\n        bytes32 v10,\n        bytes32 v11\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            mstore(add(m, 0xe0), v7)\n            mstore(add(m, 0x100), v8)\n            mstore(add(m, 0x120), v9)\n            mstore(add(m, 0x140), v10)\n            mstore(add(m, 0x160), v11)\n            result := keccak256(m, 0x180)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, .., v11))`.\n    function hash(\n        uint256 v0,\n        uint256 v1,\n        uint256 v2,\n        uint256 v3,\n        uint256 v4,\n        uint256 v5,\n        uint256 v6,\n        uint256 v7,\n        uint256 v8,\n        uint256 v9,\n        uint256 v10,\n        uint256 v11\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            mstore(add(m, 0xe0), v7)\n            mstore(add(m, 0x100), v8)\n            mstore(add(m, 0x120), v9)\n            mstore(add(m, 0x140), v10)\n            mstore(add(m, 0x160), v11)\n            result := keccak256(m, 0x180)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, .., v12))`.\n    function hash(\n        bytes32 v0,\n        bytes32 v1,\n        bytes32 v2,\n        bytes32 v3,\n        bytes32 v4,\n        bytes32 v5,\n        bytes32 v6,\n        bytes32 v7,\n        bytes32 v8,\n        bytes32 v9,\n        bytes32 v10,\n        bytes32 v11,\n        bytes32 v12\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            mstore(add(m, 0xe0), v7)\n            mstore(add(m, 0x100), v8)\n            mstore(add(m, 0x120), v9)\n            mstore(add(m, 0x140), v10)\n            mstore(add(m, 0x160), v11)\n            mstore(add(m, 0x180), v12)\n            result := keccak256(m, 0x1a0)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, .., v12))`.\n    function hash(\n        uint256 v0,\n        uint256 v1,\n        uint256 v2,\n        uint256 v3,\n        uint256 v4,\n        uint256 v5,\n        uint256 v6,\n        uint256 v7,\n        uint256 v8,\n        uint256 v9,\n        uint256 v10,\n        uint256 v11,\n        uint256 v12\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            mstore(add(m, 0xe0), v7)\n            mstore(add(m, 0x100), v8)\n            mstore(add(m, 0x120), v9)\n            mstore(add(m, 0x140), v10)\n            mstore(add(m, 0x160), v11)\n            mstore(add(m, 0x180), v12)\n            result := keccak256(m, 0x1a0)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, .., v13))`.\n    function hash(\n        bytes32 v0,\n        bytes32 v1,\n        bytes32 v2,\n        bytes32 v3,\n        bytes32 v4,\n        bytes32 v5,\n        bytes32 v6,\n        bytes32 v7,\n        bytes32 v8,\n        bytes32 v9,\n        bytes32 v10,\n        bytes32 v11,\n        bytes32 v12,\n        bytes32 v13\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            mstore(add(m, 0xe0), v7)\n            mstore(add(m, 0x100), v8)\n            mstore(add(m, 0x120), v9)\n            mstore(add(m, 0x140), v10)\n            mstore(add(m, 0x160), v11)\n            mstore(add(m, 0x180), v12)\n            mstore(add(m, 0x1a0), v13)\n            result := keccak256(m, 0x1c0)\n        }\n    }\n\n    /// @dev Returns `keccak256(abi.encode(v0, .., v13))`.\n    function hash(\n        uint256 v0,\n        uint256 v1,\n        uint256 v2,\n        uint256 v3,\n        uint256 v4,\n        uint256 v5,\n        uint256 v6,\n        uint256 v7,\n        uint256 v8,\n        uint256 v9,\n        uint256 v10,\n        uint256 v11,\n        uint256 v12,\n        uint256 v13\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            mstore(add(m, 0xe0), v7)\n            mstore(add(m, 0x100), v8)\n            mstore(add(m, 0x120), v9)\n            mstore(add(m, 0x140), v10)\n            mstore(add(m, 0x160), v11)\n            mstore(add(m, 0x180), v12)\n            mstore(add(m, 0x1a0), v13)\n            result := keccak256(m, 0x1c0)\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*             BYTES32 BUFFER HASHING OPERATIONS              */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns `keccak256(abi.encode(buffer[0], .., buffer[buffer.length - 1]))`.\n    function hash(bytes32[] memory buffer) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := keccak256(add(buffer, 0x20), shl(5, mload(buffer)))\n        }\n    }\n\n    /// @dev Sets `buffer[i]` to `value`, without a bounds check.\n    /// Returns the `buffer` for function chaining.\n    function set(bytes32[] memory buffer, uint256 i, bytes32 value)\n        internal\n        pure\n        returns (bytes32[] memory)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(add(buffer, shl(5, add(1, i))), value)\n        }\n        return buffer;\n    }\n\n    /// @dev Sets `buffer[i]` to `value`, without a bounds check.\n    /// Returns the `buffer` for function chaining.\n    function set(bytes32[] memory buffer, uint256 i, uint256 value)\n        internal\n        pure\n        returns (bytes32[] memory)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(add(buffer, shl(5, add(1, i))), value)\n        }\n        return buffer;\n    }\n\n    /// @dev Returns `new bytes32[](n)`, without zeroing out the memory.\n    function malloc(uint256 n) internal pure returns (bytes32[] memory buffer) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            buffer := mload(0x40)\n            mstore(buffer, n)\n            mstore(0x40, add(shl(5, add(1, n)), buffer))\n        }\n    }\n\n    /// @dev Frees memory that has been allocated for `buffer`.\n    /// No-op if `buffer.length` is zero, or if new memory has been allocated after `buffer`.\n    function free(bytes32[] memory buffer) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(buffer)\n            mstore(shl(6, lt(iszero(n), eq(add(shl(5, add(1, n)), buffer), mload(0x40)))), buffer)\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                      EQUALITY CHECKS                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns `a == abi.decode(b, (bytes32))`.\n    function eq(bytes32 a, bytes memory b) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := and(eq(0x20, mload(b)), eq(a, mload(add(b, 0x20))))\n        }\n    }\n\n    /// @dev Returns `abi.decode(a, (bytes32)) == b`.\n    function eq(bytes memory a, bytes32 b) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := and(eq(0x20, mload(a)), eq(b, mload(add(a, 0x20))))\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*               BYTE SLICE HASHING OPERATIONS                */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the keccak256 of the slice from `start` to `end` (exclusive).\n    /// `start` and `end` are byte offsets.\n    function hash(bytes memory b, uint256 start, uint256 end)\n        internal\n        pure\n        returns (bytes32 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(b)\n            end := xor(end, mul(xor(end, n), lt(n, end)))\n            start := xor(start, mul(xor(start, n), lt(n, start)))\n            result := keccak256(add(add(b, 0x20), start), mul(gt(end, start), sub(end, start)))\n        }\n    }\n\n    /// @dev Returns the keccak256 of the slice from `start` to the end of the bytes.\n    function hash(bytes memory b, uint256 start) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(b)\n            start := xor(start, mul(xor(start, n), lt(n, start)))\n            result := keccak256(add(add(b, 0x20), start), mul(gt(n, start), sub(n, start)))\n        }\n    }\n\n    /// @dev Returns the keccak256 of the bytes.\n    function hash(bytes memory b) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := keccak256(add(b, 0x20), mload(b))\n        }\n    }\n\n    /// @dev Returns the keccak256 of the slice from `start` to `end` (exclusive).\n    /// `start` and `end` are byte offsets.\n    function hashCalldata(bytes calldata b, uint256 start, uint256 end)\n        internal\n        pure\n        returns (bytes32 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            end := xor(end, mul(xor(end, b.length), lt(b.length, end)))\n            start := xor(start, mul(xor(start, b.length), lt(b.length, start)))\n            let n := mul(gt(end, start), sub(end, start))\n            calldatacopy(mload(0x40), add(b.offset, start), n)\n            result := keccak256(mload(0x40), n)\n        }\n    }\n\n    /// @dev Returns the keccak256 of the slice from `start` to the end of the bytes.\n    function hashCalldata(bytes calldata b, uint256 start) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            start := xor(start, mul(xor(start, b.length), lt(b.length, start)))\n            let n := mul(gt(b.length, start), sub(b.length, start))\n            calldatacopy(mload(0x40), add(b.offset, start), n)\n            result := keccak256(mload(0x40), n)\n        }\n    }\n\n    /// @dev Returns the keccak256 of the bytes.\n    function hashCalldata(bytes calldata b) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            calldatacopy(mload(0x40), b.offset, b.length)\n            result := keccak256(mload(0x40), b.length)\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                      SHA2-256 HELPERS                      */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns `sha256(abi.encode(b))`. Yes, it's more efficient.\n    function sha2(bytes32 b) internal view returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, b)\n            result := mload(staticcall(gas(), 2, 0x00, 0x20, 0x01, 0x20))\n            if iszero(returndatasize()) { invalid() }\n        }\n    }\n\n    /// @dev Returns the sha256 of the slice from `start` to `end` (exclusive).\n    /// `start` and `end` are byte offsets.\n    function sha2(bytes memory b, uint256 start, uint256 end)\n        internal\n        view\n        returns (bytes32 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(b)\n            end := xor(end, mul(xor(end, n), lt(n, end)))\n            start := xor(start, mul(xor(start, n), lt(n, start)))\n            // forgefmt: disable-next-item\n            result := mload(staticcall(gas(), 2, add(add(b, 0x20), start),\n                mul(gt(end, start), sub(end, start)), 0x01, 0x20))\n            if iszero(returndatasize()) { invalid() }\n        }\n    }\n\n    /// @dev Returns the sha256 of the slice from `start` to the end of the bytes.\n    function sha2(bytes memory b, uint256 start) internal view returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(b)\n            start := xor(start, mul(xor(start, n), lt(n, start)))\n            // forgefmt: disable-next-item\n            result := mload(staticcall(gas(), 2, add(add(b, 0x20), start),\n                mul(gt(n, start), sub(n, start)), 0x01, 0x20))\n            if iszero(returndatasize()) { invalid() }\n        }\n    }\n\n    /// @dev Returns the sha256 of the bytes.\n    function sha2(bytes memory b) internal view returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(staticcall(gas(), 2, add(b, 0x20), mload(b), 0x01, 0x20))\n            if iszero(returndatasize()) { invalid() }\n        }\n    }\n\n    /// @dev Returns the sha256 of the slice from `start` to `end` (exclusive).\n    /// `start` and `end` are byte offsets.\n    function sha2Calldata(bytes calldata b, uint256 start, uint256 end)\n        internal\n        view\n        returns (bytes32 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            end := xor(end, mul(xor(end, b.length), lt(b.length, end)))\n            start := xor(start, mul(xor(start, b.length), lt(b.length, start)))\n            let n := mul(gt(end, start), sub(end, start))\n            calldatacopy(mload(0x40), add(b.offset, start), n)\n            result := mload(staticcall(gas(), 2, mload(0x40), n, 0x01, 0x20))\n            if iszero(returndatasize()) { invalid() }\n        }\n    }\n\n    /// @dev Returns the sha256 of the slice from `start` to the end of the bytes.\n    function sha2Calldata(bytes calldata b, uint256 start) internal view returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            start := xor(start, mul(xor(start, b.length), lt(b.length, start)))\n            let n := mul(gt(b.length, start), sub(b.length, start))\n            calldatacopy(mload(0x40), add(b.offset, start), n)\n            result := mload(staticcall(gas(), 2, mload(0x40), n, 0x01, 0x20))\n            if iszero(returndatasize()) { invalid() }\n        }\n    }\n\n    /// @dev Returns the sha256 of the bytes.\n    function sha2Calldata(bytes calldata b) internal view returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            calldatacopy(mload(0x40), b.offset, b.length)\n            result := mload(staticcall(gas(), 2, mload(0x40), b.length, 0x01, 0x20))\n            if iszero(returndatasize()) { invalid() }\n        }\n    }\n}\n"},"node_modules/solady/src/utils/LibBit.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Library for bit twiddling and boolean operations.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibBit.sol)\n/// @author Inspired by (https://graphics.stanford.edu/~seander/bithacks.html)\nlibrary LibBit {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                  BIT TWIDDLING OPERATIONS                  */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Find last set.\n    /// Returns the index of the most significant bit of `x`,\n    /// counting from the least significant bit position.\n    /// If `x` is zero, returns 256.\n    function fls(uint256 x) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := or(shl(8, iszero(x)), shl(7, lt(0xffffffffffffffffffffffffffffffff, x)))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            // forgefmt: disable-next-item\n            r := or(r, byte(and(0x1f, shr(shr(r, x), 0x8421084210842108cc6318c6db6d54be)),\n                0x0706060506020504060203020504030106050205030304010505030400000000))\n        }\n    }\n\n    /// @dev Count leading zeros.\n    /// Returns the number of zeros preceding the most significant one bit.\n    /// If `x` is zero, returns 256.\n    function clz(uint256 x) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            // forgefmt: disable-next-item\n            r := add(xor(r, byte(and(0x1f, shr(shr(r, x), 0x8421084210842108cc6318c6db6d54be)),\n                0xf8f9f9faf9fdfafbf9fdfcfdfafbfcfef9fafdfafcfcfbfefafafcfbffffffff)), iszero(x))\n        }\n    }\n\n    /// @dev Find first set.\n    /// Returns the index of the least significant bit of `x`,\n    /// counting from the least significant bit position.\n    /// If `x` is zero, returns 256.\n    /// Equivalent to `ctz` (count trailing zeros), which gives\n    /// the number of zeros following the least significant one bit.\n    function ffs(uint256 x) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Isolate the least significant bit.\n            x := and(x, add(not(x), 1))\n            // For the upper 3 bits of the result, use a De Bruijn-like lookup.\n            // Credit to adhusson: https://blog.adhusson.com/cheap-find-first-set-evm/\n            // forgefmt: disable-next-item\n            r := shl(5, shr(252, shl(shl(2, shr(250, mul(x,\n                0xb6db6db6ddddddddd34d34d349249249210842108c6318c639ce739cffffffff))),\n                0x8040405543005266443200005020610674053026020000107506200176117077)))\n            // For the lower 5 bits of the result, use a De Bruijn lookup.\n            // forgefmt: disable-next-item\n            r := or(r, byte(and(div(0xd76453e0, shr(r, x)), 0x1f),\n                0x001f0d1e100c1d070f090b19131c1706010e11080a1a141802121b1503160405))\n        }\n    }\n\n    /// @dev Returns the number of set bits in `x`.\n    function popCount(uint256 x) internal pure returns (uint256 c) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let max := not(0)\n            let isMax := eq(x, max)\n            x := sub(x, and(shr(1, x), div(max, 3)))\n            x := add(and(x, div(max, 5)), and(shr(2, x), div(max, 5)))\n            x := and(add(x, shr(4, x)), div(max, 17))\n            c := or(shl(8, isMax), shr(248, mul(x, div(max, 255))))\n        }\n    }\n\n    /// @dev Returns the number of zero bytes in `x`.\n    /// To get the number of non-zero bytes, simply do `32 - countZeroBytes(x)`.\n    function countZeroBytes(uint256 x) internal pure returns (uint256 c) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := 0x7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f\n            c := byte(0, mul(shr(7, not(m)), shr(7, not(or(or(add(and(x, m), m), x), m)))))\n        }\n    }\n\n    /// @dev Returns the number of zero bytes in `s`.\n    /// To get the number of non-zero bytes, simply do `s.length - countZeroBytes(s)`.\n    function countZeroBytes(bytes memory s) internal pure returns (uint256 c) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            function czb(x_) -> _c {\n                let _m := 0x7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f\n                _c := shr(7, not(or(or(add(and(x_, _m), _m), x_), _m)))\n                _c := byte(0, mul(shr(7, not(_m)), _c))\n            }\n            let n := mload(s)\n            let l := shl(5, shr(5, n))\n            s := add(s, 0x20)\n            for { let i } xor(i, l) { i := add(i, 0x20) } { c := add(czb(mload(add(s, i))), c) }\n            if lt(l, n) { c := add(czb(or(shr(shl(3, sub(n, l)), not(0)), mload(add(s, l)))), c) }\n        }\n    }\n\n    /// @dev Returns the number of zero bytes in `s`.\n    /// To get the number of non-zero bytes, simply do `s.length - countZeroBytes(s)`.\n    function countZeroBytesCalldata(bytes calldata s) internal pure returns (uint256 c) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            function czb(x_) -> _c {\n                let _m := 0x7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f7f\n                _c := shr(7, not(or(or(add(and(x_, _m), _m), x_), _m)))\n                _c := byte(0, mul(shr(7, not(_m)), _c))\n            }\n            let l := shl(5, shr(5, s.length))\n            for { let i } xor(i, l) { i := add(i, 0x20) } {\n                c := add(czb(calldataload(add(s.offset, i))), c)\n            }\n            if lt(l, s.length) {\n                let m := shr(shl(3, sub(s.length, l)), not(0))\n                c := add(czb(or(m, calldataload(add(s.offset, l)))), c)\n            }\n        }\n    }\n\n    /// @dev Returns whether `x` is a power of 2.\n    function isPo2(uint256 x) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to `x && !(x & (x - 1))`.\n            result := iszero(add(and(x, sub(x, 1)), iszero(x)))\n        }\n    }\n\n    /// @dev Returns `x` reversed at the bit level.\n    function reverseBits(uint256 x) internal pure returns (uint256 r) {\n        uint256 m0 = 0x0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f;\n        uint256 m1 = m0 ^ (m0 << 2);\n        uint256 m2 = m1 ^ (m1 << 1);\n        r = reverseBytes(x);\n        r = (m2 & (r >> 1)) | ((m2 & r) << 1);\n        r = (m1 & (r >> 2)) | ((m1 & r) << 2);\n        r = (m0 & (r >> 4)) | ((m0 & r) << 4);\n    }\n\n    /// @dev Returns `x` reversed at the byte level.\n    function reverseBytes(uint256 x) internal pure returns (uint256 r) {\n        unchecked {\n            // Computing masks on-the-fly reduces bytecode size by about 200 bytes.\n            uint256 m0 = 0x100000000000000000000000000000001 * (~toUint(x == uint256(0)) >> 192);\n            uint256 m1 = m0 ^ (m0 << 32);\n            uint256 m2 = m1 ^ (m1 << 16);\n            uint256 m3 = m2 ^ (m2 << 8);\n            r = (m3 & (x >> 8)) | ((m3 & x) << 8);\n            r = (m2 & (r >> 16)) | ((m2 & r) << 16);\n            r = (m1 & (r >> 32)) | ((m1 & r) << 32);\n            r = (m0 & (r >> 64)) | ((m0 & r) << 64);\n            r = (r >> 128) | (r << 128);\n        }\n    }\n\n    /// @dev Returns the common prefix of `x` and `y` at the bit level.\n    function commonBitPrefix(uint256 x, uint256 y) internal pure returns (uint256) {\n        unchecked {\n            uint256 s = 256 - clz(x ^ y);\n            return (x >> s) << s;\n        }\n    }\n\n    /// @dev Returns the common prefix of `x` and `y` at the nibble level.\n    function commonNibblePrefix(uint256 x, uint256 y) internal pure returns (uint256) {\n        unchecked {\n            uint256 s = (64 - (clz(x ^ y) >> 2)) << 2;\n            return (x >> s) << s;\n        }\n    }\n\n    /// @dev Returns the common prefix of `x` and `y` at the byte level.\n    function commonBytePrefix(uint256 x, uint256 y) internal pure returns (uint256) {\n        unchecked {\n            uint256 s = (32 - (clz(x ^ y) >> 3)) << 3;\n            return (x >> s) << s;\n        }\n    }\n\n    /// @dev hex\"ABCD\" -> hex\"0A0B0C0D\".\n    function toNibbles(bytes memory s) internal pure returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            let n := mload(s)\n            mstore(result, add(n, n)) // Store the new length.\n            s := add(s, 0x20)\n            let o := add(result, 0x20)\n            // forgefmt: disable-next-item\n            for { let i := 0 } lt(i, n) { i := add(i, 0x10) } {\n                let x := shr(128, mload(add(s, i)))\n                x := and(0x0000000000000000ffffffffffffffff0000000000000000ffffffffffffffff, or(shl(64, x), x))\n                x := and(0x00000000ffffffff00000000ffffffff00000000ffffffff00000000ffffffff, or(shl(32, x), x))\n                x := and(0x0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff, or(shl(16, x), x))\n                x := and(0x00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff, or(shl(8, x), x))\n                mstore(add(o, add(i, i)),\n                    and(0x0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f, or(shl(4, x), x)))\n            }\n            mstore(add(o, add(s, s)), 0) // Zeroize slot after result.\n            mstore(0x40, add(0x40, add(o, add(s, s)))) // Allocate memory.\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                     BOOLEAN OPERATIONS                     */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    // A Solidity bool on the stack or memory is represented as a 256-bit word.\n    // Non-zero values are true, zero is false.\n    // A clean bool is either 0 (false) or 1 (true) under the hood.\n    // Usually, if not always, the bool result of a regular Solidity expression,\n    // or the argument of a public/external function will be a clean bool.\n    // You can usually use the raw variants for more performance.\n    // If uncertain, test (best with exact compiler settings).\n    // Or use the non-raw variants (compiler can sometimes optimize out the double `iszero`s).\n\n    /// @dev Returns `x & y`. Inputs must be clean.\n    function rawAnd(bool x, bool y) internal pure returns (bool z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := and(x, y)\n        }\n    }\n\n    /// @dev Returns `x & y`.\n    function and(bool x, bool y) internal pure returns (bool z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := and(iszero(iszero(x)), iszero(iszero(y)))\n        }\n    }\n\n    /// @dev Returns `w & x & y`.\n    function and(bool w, bool x, bool y) internal pure returns (bool z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := iszero(or(iszero(w), or(iszero(x), iszero(y))))\n        }\n    }\n\n    /// @dev Returns `v & w & x & y`.\n    function and(bool v, bool w, bool x, bool y) internal pure returns (bool z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := iszero(or(or(iszero(v), iszero(w)), or(iszero(x), iszero(y))))\n        }\n    }\n\n    /// @dev Returns `x | y`. Inputs must be clean.\n    function rawOr(bool x, bool y) internal pure returns (bool z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := or(x, y)\n        }\n    }\n\n    /// @dev Returns `x | y`.\n    function or(bool x, bool y) internal pure returns (bool z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := iszero(iszero(or(x, y)))\n        }\n    }\n\n    /// @dev Returns `w | x | y`.\n    function or(bool w, bool x, bool y) internal pure returns (bool z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := iszero(iszero(or(w, or(x, y))))\n        }\n    }\n\n    /// @dev Returns `v | w | x | y`.\n    function or(bool v, bool w, bool x, bool y) internal pure returns (bool z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := iszero(iszero(or(v, or(w, or(x, y)))))\n        }\n    }\n\n    /// @dev Returns 1 if `b` is true, else 0. Input must be clean.\n    function rawToUint(bool b) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := b\n        }\n    }\n\n    /// @dev Returns 1 if `b` is true, else 0.\n    function toUint(bool b) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := iszero(iszero(b))\n        }\n    }\n}\n"},"node_modules/solady/src/accounts/LibEIP7702.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\n/// @notice Library for EIP7702 operations.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/accounts/LibEIP7702.sol)\nlibrary LibEIP7702 {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Failed to deploy the EIP7702Proxy.\n    error DeploymentFailed();\n\n    /// @dev The proxy query has failed.\n    error ProxyQueryFailed();\n\n    /// @dev Failed to change the proxy admin.\n    error ChangeProxyAdminFailed();\n\n    /// @dev Failed to upgrade the proxy.\n    error UpgradeProxyFailed();\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         CONSTANTS                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The ERC-1967 storage slot for the implementation in the proxy.\n    /// `uint256(keccak256(\"eip1967.proxy.implementation\")) - 1`.\n    bytes32 internal constant ERC1967_IMPLEMENTATION_SLOT =\n        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /// @dev The transient storage slot for requesting the proxy to initialize the implementation.\n    /// `uint256(keccak256(\"eip7702.proxy.delegation.initialization.request\")) - 1`.\n    /// While we would love to use a smaller constant, this slot is used in both the proxy\n    /// and the delegation, so we shall just use bytes32 in case we want to standardize this.\n    bytes32 internal constant EIP7702_PROXY_DELEGATION_INITIALIZATION_REQUEST_SLOT =\n        0x94e11c6e41e7fb92cb8bb65e13fdfbd4eba8b831292a1a220f7915c78c7c078f;\n\n    /// @dev The creation code for the EIP7702Proxy.\n    /// This is generated from `EIP7702Proxy.sol` with exact compilation settings.\n    bytes internal constant EIP7702_PROXY_CREATION_CODE =\n        hex\"60c06040819052306080526102d63881900390819083398101604081905261002691610096565b7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc8290557fb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103819055811515110260a0526100c7565b80516001600160a01b0381168114610091575f5ffd5b919050565b5f5f604083850312156100a7575f5ffd5b6100b08361007b565b91506100be6020840161007b565b90509250929050565b60805160a0516101f06100e65f395f602701525f600601526101f05ff3fe60016040527f00000000000000000000000000000000000000000000000000000000000000007f00000000000000000000000000000000000000000000000000000000000000007f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc361960601c30841861010a576001361161008657815481165f5260205ff35b5f3560e01c80635c60da1b036100a157825482165f5260205ff35b7fb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d61038163f851a440036100d65780545f5260205ff35b80543303610106578382630900f01014028183638f2839701402178015610104576004358416815560206040f35b505b5f5ffd5b815481163660010361013b5780610133575082806101335760205f5f5f885afa15610106573d5ff35b805f5260205ff35b365f5f37806101a7575082806101a7576020365f5f885afa5f5f365f36515af416610168573d5f5f3e3d5ffd5b7f94e11c6e41e7fb92cb8bb65e13fdfbd4eba8b831292a1a220f7915c78c7c078f805c1561019e57365184548419161784555f815d5b503d5f5f3e3d5ff35b5f5f365f845af461019e573d5f5f3e3d5ffdfea2646970667358221220e8b1a2a38594baf32c154aa7dd7743c9cd741d4f386b5ab588a5dcd613c3a00e64736f6c634300081c0033\";\n\n    /// @dev The keccak256 of runtime code for `EIP7702Proxy.sol` with exact compilation settings,\n    /// with immutables zeroized and without the CBOR metadata.\n    bytes32 internal constant EIP7702_PROXY_MINIMAL_CODE_HASH =\n        0xf8710866f390ac7c12640457f9cb9663657ac8168b7d4ce6418a982932b3043e;\n\n    /// @dev The length of the runtime code for `EIP7702Proxy.sol` with exact compilation settings,\n    /// with immutables zeroized and without the CBOR metadata.\n    uint256 internal constant EIP7702_PROXY_MINIMAL_CODE_LENGTH = 0x1ba;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*               AUTHORITY AND PROXY OPERATIONS               */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the delegation of the account.\n    /// If the account is not an EIP7702 authority, returns `address(0)`.\n    function delegationOf(address account) internal view returns (address result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            extcodecopy(account, 0x00, 0x00, 0x20)\n            // Note: Checking that it starts with hex\"ef01\" is the most general and futureproof.\n            // 7702 bytecode is `abi.encodePacked(hex\"ef01\", uint8(version), address(delegation))`.\n            result := mul(shr(96, mload(0x03)), eq(0xef01, shr(240, mload(0x00))))\n        }\n    }\n\n    /// @dev Returns the delegation and the implementation of the account.\n    /// If the account delegation is not a valid EIP7702Proxy, returns `address(0)`.\n    function delegationAndImplementationOf(address account)\n        internal\n        view\n        returns (address delegation, address implementation)\n    {\n        delegation = delegationOf(account);\n        if (isEIP7702Proxy(delegation)) {\n            /// @solidity memory-safe-assembly\n            assembly {\n                mstore(0x00, 0)\n                if iszero(staticcall(gas(), account, 0x00, 0x01, 0x00, 0x20)) { revert(0x00, 0x00) }\n                implementation := mload(0x00)\n            }\n        }\n    }\n\n    /// @dev Returns the implementation of `target`.\n    /// If `target` is neither an EIP7702Proxy nor an EOA delegated to an EIP7702Proxy, returns `address(0)`.\n    function implementationOf(address target) internal view returns (address result) {\n        if (!isEIP7702Proxy(target)) if (!isEIP7702Proxy(delegationOf(target))) return address(0);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, 0)\n            if iszero(staticcall(gas(), target, 0x00, 0x01, 0x00, 0x20)) { revert(0x00, 0x00) }\n            result := mload(0x00)\n        }\n    }\n\n    /// @dev Returns if `target` is an valid EIP7702Proxy based on a bytecode hash check.\n    function isEIP7702Proxy(address target) internal view returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            // Copy the runtime bytecode without the CBOR metadata.\n            extcodecopy(target, m, 0x00, EIP7702_PROXY_MINIMAL_CODE_LENGTH)\n            // Zeroize the immutables.\n            mstore(add(m, 0x06), 0) // The first `7f<immutable_word>`.\n            mstore(add(m, 0x27), 0) // The second `7f<immutable_word>`.\n            let h := keccak256(m, EIP7702_PROXY_MINIMAL_CODE_LENGTH)\n            result := eq(EIP7702_PROXY_MINIMAL_CODE_HASH, h)\n        }\n    }\n\n    /// @dev Returns the initialization code for the EIP7702Proxy.\n    function proxyInitCode(address initialImplementation, address initialAdmin)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(\n            EIP7702_PROXY_CREATION_CODE,\n            uint256(uint160(initialImplementation)),\n            uint256(uint160(initialAdmin))\n        );\n    }\n\n    /// @dev Deploys an EIP7702Proxy.\n    function deployProxy(address initialImplementation, address initialAdmin)\n        internal\n        returns (address instance)\n    {\n        bytes memory initCode = proxyInitCode(initialImplementation, initialAdmin);\n        /// @solidity memory-safe-assembly\n        assembly {\n            instance := create(0, add(initCode, 0x20), mload(initCode))\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Deploys an EIP7702Proxy to a deterministic address with `salt`.\n    function deployProxyDeterministic(\n        address initialImplementation,\n        address initialAdmin,\n        bytes32 salt\n    ) internal returns (address instance) {\n        bytes memory initCode = proxyInitCode(initialImplementation, initialAdmin);\n        /// @solidity memory-safe-assembly\n        assembly {\n            instance := create2(0, add(initCode, 0x20), mload(initCode), salt)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Returns the admin of the proxy.\n    /// Assumes that the proxy is a proper EIP7702Proxy, if it exists.\n    function proxyAdmin(address proxy) internal view returns (address result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, 0xf851a440) // `admin()`.\n            let t := staticcall(gas(), proxy, 0x1c, 0x04, 0x00, 0x20)\n            if iszero(and(gt(returndatasize(), 0x1f), t)) {\n                mstore(0x00, 0x26ec9b6a) // `ProxyQueryFailed()`.\n                revert(0x1c, 0x04)\n            }\n            result := mload(0x00)\n        }\n    }\n\n    /// @dev Changes the admin on the proxy. The caller must be the admin.\n    /// Assumes that the proxy is a proper EIP7702Proxy, if it exists.\n    function changeProxyAdmin(address proxy, address newAdmin) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, 0x8f283970) // `changeAdmin(address)`.\n            mstore(0x20, newAdmin) // The implementation will clean the upper 96 bits.\n            if iszero(and(eq(mload(0x00), 1), call(gas(), proxy, 0, 0x1c, 0x24, 0x00, 0x20))) {\n                mstore(0x00, 0xc502e37e) // `ChangeProxyAdminFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Changes the implementation on the proxy. The caller must be the admin.\n    /// Assumes that the proxy is a proper EIP7702Proxy, if it exists.\n    function upgradeProxy(address proxy, address newImplementation) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, 0x0900f010) // `upgrade(address)`.\n            mstore(0x20, newImplementation) // The implementation will clean the upper 96 bits.\n            if iszero(and(eq(mload(0x00), 1), call(gas(), proxy, 0, 0x1c, 0x24, 0x00, 0x20))) {\n                mstore(0x00, 0xc6edd882) // `UpgradeProxyFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                      UUPS OPERATIONS                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Upgrades the implementation.\n    /// The new implementation will NOT be active until the next UserOp or transaction.\n    /// To \"auto-upgrade\" to the latest implementation on the proxy, pass in `address(0)` to reset\n    /// the implementation slot. This causes the proxy to use the latest default implementation,\n    /// which may be optionally reinitialized via `requestProxyDelegationInitialization()`.\n    /// This function is intended to be used on the authority of an EIP7702Proxy delegation.\n    /// The most intended usage pattern is to wrap this in an access-gated admin function.\n    function upgradeProxyDelegation(address newImplementation) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let s := ERC1967_IMPLEMENTATION_SLOT\n            // Preserve the upper 96 bits when updating in case they are used for some stuff.\n            mstore(0x00, sload(s))\n            mstore(0x0c, shl(96, newImplementation))\n            sstore(s, mload(0x00))\n        }\n    }\n\n    /// @dev Requests the implementation to be initialized to the latest implementation on the proxy.\n    /// This function is intended to be used on the authority of an EIP7702Proxy delegation.\n    /// The most intended usage pattern is to place it at the end of an `execute` function.\n    function requestProxyDelegationInitialization() internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(shl(96, sload(ERC1967_IMPLEMENTATION_SLOT))) {\n                // Use a dedicated transient storage slot for better Swiss-cheese-model safety.\n                tstore(EIP7702_PROXY_DELEGATION_INITIALIZATION_REQUEST_SLOT, address())\n            }\n        }\n    }\n}\n"},"contracts/interfaces/nexus/base/IBaseAccountEventsAndErrors.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\n// ──────────────────────────────────────────────────────────────────────────────\n//     _   __    _  __\n//    / | / /__ | |/ /_  _______\n//   /  |/ / _ \\|   / / / / ___/\n//  / /|  /  __/   / /_/ (__  )\n// /_/ |_/\\___/_/|_\\__,_/____/\n//\n// ──────────────────────────────────────────────────────────────────────────────\n// Nexus: A suite of contracts for Modular Smart Accounts compliant with ERC-7579 and ERC-4337, developed by Biconomy.\n// Learn more at https://biconomy.io. To report security issues, please contact us at: security@biconomy.io\n\n/// @title Execution Manager Events and Errors Interface\n/// @notice Interface for defining events and errors related to transaction execution processes within smart accounts.\n/// @dev This interface defines events and errors used by execution manager to handle and report the operational status\n/// of\n/// smart account transactions.\n/// It is a part of the Nexus suite of contracts aimed at implementing flexible and secure smart account operations.\n/// @author @livingrockrises | Biconomy | chirag@biconomy.io\n/// @author @aboudjem | Biconomy | adam.boudjemaa@biconomy.io\n/// @author @filmakarov | Biconomy | filipp.makarov@biconomy.io\n/// @author @zeroknots | Rhinestone.wtf | zeroknots.eth\n/// Special thanks to the Solady team for foundational contributions: https://github.com/Vectorized/solady\ninterface IBaseAccountEventsAndErrors {\n    /// @dev Throws an error when a caller is not authorized to access an account.\n    error AccountAccessUnauthorized();\n}\n"},"contracts/interfaces/nexus/base/IStorage.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\n// ──────────────────────────────────────────────────────────────────────────────\n//     _   __    _  __\n//    / | / /__ | |/ /_  _______\n//   /  |/ / _ \\|   / / / / ___/\n//  / /|  /  __/   / /_/ (__  )\n// /_/ |_/\\___/_/|_\\__,_/____/\n//\n// ──────────────────────────────────────────────────────────────────────────────\n// Nexus: A suite of contracts for Modular Smart Accounts compliant with ERC-7579 and ERC-4337, developed by Biconomy.\n// Learn more at https://biconomy.io. To report security issues, please contact us at: security@biconomy.io\n\nimport { SentinelListLib } from \"sentinellist/SentinelList.sol\";\nimport { IHook, IPreValidationHookERC1271, IPreValidationHookERC4337 } from \"erc7579/interfaces/IERC7579Module.sol\";\nimport { CallType } from \"../../../lib/erc-7579/ModeLib.sol\";\n\n/// @title Nexus - IStorage Interface\n/// @notice Provides structured storage for Modular Smart Account under the Nexus suite, compliant with ERC-7579 and\n/// ERC-4337.\n/// @dev Manages structured storage using SentinelListLib for validators and executors, and a mapping for fallback\n/// handlers.\n/// This interface utilizes ERC-7201 storage location practices to ensure isolated and collision-resistant storage\n/// spaces\n/// within smart contracts.\n/// It is designed to support dynamic execution and modular management strategies essential for advanced smart account\n/// architectures.\n/// @custom:storage-location erc7201:biconomy.storage.Nexus\n/// @author @livingrockrises | Biconomy | chirag@biconomy.io\n/// @author @aboudjem | Biconomy | adam.boudjemaa@biconomy.io\n/// @author @filmakarov | Biconomy | filipp.makarov@biconomy.io\n/// @author @zeroknots | Rhinestone.wtf | zeroknots.eth\n/// Special thanks to the Solady team for foundational contributions: https://github.com/Vectorized/solady\ninterface IStorage {\n    /// @notice Struct storing validators and executors using Sentinel lists, and fallback handlers via mapping.\n    struct AccountStorage {\n        ///< List of validators, initialized upon contract deployment.\n        SentinelListLib.SentinelList validators;\n        ///< List of executors, similarly initialized.\n        SentinelListLib.SentinelList executors;\n        ///< Mapping of selectors to their respective fallback handlers.\n        mapping(bytes4 => FallbackHandler) fallbacks;\n        ///< Current hook module associated with this account.\n        IHook hook;\n        ///< Mapping of hooks to requested timelocks.\n        mapping(address hook => uint256) emergencyUninstallTimelock;\n        ///< PreValidation hook for validateUserOp\n        IPreValidationHookERC4337 preValidationHookERC4337;\n        ///< PreValidation hook for isValidSignature\n        IPreValidationHookERC1271 preValidationHookERC1271;\n        ///< Mapping of used nonces for replay protection.\n        mapping(uint256 => bool) nonces;\n        ///< ERC-7484 registry\n        address registry; // keeping this to avoid collisions b/w versions\n        ///< Mapping of used 7702 init hashes for replay protection.\n        mapping(bytes32 => bool) erc7702InitHashes;\n    }\n\n    /// @notice Defines a fallback handler with an associated handler address and a call type.\n    struct FallbackHandler {\n        ///< The address of the fallback function handler.\n        address handler;\n        ///< The type of call this handler supports (e.g., static or call).\n        CallType calltype;\n    }\n}\n"},"contracts/interfaces/nexus/base/IModuleManagerEventsAndErrors.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\n// ──────────────────────────────────────────────────────────────────────────────\n//     _   __    _  __\n//    / | / /__ | |/ /_  _______\n//   /  |/ / _ \\|   / / / / ___/\n//  / /|  /  __/   / /_/ (__  )\n// /_/ |_/\\___/_/|_\\__,_/____/\n//\n// ──────────────────────────────────────────────────────────────────────────────\n// Nexus: A suite of contracts for Modular Smart Accounts compliant with ERC-7579 and ERC-4337, developed by Biconomy.\n// Learn more at https://biconomy.io. To report security issues, please contact us at: security@biconomy.io\n\nimport { CallType } from \"../../../lib/erc-7579/ModeLib.sol\";\n\n/// @title ERC-7579 Module Manager Events and Errors Interface\n/// @notice Provides event and error definitions for actions related to module management in smart accounts.\n/// @dev Used by IModuleManager to define the events and errors associated with the installation and management of\n/// modules.\n/// @author @livingrockrises | Biconomy | chirag@biconomy.io\n/// @author @aboudjem | Biconomy | adam.boudjemaa@biconomy.io\n/// @author @filmakarov | Biconomy | filipp.makarov@biconomy.io\n/// @author @zeroknots | Rhinestone.wtf | zeroknots.eth\n/// Special thanks to the Solady team for foundational contributions: https://github.com/Vectorized/solady\ninterface IModuleManagerEventsAndErrors {\n    /// @notice Emitted when a module is installed onto a smart account.\n    /// @param moduleTypeId The identifier for the type of module installed.\n    /// @param module The address of the installed module.\n    event ModuleInstalled(uint256 moduleTypeId, address module);\n\n    /// @notice Emitted when a module is uninstalled from a smart account.\n    /// @param moduleTypeId The identifier for the type of module uninstalled.\n    /// @param module The address of the uninstalled module.\n    event ModuleUninstalled(uint256 moduleTypeId, address module);\n\n    /// @dev Thrown when the specified module address is not recognized as valid.\n    error InvalidModule(address module);\n\n    /// @dev Thrown when an invalid module type identifier is provided.\n    error InvalidModuleTypeId(uint256 moduleTypeId);\n\n    /// @dev Thrown when there is an attempt to install a module that is already installed.\n    error ModuleAlreadyInstalled(uint256 moduleTypeId, address module);\n\n    /// @dev Thrown when an operation is performed by an unauthorized operator.\n    error UnauthorizedOperation(address operator);\n\n    /// @dev Thrown when there is an attempt to uninstall a module that is not installed.\n    error ModuleNotInstalled(uint256 moduleTypeId, address module);\n\n    /// @dev Thrown when a module address is set to zero.\n    error ModuleAddressCanNotBeZero();\n\n    /// @dev Thrown when a post-check fails after hook execution.\n    error HookPostCheckFailed();\n\n    /// @dev Thrown when there is an attempt to install a hook while another is already installed.\n    error HookAlreadyInstalled(address currentHook);\n\n    /// @dev Thrown when there is an attempt to install a PreValidationHook while another is already installed.\n    error PrevalidationHookAlreadyInstalled(address currentPreValidationHook);\n\n    /// @dev Thrown when there is an attempt to install a fallback handler for a selector already having one.\n    error FallbackAlreadyInstalledForSelector(bytes4 selector);\n\n    /// @dev Thrown when there is an attempt to uninstall a fallback handler for a selector that does not have one\n    /// installed.\n    error FallbackNotInstalledForSelector(bytes4 selector);\n\n    /// @dev Thrown when Invalid data is provided for MultiType install flow\n    error InvalidInput();\n\n    /// @dev Thrown when unable to validate Emergency Uninstall signature\n    error EmergencyUninstallSigError();\n\n    /// @notice Error thrown when an invalid nonce is used\n    error InvalidNonce();\n\n    /// Error thrown when account installs/uninstalls module with mismatched moduleTypeId\n    error MismatchModuleTypeId();\n\n    /// @dev Thrown when there is an attempt to install a forbidden selector as a fallback handler.\n    error FallbackSelectorForbidden();\n\n    /// @dev Thrown when there is an attempt to install a fallback handler with an invalid calltype for a given\n    /// selector.\n    error FallbackCallTypeInvalid();\n\n    /// @notice Error thrown when an execution with an unsupported CallType was made.\n    /// @param callType The unsupported call type.\n    error UnsupportedCallType(CallType callType);\n\n    /// @notice Error thrown when the default validator is already installed.\n    error DefaultValidatorAlreadyInstalled();\n}\n"},"node_modules/@erc7579/implementation/src/lib/ModeLib.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\n/**\n * @title ModeLib\n * To allow smart accounts to be very simple, but allow for more complex execution, A custom mode\n * encoding is used.\n *    Function Signature of execute function:\n *           function execute(ModeCode mode, bytes calldata executionCalldata) external payable;\n * This allows for a single bytes32 to be used to encode the execution mode, calltype, execType and\n * context.\n * NOTE: Simple Account implementations only have to scope for the most significant byte. Account  that\n * implement\n * more complex execution modes may use the entire bytes32.\n *\n * |--------------------------------------------------------------------|\n * | CALLTYPE  | EXECTYPE  |   UNUSED   | ModeSelector  |  ModePayload  |\n * |--------------------------------------------------------------------|\n * | 1 byte    | 1 byte    |   4 bytes  | 4 bytes       |   22 bytes    |\n * |--------------------------------------------------------------------|\n *\n * CALLTYPE: 1 byte\n * CallType is used to determine how the executeCalldata paramter of the execute function has to be\n * decoded.\n * It can be either single, batch or delegatecall. In the future different calls could be added.\n * CALLTYPE can be used by a validation module to determine how to decode <userOp.callData[36:]>.\n *\n * EXECTYPE: 1 byte\n * ExecType is used to determine how the account should handle the execution.\n * It can indicate if the execution should revert on failure or continue execution.\n * In the future more execution modes may be added.\n * Default Behavior (EXECTYPE = 0x00) is to revert on a single failed execution. If one execution in\n * a batch fails, the entire batch is reverted\n *\n * UNUSED: 4 bytes\n * Unused bytes are reserved for future use.\n *\n * ModeSelector: bytes4\n * The \"optional\" mode selector can be used by account vendors, to implement custom behavior in\n * their accounts.\n * the way a ModeSelector is to be calculated is bytes4(keccak256(\"vendorname.featurename\"))\n * this is to prevent collisions between different vendors, while allowing innovation and the\n * development of new features without coordination between ERC-7579 implementing accounts\n *\n * ModePayload: 22 bytes\n * Mode payload is used to pass additional data to the smart account execution, this may be\n * interpreted depending on the ModeSelector\n *\n * ExecutionCallData: n bytes\n * single, delegatecall or batch exec abi.encoded as bytes\n */\nimport { Execution } from \"../interfaces/IERC7579Account.sol\";\n\n// Custom type for improved developer experience\ntype ModeCode is bytes32;\n\ntype CallType is bytes1;\n\ntype ExecType is bytes1;\n\ntype ModeSelector is bytes4;\n\ntype ModePayload is bytes22;\n\n// Default CallType\nCallType constant CALLTYPE_SINGLE = CallType.wrap(0x00);\n// Batched CallType\nCallType constant CALLTYPE_BATCH = CallType.wrap(0x01);\n// @dev Implementing delegatecall is OPTIONAL!\n// implement delegatecall with extreme care.\nCallType constant CALLTYPE_STATIC = CallType.wrap(0xFE);\nCallType constant CALLTYPE_DELEGATECALL = CallType.wrap(0xFF);\n\n// @dev default behavior is to revert on failure\n// To allow very simple accounts to use mode encoding, the default behavior is to revert on failure\n// Since this is value 0x00, no additional encoding is required for simple accounts\nExecType constant EXECTYPE_DEFAULT = ExecType.wrap(0x00);\n// @dev account may elect to change execution behavior. For example \"try exec\" / \"allow fail\"\nExecType constant EXECTYPE_TRY = ExecType.wrap(0x01);\n\nModeSelector constant MODE_DEFAULT = ModeSelector.wrap(bytes4(0x00000000));\n// Example declaration of a custom mode selector\nModeSelector constant MODE_OFFSET = ModeSelector.wrap(bytes4(keccak256(\"default.mode.offset\")));\n\n/**\n * @dev ModeLib is a helper library to encode/decode ModeCodes\n */\nlibrary ModeLib {\n    function decode(ModeCode mode)\n        internal\n        pure\n        returns (\n            CallType _calltype,\n            ExecType _execType,\n            ModeSelector _modeSelector,\n            ModePayload _modePayload\n        )\n    {\n        assembly {\n            _calltype := mode\n            _execType := shl(8, mode)\n            _modeSelector := shl(48, mode)\n            _modePayload := shl(80, mode)\n        }\n    }\n\n    function encode(\n        CallType callType,\n        ExecType execType,\n        ModeSelector mode,\n        ModePayload payload\n    )\n        internal\n        pure\n        returns (ModeCode)\n    {\n        return ModeCode.wrap(\n            bytes32(\n                abi.encodePacked(callType, execType, bytes4(0), ModeSelector.unwrap(mode), payload)\n            )\n        );\n    }\n\n    function encodeSimpleBatch() internal pure returns (ModeCode mode) {\n        mode = encode(CALLTYPE_BATCH, EXECTYPE_DEFAULT, MODE_DEFAULT, ModePayload.wrap(0x00));\n    }\n\n    function encodeSimpleSingle() internal pure returns (ModeCode mode) {\n        mode = encode(CALLTYPE_SINGLE, EXECTYPE_DEFAULT, MODE_DEFAULT, ModePayload.wrap(0x00));\n    }\n\n    function getCallType(ModeCode mode) internal pure returns (CallType calltype) {\n        assembly {\n            calltype := mode\n        }\n    }\n}\n\nusing { eqModeSelector as == } for ModeSelector global;\nusing { eqCallType as == } for CallType global;\nusing { eqExecType as == } for ExecType global;\n\nfunction eqCallType(CallType a, CallType b) pure returns (bool) {\n    return CallType.unwrap(a) == CallType.unwrap(b);\n}\n\nfunction eqExecType(ExecType a, ExecType b) pure returns (bool) {\n    return ExecType.unwrap(a) == ExecType.unwrap(b);\n}\n\nfunction eqModeSelector(ModeSelector a, ModeSelector b) pure returns (bool) {\n    return ModeSelector.unwrap(a) == ModeSelector.unwrap(b);\n}\n"},"contracts/interfaces/nexus/base/IExecutionHelperEventsAndErrors.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\n// ──────────────────────────────────────────────────────────────────────────────\n//     _   __    _  __\n//    / | / /__ | |/ /_  _______\n//   /  |/ / _ \\|   / / / / ___/\n//  / /|  /  __/   / /_/ (__  )\n// /_/ |_/\\___/_/|_\\__,_/____/\n//\n// ──────────────────────────────────────────────────────────────────────────────\n// Nexus: A suite of contracts for Modular Smart Accounts compliant with ERC-7579 and ERC-4337, developed by Biconomy.\n// Learn more at https://biconomy.io. To report security issues, please contact us at: security@biconomy.io\n\n/// @title Execution Manager Events and Errors Interface\n/// @notice Interface for defining events and errors related to transaction execution processes within smart accounts.\n/// @dev This interface defines events and errors used by execution manager to handle and report the operational status\n/// of\n/// smart account transactions.\n/// It is a part of the Nexus suite of contracts aimed at implementing flexible and secure smart account operations.\n/// @author @livingrockrises | Biconomy | chirag@biconomy.io\n/// @author @aboudjem | Biconomy | adam.boudjemaa@biconomy.io\n/// @author @filmakarov | Biconomy | filipp.makarov@biconomy.io\n/// @author @zeroknots | Rhinestone.wtf | zeroknots.eth\n/// Special thanks to the Solady team for foundational contributions: https://github.com/Vectorized/solady\n\nimport { ExecType } from \"../../../lib/erc-7579/ModeLib.sol\";\n\ninterface IExecutionHelperEventsAndErrors {\n    /// @notice Event emitted when a transaction fails to execute successfully.\n    event TryExecuteUnsuccessful(bytes callData, bytes result);\n\n    /// @notice Event emitted when a transaction fails to execute successfully.\n    event TryDelegateCallUnsuccessful(bytes callData, bytes result);\n\n    /// @notice Error thrown when an execution with an unsupported ExecType was made.\n    /// @param execType The unsupported execution type.\n    error UnsupportedExecType(ExecType execType);\n}\n"},"contracts/composability/ComposableStorage.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\n/**\n * @title ComposableStorage\n * @dev Contract to handle generic storage operations with cross-chain support\n */\ncontract ComposableStorage {\n    error SlotNotInitialized();\n\n    // Mapping to track initialized slots\n    mapping(bytes32 => bool) private initializedSlots;\n\n    // Mapping to track length of dynamic data\n    mapping(bytes32 => uint256) private dynamicDataLength;\n\n    /**\n     * @dev Internal function to write a value to a specific storage slot\n     */\n    function _writeStorage(bytes32 slot, bytes32 value, bytes32 namespace) private {\n        bytes32 namespacedSlot = getNamespacedSlot(namespace, slot);\n        initializedSlots[namespacedSlot] = true;\n        assembly {\n            sstore(namespacedSlot, value)\n        }\n    }\n\n    /**\n     * @dev Write a value to a specific storage slot\n     * @param slot The storage slot to write to\n     * @param value The value to write\n     */\n    function writeStorage(bytes32 slot, bytes32 value, address account) external {\n        bytes32 namespace = getNamespace(account, msg.sender);\n        _writeStorage(slot, value, namespace);\n    }\n\n    /**\n     * @dev Read a value from a specific namespace and slot\n     * @param namespace The namespace (typically a contract address)\n     * @param slot The storage slot to read from\n     * @return The value stored at the specified namespaced slot\n     */\n    function readStorage(bytes32 namespace, bytes32 slot) external view returns (bytes32) {\n        bytes32 namespacedSlot = getNamespacedSlot(namespace, slot);\n        if (!initializedSlots[namespacedSlot]) {\n            revert SlotNotInitialized();\n        }\n        bytes32 value;\n        assembly {\n            value := sload(namespacedSlot)\n        }\n        return value;\n    }\n\n    /**\n     * @dev Generates a namespaced slot\n     * @param namespace The namespace (typically a contract address)\n     * @param slot The storage slot to read from\n     * @return The namespaced slot\n     */\n    function getNamespacedSlot(bytes32 namespace, bytes32 slot) public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(namespace, slot));\n    }\n\n    /**\n     * @dev Generates a namespace for a given account and caller\n     * @param account The account address\n     * @param caller The caller address\n     * @return The generated namespace\n     */\n    function getNamespace(address account, address caller) public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(account, caller));\n    }\n\n    /**\n     * @dev Check if a slot has been initialized\n     */\n    function isSlotInitialized(bytes32 namespace, bytes32 slot) external view returns (bool) {\n        bytes32 namespacedSlot = getNamespacedSlot(namespace, slot);\n        return initializedSlots[namespacedSlot];\n    }\n}\n"},"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"}},"settings":{"remappings":["forge-std/=node_modules/forge-std/src/","account-abstraction/=node_modules/account-abstraction/contracts/","solady/=node_modules/solady/src/","sentinellist/=node_modules/@rhinestone/sentinellist/src/","module-bases/=node_modules/@rhinestone/module-bases/src/","erc7739Validator/=node_modules/@erc7579/erc7739-validator-base/src/","EnumerableSet4337/=node_modules/@erc7579/enumerablemap4337/src/","erc7579/=node_modules/@erc7579/implementation/src/","byteslib/=node_modules/solidity-bytes-utils/contracts/","rlp-reader/=node_modules/solidity-rlp/contracts/","murky-trees/=node_modules/murky/src/","solarray/=node_modules/solarray/src/","excessively-safe-call/=node_modules/excessively-safe-call/src/","@ERC4337/=node_modules/@ERC4337/","@erc7579/=node_modules/@erc7579/","@gnosis.pm/=node_modules/@gnosis.pm/","@openzeppelin/=node_modules/@openzeppelin/","@prb/=node_modules/@prb/","@rhinestone/=node_modules/@rhinestone/","@safe-global/=node_modules/@safe-global/","@zerodev/=node_modules/@zerodev/","account-abstraction-v0.6/=node_modules/account-abstraction-v0.6/","ds-test/=node_modules/ds-test/","hardhat-deploy/=node_modules/hardhat-deploy/","hardhat/=node_modules/hardhat/","solidity-bytes-utils/=node_modules/solidity-bytes-utils/","solidity-rlp/=node_modules/solidity-rlp/"],"optimizer":{"enabled":true,"runs":999},"metadata":{"useLiteralContent":false,"bytecodeHash":"none","appendCBOR":true},"outputSelection":{"*":{"*":["abi","evm.bytecode.object","evm.bytecode.sourceMap","evm.bytecode.linkReferences","evm.deployedBytecode.object","evm.deployedBytecode.sourceMap","evm.deployedBytecode.linkReferences","evm.deployedBytecode.immutableReferences","evm.methodIdentifiers","metadata"]}},"evmVersion":"cancun","viaIR":true,"libraries":{}}}
